{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar logger_1 = require(\"@ethersproject/logger\");\n\nvar _version_1 = require(\"../_version\");\n\nvar logger = new logger_1.Logger(_version_1.version);\n\nvar abstract_coder_1 = require(\"./abstract-coder\");\n\nvar anonymous_1 = require(\"./anonymous\");\n\nfunction pack(writer, coders, values) {\n  if (Array.isArray(values)) {// do nothing\n  } else if (values && typeof values === \"object\") {\n    var arrayValues_1 = [];\n    coders.forEach(function (coder) {\n      arrayValues_1.push(values[coder.localName]);\n    });\n    values = arrayValues_1;\n  } else {\n    logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n  }\n\n  if (coders.length !== values.length) {\n    logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n  }\n\n  var staticWriter = new abstract_coder_1.Writer(writer.wordSize);\n  var dynamicWriter = new abstract_coder_1.Writer(writer.wordSize);\n  var updateFuncs = [];\n  coders.forEach(function (coder, index) {\n    var value = values[index];\n\n    if (coder.dynamic) {\n      // Get current dynamic offset (for the future pointer)\n      var dynamicOffset_1 = dynamicWriter.length; // Encode the dynamic value into the dynamicWriter\n\n      coder.encode(dynamicWriter, value); // Prepare to populate the correct offset once we are done\n\n      var updateFunc_1 = staticWriter.writeUpdatableValue();\n      updateFuncs.push(function (baseOffset) {\n        updateFunc_1(baseOffset + dynamicOffset_1);\n      });\n    } else {\n      coder.encode(staticWriter, value);\n    }\n  }); // Backfill all the dynamic offsets, now that we know the static length\n\n  updateFuncs.forEach(function (func) {\n    func(staticWriter.length);\n  });\n  var length = writer.writeBytes(staticWriter.data);\n  length += writer.writeBytes(dynamicWriter.data);\n  return length;\n}\n\nexports.pack = pack;\n\nfunction unpack(reader, coders) {\n  var values = []; // A reader anchored to this base\n\n  var baseReader = reader.subReader(0); // The amount of dynamic data read; to consume later to synchronize\n\n  var dynamicLength = 0;\n  coders.forEach(function (coder) {\n    var value = null;\n\n    if (coder.dynamic) {\n      var offset = reader.readValue();\n      var offsetReader = baseReader.subReader(offset.toNumber());\n      value = coder.decode(offsetReader);\n      dynamicLength += offsetReader.consumed;\n    } else {\n      value = coder.decode(reader);\n    }\n\n    if (value != undefined) {\n      values.push(value);\n    }\n  }); // @TODO: get rid of this an see if it still works?\n  // Consume the dynamic components in the main reader\n\n  reader.readBytes(dynamicLength); // Add any named parameters (i.e. tuples)\n\n  coders.forEach(function (coder, index) {\n    var name = coder.localName;\n\n    if (!name) {\n      return;\n    }\n\n    if (name === \"length\") {\n      name = \"_length\";\n    }\n\n    if (values[name] != null) {\n      return;\n    }\n\n    values[name] = values[index];\n  });\n  return values;\n}\n\nexports.unpack = unpack;\n\nvar ArrayCoder =\n/** @class */\nfunction (_super) {\n  __extends(ArrayCoder, _super);\n\n  function ArrayCoder(coder, length, localName) {\n    var _this = this;\n\n    var type = coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\";\n    var dynamic = length === -1 || coder.dynamic;\n    _this = _super.call(this, \"array\", type, localName, dynamic) || this;\n    _this.coder = coder;\n    _this.length = length;\n    return _this;\n  }\n\n  ArrayCoder.prototype.encode = function (writer, value) {\n    if (!Array.isArray(value)) {\n      this._throwError(\"expected array value\", value);\n    }\n\n    var count = this.length; //let result = new Uint8Array(0);\n\n    if (count === -1) {\n      count = value.length;\n      writer.writeValue(value.length);\n    }\n\n    logger.checkArgumentCount(count, value.length, \"coder array\" + (this.localName ? \" \" + this.localName : \"\"));\n    var coders = [];\n\n    for (var i = 0; i < value.length; i++) {\n      coders.push(this.coder);\n    }\n\n    return pack(writer, coders, value);\n  };\n\n  ArrayCoder.prototype.decode = function (reader) {\n    var count = this.length;\n\n    if (count === -1) {\n      count = reader.readValue().toNumber();\n    }\n\n    var coders = [];\n\n    for (var i = 0; i < count; i++) {\n      coders.push(new anonymous_1.AnonymousCoder(this.coder));\n    }\n\n    return reader.coerce(this.name, unpack(reader, coders));\n  };\n\n  return ArrayCoder;\n}(abstract_coder_1.Coder);\n\nexports.ArrayCoder = ArrayCoder;","map":null,"metadata":{},"sourceType":"script"}