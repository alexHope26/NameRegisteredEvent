{"ast":null,"code":"const ethUtil = require('ethereumjs-util');\n\nconst Tx = require('ethereumjs-tx');\n\nconst Trie = require('merkle-patricia-tree');\n\nconst BN = ethUtil.BN;\nconst rlp = ethUtil.rlp;\n\nconst async = require('async');\n\nconst BlockHeader = require('./header');\n\nconst params = require('ethereum-common/params.json');\n/**\n * Creates a new block object\n * @constructor the raw serialized or the deserialized block.\n * @param {Array|Buffer|Object} data\n * @prop {Header} header the block's header\n * @prop {Array.<Header>} uncleList an array of uncle headers\n * @prop {Array.<Buffer>} raw an array of buffers containing the raw blocks.\n */\n\n\nvar Block = module.exports = function (data) {\n  this.transactions = [];\n  this.uncleHeaders = [];\n  this._inBlockChain = false;\n  this.txTrie = new Trie();\n  Object.defineProperty(this, 'raw', {\n    get: function () {\n      return this.serialize(false);\n    }\n  });\n  var rawTransactions, rawUncleHeaders; // defaults\n\n  if (!data) {\n    data = [[], [], []];\n  }\n\n  if (Buffer.isBuffer(data)) {\n    data = rlp.decode(data);\n  }\n\n  if (Array.isArray(data)) {\n    this.header = new BlockHeader(data[0]);\n    rawTransactions = data[1];\n    rawUncleHeaders = data[2];\n  } else {\n    this.header = new BlockHeader(data.header);\n    rawTransactions = data.transactions || [];\n    rawUncleHeaders = data.uncleHeaders || [];\n  } // parse uncle headers\n\n\n  for (var i = 0; i < rawUncleHeaders.length; i++) {\n    this.uncleHeaders.push(new BlockHeader(rawUncleHeaders[i]));\n  } // parse transactions\n\n\n  for (i = 0; i < rawTransactions.length; i++) {\n    var tx = new Tx(rawTransactions[i]);\n    tx._homestead = true;\n    this.transactions.push(tx);\n  }\n};\n\nBlock.Header = BlockHeader;\n/**\n * Produces a hash the RLP of the block\n * @method hash\n */\n\nBlock.prototype.hash = function () {\n  return this.header.hash();\n};\n/**\n * Determines if a given block is the genesis block\n * @method isGenisis\n * @return Boolean\n */\n\n\nBlock.prototype.isGenesis = function () {\n  return this.header.isGenesis();\n};\n/**\n * turns the block in to the canonical genesis block\n * @method setGenesisParams\n */\n\n\nBlock.prototype.setGenesisParams = function () {\n  this.header.gasLimit = params.genesisGasLimit.v;\n  this.header.difficulty = params.genesisDifficulty.v;\n  this.header.extraData = params.genesisExtraData.v;\n  this.header.nonce = params.genesisNonce.v;\n  this.header.stateRoot = params.genesisStateRoot.v;\n  this.header.number = new Buffer([]);\n};\n/**\n * Produces a serialization of the block.\n * @method serialize\n * @param {Boolean} rlpEncode whether to rlp encode the block or not\n */\n\n\nBlock.prototype.serialize = function (rlpEncode) {\n  var raw = [this.header.raw, [], []]; // rlpEnode defaults to true\n\n  if (typeof rlpEncode === 'undefined') {\n    rlpEncode = true;\n  }\n\n  this.transactions.forEach(function (tx) {\n    raw[1].push(tx.raw);\n  });\n  this.uncleHeaders.forEach(function (uncle) {\n    raw[2].push(uncle.raw);\n  });\n  return rlpEncode ? rlp.encode(raw) : raw;\n};\n/**\n * Generate transaction trie. The tx trie must be generated before the transaction trie can\n * be validated with `validateTransactionTrie`\n * @method genTxTrie\n * @param {Function} cb the callback\n */\n\n\nBlock.prototype.genTxTrie = function (cb) {\n  var i = 0;\n  var self = this;\n  async.eachSeries(this.transactions, function (tx, done) {\n    self.txTrie.put(rlp.encode(i), tx.serialize(), done);\n    i++;\n  }, cb);\n};\n/**\n * Validates the transaction trie\n * @method validateTransactionTrie\n * @return {Boolean}\n */\n\n\nBlock.prototype.validateTransactionsTrie = function () {\n  var txT = this.header.transactionsTrie.toString('hex');\n\n  if (this.transactions.length) {\n    return txT === this.txTrie.root.toString('hex');\n  } else {\n    return txT === ethUtil.SHA3_RLP.toString('hex');\n  }\n};\n/**\n * Validates the transactions\n * @method validateTransactions\n * @param {Boolean} [stringError=false] whether to return a string with a dscription of why the validation failed or return a Bloolean\n * @return {Boolean}\n */\n\n\nBlock.prototype.validateTransactions = function (stringError) {\n  var errors = [];\n  this.transactions.forEach(function (tx, i) {\n    var error = tx.validate(true);\n\n    if (error) {\n      errors.push(error + ' at tx ' + i);\n    }\n  });\n\n  if (stringError === undefined || stringError === false) {\n    return errors.length === 0;\n  } else {\n    return arrayToString(errors);\n  }\n};\n/**\n * Validates the entire block. Returns a string to the callback if block is invalid\n * @method validate\n * @param {BlockChain} blockChain the blockchain that this block wants to be part of\n * @param {Function} cb the callback which is given a `String` if the block is not valid\n */\n\n\nBlock.prototype.validate = function (blockChain, cb) {\n  var self = this;\n  var errors = [];\n  async.parallel([// validate uncles\n  self.validateUncles.bind(self, blockChain), // validate block\n  self.header.validate.bind(self.header, blockChain), // generate the transaction trie\n  self.genTxTrie.bind(self)], function (err) {\n    if (err) {\n      errors.push(err);\n    }\n\n    if (!self.validateTransactionsTrie()) {\n      errors.push('invalid transaction true');\n    }\n\n    var txErrors = self.validateTransactions(true);\n\n    if (txErrors !== '') {\n      errors.push(txErrors);\n    }\n\n    if (!self.validateUnclesHash()) {\n      errors.push('invild uncle hash');\n    }\n\n    cb(arrayToString(errors));\n  });\n};\n/**\n * Validates the uncle's hash\n * @method validateUncleHash\n * @return {Boolean}\n */\n\n\nBlock.prototype.validateUnclesHash = function () {\n  var raw = [];\n  this.uncleHeaders.forEach(function (uncle) {\n    raw.push(uncle.raw);\n  });\n  raw = rlp.encode(raw);\n  return ethUtil.sha3(raw).toString('hex') === this.header.uncleHash.toString('hex');\n};\n/**\n * Validates the uncles that are in the block if any. Returns a string to the callback if uncles are invalid\n * @method validateUncles\n * @param {Blockchain} blockChaina an instance of the Blockchain\n * @param {Function} cb the callback\n */\n\n\nBlock.prototype.validateUncles = function (blockChain, cb) {\n  if (this.isGenesis()) {\n    return cb();\n  }\n\n  var self = this;\n\n  if (self.uncleHeaders.length > 2) {\n    return cb('too many uncle headers');\n  }\n\n  var uncleHashes = self.uncleHeaders.map(function (header) {\n    return header.hash().toString('hex');\n  });\n\n  if (!(new Set(uncleHashes).size === uncleHashes.length)) {\n    return cb('dublicate unlces');\n  }\n\n  async.each(self.uncleHeaders, function (uncle, cb2) {\n    var height = new BN(self.header.number);\n    async.parallel([uncle.validate.bind(uncle, blockChain, height), // check to make sure the uncle is not already in the blockchain\n    function (cb3) {\n      blockChain.getDetails(uncle.hash(), function (err, blockInfo) {\n        // TODO: remove uncles from BC\n        if (blockInfo && blockInfo.isUncle) {\n          cb3(err || 'uncle already included');\n        } else {\n          cb3();\n        }\n      });\n    }], cb2);\n  }, cb);\n};\n/**\n * Converts the block toJSON\n * @method toJSON\n * @param {Bool} labeled whether to create an labeled object or an array\n * @return {Object}\n */\n\n\nBlock.prototype.toJSON = function (labeled) {\n  if (labeled) {\n    var obj = {\n      header: this.header.toJSON(true),\n      transactions: [],\n      uncleHeaders: []\n    };\n    this.transactions.forEach(function (tx) {\n      obj.transactions.push(tx.toJSON(labeled));\n    });\n    this.uncleHeaders.forEach(function (uh) {\n      obj.uncleHeaders.push(uh.toJSON());\n    });\n    return obj;\n  } else {\n    return ethUtil.baToJSON(this.raw);\n  }\n};\n\nfunction arrayToString(array) {\n  try {\n    return array.reduce(function (str, err) {\n      if (str) {\n        str += ' ';\n      }\n\n      return str + err;\n    });\n  } catch (e) {\n    return '';\n  }\n}","map":null,"metadata":{},"sourceType":"script"}