{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar address_1 = require(\"@ethersproject/address\");\n\nvar bignumber_1 = require(\"@ethersproject/bignumber\");\n\nvar bytes_1 = require(\"@ethersproject/bytes\");\n\nvar hash_1 = require(\"@ethersproject/hash\");\n\nvar keccak256_1 = require(\"@ethersproject/keccak256\");\n\nvar properties_1 = require(\"@ethersproject/properties\");\n\nvar abi_coder_1 = require(\"./abi-coder\");\n\nvar fragments_1 = require(\"./fragments\");\n\nvar logger_1 = require(\"@ethersproject/logger\");\n\nvar _version_1 = require(\"./_version\");\n\nvar logger = new logger_1.Logger(_version_1.version);\n\nvar LogDescription =\n/** @class */\nfunction (_super) {\n  __extends(LogDescription, _super);\n\n  function LogDescription() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return LogDescription;\n}(properties_1.Description);\n\nexports.LogDescription = LogDescription;\n\nvar TransactionDescription =\n/** @class */\nfunction (_super) {\n  __extends(TransactionDescription, _super);\n\n  function TransactionDescription() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return TransactionDescription;\n}(properties_1.Description);\n\nexports.TransactionDescription = TransactionDescription;\n\nvar Indexed =\n/** @class */\nfunction (_super) {\n  __extends(Indexed, _super);\n\n  function Indexed() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Indexed.isIndexed = function (value) {\n    return !!(value && value._isIndexed);\n  };\n\n  return Indexed;\n}(properties_1.Description);\n\nexports.Indexed = Indexed;\n\nvar Result =\n/** @class */\nfunction () {\n  function Result() {}\n\n  return Result;\n}();\n\nexports.Result = Result;\n\nvar Interface =\n/** @class */\nfunction () {\n  function Interface(fragments) {\n    var _newTarget = this.constructor;\n\n    var _this = this;\n\n    logger.checkNew(_newTarget, Interface);\n    var abi = [];\n\n    if (typeof fragments === \"string\") {\n      abi = JSON.parse(fragments);\n    } else {\n      abi = fragments;\n    }\n\n    properties_1.defineReadOnly(this, \"fragments\", abi.map(function (fragment) {\n      return fragments_1.Fragment.from(fragment);\n    }).filter(function (fragment) {\n      return fragment != null;\n    }));\n    properties_1.defineReadOnly(this, \"_abiCoder\", properties_1.getStatic(_newTarget, \"getAbiCoder\")());\n    properties_1.defineReadOnly(this, \"functions\", {});\n    properties_1.defineReadOnly(this, \"errors\", {});\n    properties_1.defineReadOnly(this, \"events\", {});\n    properties_1.defineReadOnly(this, \"structs\", {}); // Add all fragments by their signature\n\n    this.fragments.forEach(function (fragment) {\n      var bucket = null;\n\n      switch (fragment.type) {\n        case \"constructor\":\n          if (_this.deploy) {\n            logger.warn(\"duplicate definition - constructor\");\n            return;\n          }\n\n          properties_1.defineReadOnly(_this, \"deploy\", fragment);\n          return;\n\n        case \"function\":\n          bucket = _this.functions;\n          break;\n\n        case \"event\":\n          bucket = _this.events;\n          break;\n\n        default:\n          return;\n      }\n\n      var signature = fragment.format();\n\n      if (bucket[signature]) {\n        logger.warn(\"duplicate definition - \" + signature);\n        return;\n      }\n\n      bucket[signature] = fragment;\n    }); // Add any fragments with a unique name by its name (sans signature parameters)\n\n    [this.events, this.functions].forEach(function (bucket) {\n      var count = getNameCount(bucket);\n      Object.keys(bucket).forEach(function (signature) {\n        var fragment = bucket[signature];\n\n        if (count[fragment.name] !== 1) {\n          logger.warn(\"duplicate definition - \" + fragment.name);\n          return;\n        }\n\n        bucket[fragment.name] = fragment;\n      });\n    }); // If we do not have a constructor use the default \"constructor() payable\"\n\n    if (!this.deploy) {\n      properties_1.defineReadOnly(this, \"deploy\", fragments_1.ConstructorFragment.from({\n        type: \"constructor\"\n      }));\n    }\n\n    properties_1.defineReadOnly(this, \"_isInterface\", true);\n  }\n\n  Interface.getAbiCoder = function () {\n    return abi_coder_1.defaultAbiCoder;\n  };\n\n  Interface.getAddress = function (address) {\n    return address_1.getAddress(address);\n  };\n\n  Interface.prototype._sighashify = function (functionFragment) {\n    return bytes_1.hexDataSlice(hash_1.id(functionFragment.format()), 0, 4);\n  };\n\n  Interface.prototype._topicify = function (eventFragment) {\n    return hash_1.id(eventFragment.format());\n  };\n\n  Interface.prototype.getFunction = function (nameOrSignatureOrSighash) {\n    if (bytes_1.isHexString(nameOrSignatureOrSighash)) {\n      return getFragment(nameOrSignatureOrSighash, this.getSighash.bind(this), this.functions);\n    } // It is a bare name, look up the function (will return null if ambiguous)\n\n\n    if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n      return this.functions[nameOrSignatureOrSighash.trim()] || null;\n    } // Normlize the signature and lookup the function\n\n\n    return this.functions[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n  };\n\n  Interface.prototype.getEvent = function (nameOrSignatureOrTopic) {\n    if (bytes_1.isHexString(nameOrSignatureOrTopic)) {\n      return getFragment(nameOrSignatureOrTopic, this.getEventTopic.bind(this), this.events);\n    } // It is a bare name, look up the function (will return null if ambiguous)\n\n\n    if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n      return this.events[nameOrSignatureOrTopic];\n    }\n\n    return this.events[fragments_1.EventFragment.fromString(nameOrSignatureOrTopic).format()];\n  };\n\n  Interface.prototype.getSighash = function (functionFragment) {\n    if (typeof functionFragment === \"string\") {\n      functionFragment = this.getFunction(functionFragment);\n    }\n\n    return this._sighashify(functionFragment);\n  };\n\n  Interface.prototype.getEventTopic = function (eventFragment) {\n    if (typeof eventFragment === \"string\") {\n      eventFragment = this.getEvent(eventFragment);\n    }\n\n    return this._topicify(eventFragment);\n  };\n\n  Interface.prototype._encodeParams = function (params, values) {\n    return this._abiCoder.encode(params, values);\n  };\n\n  Interface.prototype.encodeDeploy = function (values) {\n    return this._encodeParams(this.deploy.inputs, values || []);\n  };\n\n  Interface.prototype.encodeFunctionData = function (functionFragment, values) {\n    if (typeof functionFragment === \"string\") {\n      functionFragment = this.getFunction(functionFragment);\n    }\n\n    return bytes_1.hexlify(bytes_1.concat([this.getSighash(functionFragment), this._encodeParams(functionFragment.inputs, values || [])]));\n  };\n\n  Interface.prototype.decodeFunctionResult = function (functionFragment, data) {\n    if (typeof functionFragment === \"string\") {\n      functionFragment = this.getFunction(functionFragment);\n    }\n\n    var bytes = bytes_1.arrayify(data);\n    var reason = null;\n    var errorSignature = null;\n\n    switch (bytes.length % this._abiCoder._getWordSize()) {\n      case 0:\n        try {\n          return this._abiCoder.decode(functionFragment.outputs, bytes);\n        } catch (error) {}\n\n        break;\n\n      case 4:\n        if (bytes_1.hexlify(bytes.slice(0, 4)) === \"0x08c379a0\") {\n          errorSignature = \"Error(string)\";\n          reason = this._abiCoder.decode([\"string\"], bytes.slice(4));\n        }\n\n        break;\n    }\n\n    return logger.throwError(\"call revert exception\", logger_1.Logger.errors.CALL_EXCEPTION, {\n      method: functionFragment.format(),\n      errorSignature: errorSignature,\n      errorArgs: [reason],\n      reason: reason\n    });\n  };\n\n  Interface.prototype.encodeFilterTopics = function (eventFragment, values) {\n    var _this = this;\n\n    if (typeof eventFragment === \"string\") {\n      eventFragment = this.getEvent(eventFragment);\n    }\n\n    if (values.length > eventFragment.inputs.length) {\n      logger.throwError(\"too many arguments for \" + eventFragment.format(), logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {\n        argument: \"values\",\n        value: values\n      });\n    }\n\n    var topics = [];\n\n    if (!eventFragment.anonymous) {\n      topics.push(this.getEventTopic(eventFragment));\n    }\n\n    values.forEach(function (value, index) {\n      var param = eventFragment.inputs[index];\n\n      if (!param.indexed) {\n        if (value != null) {\n          logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n        }\n\n        return;\n      }\n\n      if (value == null) {\n        topics.push(null);\n      } else if (param.type === \"string\") {\n        topics.push(hash_1.id(value));\n      } else if (param.type === \"bytes\") {\n        topics.push(keccak256_1.keccak256(bytes_1.hexlify(value)));\n      } else if (param.type.indexOf(\"[\") !== -1 || param.type.substring(0, 5) === \"tuple\") {\n        logger.throwArgumentError(\"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n      } else {\n        // Check addresses are valid\n        if (param.type === \"address\") {\n          _this._abiCoder.encode([\"address\"], [value]);\n        }\n\n        topics.push(bytes_1.hexZeroPad(bytes_1.hexlify(value), 32));\n      }\n    }); // Trim off trailing nulls\n\n    while (topics.length && topics[topics.length - 1] === null) {\n      topics.pop();\n    }\n\n    return topics;\n  };\n\n  Interface.prototype.decodeEventLog = function (eventFragment, data, topics) {\n    if (typeof eventFragment === \"string\") {\n      eventFragment = this.getEvent(eventFragment);\n    }\n\n    if (topics != null && !eventFragment.anonymous) {\n      var topicHash = this.getEventTopic(eventFragment);\n\n      if (!bytes_1.isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n        logger.throwError(\"fragment/topic mismatch\", logger_1.Logger.errors.INVALID_ARGUMENT, {\n          argument: \"topics[0]\",\n          expected: topicHash,\n          value: topics[0]\n        });\n      }\n\n      topics = topics.slice(1);\n    }\n\n    var indexed = [];\n    var nonIndexed = [];\n    var dynamic = [];\n    eventFragment.inputs.forEach(function (param, index) {\n      if (param.indexed) {\n        if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n          indexed.push(fragments_1.ParamType.fromObject({\n            type: \"bytes32\",\n            name: param.name\n          }));\n          dynamic.push(true);\n        } else {\n          indexed.push(param);\n          dynamic.push(false);\n        }\n      } else {\n        nonIndexed.push(param);\n        dynamic.push(false);\n      }\n    });\n    var resultIndexed = topics != null ? this._abiCoder.decode(indexed, bytes_1.concat(topics)) : null;\n\n    var resultNonIndexed = this._abiCoder.decode(nonIndexed, data);\n\n    var result = [];\n    var nonIndexedIndex = 0,\n        indexedIndex = 0;\n    eventFragment.inputs.forEach(function (param, index) {\n      if (param.indexed) {\n        if (resultIndexed == null) {\n          result[index] = new Indexed({\n            _isIndexed: true,\n            hash: null\n          });\n        } else if (dynamic[index]) {\n          result[index] = new Indexed({\n            _isIndexed: true,\n            hash: resultIndexed[indexedIndex++]\n          });\n        } else {\n          result[index] = resultIndexed[indexedIndex++];\n        }\n      } else {\n        result[index] = resultNonIndexed[nonIndexedIndex++];\n      } //if (param.name && result[param.name] == null) { result[param.name] = result[index]; }\n\n    });\n    return result;\n  };\n\n  Interface.prototype.parseTransaction = function (tx) {\n    var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n\n    if (!fragment) {\n      return null;\n    }\n\n    return new TransactionDescription({\n      args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n      functionFragment: fragment,\n      name: fragment.name,\n      signature: fragment.format(),\n      sighash: this.getSighash(fragment),\n      value: bignumber_1.BigNumber.from(tx.value || \"0\")\n    });\n  };\n\n  Interface.prototype.parseLog = function (log) {\n    var fragment = this.getEvent(log.topics[0]);\n\n    if (!fragment || fragment.anonymous) {\n      return null;\n    } // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n\n\n    return new LogDescription({\n      eventFragment: fragment,\n      name: fragment.name,\n      signature: fragment.format(),\n      topic: this.getEventTopic(fragment),\n      values: this.decodeEventLog(fragment, log.data, log.topics)\n    });\n  };\n  /*\n  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n      if (Interface.isInterface(value)) {\n          return value;\n      }\n      if (typeof(value) === \"string\") {\n          return new Interface(JSON.parse(value));\n      }\n      return new Interface(value);\n  }\n  */\n\n\n  Interface.isInterface = function (value) {\n    return !!(value && value._isInterface);\n  };\n\n  return Interface;\n}();\n\nexports.Interface = Interface;\n\nfunction getFragment(hash, calcFunc, items) {\n  for (var signature in items) {\n    if (signature.indexOf(\"(\") === -1) {\n      continue;\n    }\n\n    var fragment = items[signature];\n\n    if (calcFunc(fragment) === hash) {\n      return fragment;\n    }\n  }\n\n  return null;\n}\n\nfunction getNameCount(fragments) {\n  var unique = {}; // Count each name\n\n  for (var signature in fragments) {\n    var name_1 = fragments[signature].name;\n\n    if (!unique[name_1]) {\n      unique[name_1] = 0;\n    }\n\n    unique[name_1]++;\n  }\n\n  return unique;\n}","map":null,"metadata":{},"sourceType":"script"}