{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar logger_1 = require(\"@ethersproject/logger\");\n\nvar _version_1 = require(\"./_version\");\n\nvar logger = new logger_1.Logger(_version_1.version);\n\nfunction defineReadOnly(object, name, value) {\n  Object.defineProperty(object, name, {\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n}\n\nexports.defineReadOnly = defineReadOnly; // Crawl up the constructor chain to find a static method\n\nfunction getStatic(ctor, key) {\n  for (var i = 0; i < 32; i++) {\n    if (ctor[key]) {\n      return ctor[key];\n    }\n\n    if (!ctor.prototype || typeof ctor.prototype !== \"object\") {\n      break;\n    }\n\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n\n  return null;\n}\n\nexports.getStatic = getStatic;\n\nfunction resolveProperties(object) {\n  var promises = Object.keys(object).map(function (key) {\n    var value = object[key];\n\n    if (!(value instanceof Promise)) {\n      return Promise.resolve({\n        key: key,\n        value: value\n      });\n    }\n\n    return value.then(function (value) {\n      return {\n        key: key,\n        value: value\n      };\n    });\n  });\n  return Promise.all(promises).then(function (results) {\n    var result = {};\n    return results.reduce(function (accum, result) {\n      accum[result.key] = result.value;\n      return accum;\n    }, result);\n  });\n}\n\nexports.resolveProperties = resolveProperties;\n\nfunction checkProperties(object, properties) {\n  if (!object || typeof object !== \"object\") {\n    logger.throwArgumentError(\"invalid object\", \"object\", object);\n  }\n\n  Object.keys(object).forEach(function (key) {\n    if (!properties[key]) {\n      logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n    }\n  });\n}\n\nexports.checkProperties = checkProperties;\n\nfunction shallowCopy(object) {\n  var result = {};\n\n  for (var key in object) {\n    result[key] = object[key];\n  }\n\n  return result;\n}\n\nexports.shallowCopy = shallowCopy;\nvar opaque = {\n  bigint: true,\n  boolean: true,\n  number: true,\n  string: true\n}; // Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\n\nfunction deepCopy(object) {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return object;\n  } // Arrays are mutable, so we need to create a copy\n\n\n  if (Array.isArray(object)) {\n    return Object.freeze(object.map(function (item) {\n      return deepCopy(item);\n    }));\n  }\n\n  if (typeof object === \"object\") {\n    // Immutable objects are safe to just use\n    if (Object.isFrozen(object)) {\n      return object;\n    }\n\n    var result = {};\n\n    for (var key in object) {\n      var value = object[key];\n\n      if (value === undefined) {\n        continue;\n      }\n\n      defineReadOnly(result, key, deepCopy(value));\n    }\n\n    return result;\n  } // The function type is also immutable, so safe to copy by assignment\n\n\n  if (typeof object === \"function\") {\n    return object;\n  }\n\n  throw new Error(\"Cannot deepCopy \" + typeof object);\n}\n\nexports.deepCopy = deepCopy;\n\nvar Description =\n/** @class */\nfunction () {\n  function Description(info) {\n    for (var key in info) {\n      this[key] = deepCopy(info[key]);\n    }\n\n    Object.freeze(this);\n  }\n\n  return Description;\n}();\n\nexports.Description = Description;","map":null,"metadata":{},"sourceType":"script"}