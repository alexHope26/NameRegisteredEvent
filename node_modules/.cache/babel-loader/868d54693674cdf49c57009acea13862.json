{"ast":null,"code":"var inherits = require('inherits');\n\nvar AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN;\n\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator;\n\nvar ltgt = require('ltgt');\n\nvar createRBT = require('functional-red-black-tree');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar globalStore = {}; // In Node, use global.setImmediate. In the browser, use a consistent\n// microtask library to give consistent microtask experience to all browsers\n\nvar setImmediate = require('./immediate');\n\nfunction gt(value) {\n  return ltgt.compare(value, this._end) > 0;\n}\n\nfunction gte(value) {\n  return ltgt.compare(value, this._end) >= 0;\n}\n\nfunction lt(value) {\n  return ltgt.compare(value, this._end) < 0;\n}\n\nfunction lte(value) {\n  return ltgt.compare(value, this._end) <= 0;\n}\n\nfunction MemIterator(db, options) {\n  AbstractIterator.call(this, db);\n  this._limit = options.limit;\n  if (this._limit === -1) this._limit = Infinity;\n  var tree = db._store[db._location];\n  this.keyAsBuffer = options.keyAsBuffer !== false;\n  this.valueAsBuffer = options.valueAsBuffer !== false;\n  this._reverse = options.reverse;\n  this._options = options;\n  this._done = 0;\n\n  if (!this._reverse) {\n    this._incr = 'next';\n    this._start = ltgt.lowerBound(options);\n    this._end = ltgt.upperBound(options);\n\n    if (typeof this._start === 'undefined') {\n      this._tree = tree.begin;\n    } else if (ltgt.lowerBoundInclusive(options)) {\n      this._tree = tree.ge(this._start);\n    } else {\n      this._tree = tree.gt(this._start);\n    }\n\n    if (this._end) {\n      if (ltgt.upperBoundInclusive(options)) {\n        this._test = lte;\n      } else {\n        this._test = lt;\n      }\n    }\n  } else {\n    this._incr = 'prev';\n    this._start = ltgt.upperBound(options);\n    this._end = ltgt.lowerBound(options);\n\n    if (typeof this._start === 'undefined') {\n      this._tree = tree.end;\n    } else if (ltgt.upperBoundInclusive(options)) {\n      this._tree = tree.le(this._start);\n    } else {\n      this._tree = tree.lt(this._start);\n    }\n\n    if (this._end) {\n      if (ltgt.lowerBoundInclusive(options)) {\n        this._test = gte;\n      } else {\n        this._test = gt;\n      }\n    }\n  }\n}\n\ninherits(MemIterator, AbstractIterator);\n\nMemIterator.prototype._next = function (callback) {\n  var key;\n  var value;\n  if (this._done++ >= this._limit) return setImmediate(callback);\n  if (!this._tree.valid) return setImmediate(callback);\n  key = this._tree.key;\n  value = this._tree.value;\n  if (!this._test(key)) return setImmediate(callback);\n  if (this.keyAsBuffer) key = Buffer.from(key);\n  if (this.valueAsBuffer) value = Buffer.from(value);\n\n  this._tree[this._incr]();\n\n  setImmediate(function callNext() {\n    callback(null, key, value);\n  });\n};\n\nMemIterator.prototype._test = function () {\n  return true;\n};\n\nfunction MemDOWN(location) {\n  if (!(this instanceof MemDOWN)) return new MemDOWN(location);\n  AbstractLevelDOWN.call(this, typeof location === 'string' ? location : '');\n  this._location = this.location ? '$' + this.location : '_tree';\n  this._store = this.location ? globalStore : this;\n  this._store[this._location] = this._store[this._location] || createRBT(ltgt.compare);\n}\n\nMemDOWN.clearGlobalStore = function (strict) {\n  if (strict) {\n    Object.keys(globalStore).forEach(function (key) {\n      delete globalStore[key];\n    });\n  } else {\n    globalStore = {};\n  }\n};\n\ninherits(MemDOWN, AbstractLevelDOWN);\n\nMemDOWN.prototype._open = function (options, callback) {\n  var self = this;\n  setImmediate(function callNext() {\n    callback(null, self);\n  });\n};\n\nMemDOWN.prototype._put = function (key, value, options, callback) {\n  if (typeof value === 'undefined' || value === null) value = '';\n\n  var iter = this._store[this._location].find(key);\n\n  if (iter.valid) {\n    this._store[this._location] = iter.update(value);\n  } else {\n    this._store[this._location] = this._store[this._location].insert(key, value);\n  }\n\n  setImmediate(callback);\n};\n\nMemDOWN.prototype._get = function (key, options, callback) {\n  var value = this._store[this._location].get(key);\n\n  if (typeof value === 'undefined') {\n    // 'NotFound' error, consistent with LevelDOWN API\n    return setImmediate(function callNext() {\n      callback(new Error('NotFound'));\n    });\n  }\n\n  if (options.asBuffer !== false && !this._isBuffer(value)) {\n    value = Buffer.from(String(value));\n  }\n\n  setImmediate(function callNext() {\n    callback(null, value);\n  });\n};\n\nMemDOWN.prototype._del = function (key, options, callback) {\n  this._store[this._location] = this._store[this._location].remove(key);\n  setImmediate(callback);\n};\n\nMemDOWN.prototype._batch = function (array, options, callback) {\n  var i = -1;\n  var key;\n  var value;\n  var iter;\n  var len = array.length;\n  var tree = this._store[this._location];\n\n  while (++i < len) {\n    if (!array[i]) continue;\n    key = this._isBuffer(array[i].key) ? array[i].key : String(array[i].key);\n    iter = tree.find(key);\n\n    if (array[i].type === 'put') {\n      value = this._isBuffer(array[i].value) ? array[i].value : String(array[i].value);\n      tree = iter.valid ? iter.update(value) : tree.insert(key, value);\n    } else {\n      tree = iter.remove();\n    }\n  }\n\n  this._store[this._location] = tree;\n  setImmediate(callback);\n};\n\nMemDOWN.prototype._iterator = function (options) {\n  return new MemIterator(this, options);\n};\n\nMemDOWN.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj);\n};\n\nMemDOWN.destroy = function (name, callback) {\n  var key = '$' + name;\n\n  if (key in globalStore) {\n    delete globalStore[key];\n  }\n\n  setImmediate(callback);\n};\n\nmodule.exports = MemDOWN.default = MemDOWN;","map":null,"metadata":{},"sourceType":"script"}