{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bytes_1 = require(\"@ethersproject/bytes\");\n\nvar logger_1 = require(\"@ethersproject/logger\");\n\nvar _version_1 = require(\"./_version\");\n\nvar logger = new logger_1.Logger(_version_1.version);\n\nvar bignumber_1 = require(\"./bignumber\");\n\nvar _constructorGuard = {};\nvar Zero = bignumber_1.BigNumber.from(0);\nvar NegativeOne = bignumber_1.BigNumber.from(-1);\n\nfunction throwFault(message, fault, operation, value) {\n  var params = {\n    fault: fault,\n    operation: operation\n  };\n\n  if (value !== undefined) {\n    params.value = value;\n  }\n\n  return logger.throwError(message, logger_1.Logger.errors.NUMERIC_FAULT, params);\n} // Constant to pull zeros from for multipliers\n\n\nvar zeros = \"0\";\n\nwhile (zeros.length < 256) {\n  zeros += zeros;\n} // Returns a string \"1\" followed by decimal \"0\"s\n\n\nfunction getMultiplier(decimals) {\n  if (typeof decimals !== \"number\") {\n    try {\n      decimals = bignumber_1.BigNumber.from(decimals).toNumber();\n    } catch (e) {}\n  }\n\n  if (typeof decimals === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n    return \"1\" + zeros.substring(0, decimals);\n  }\n\n  return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nfunction formatFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n\n  var multiplier = getMultiplier(decimals); // Make sure wei is a big number (convert as necessary)\n\n  value = bignumber_1.BigNumber.from(value);\n  var negative = value.lt(Zero);\n\n  if (negative) {\n    value = value.mul(NegativeOne);\n  }\n\n  var fraction = value.mod(multiplier).toString();\n\n  while (fraction.length < multiplier.length - 1) {\n    fraction = \"0\" + fraction;\n  } // Strip training 0\n\n\n  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n  var whole = value.div(multiplier).toString();\n  value = whole + \".\" + fraction;\n\n  if (negative) {\n    value = \"-\" + value;\n  }\n\n  return value;\n}\n\nexports.formatFixed = formatFixed;\n\nfunction parseFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n\n  var multiplier = getMultiplier(decimals);\n\n  if (typeof value !== \"string\" || !value.match(/^-?[0-9.,]+$/)) {\n    logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n  }\n\n  if (multiplier.length - 1 === 0) {\n    return bignumber_1.BigNumber.from(value);\n  } // Is it negative?\n\n\n  var negative = value.substring(0, 1) === \"-\";\n\n  if (negative) {\n    value = value.substring(1);\n  }\n\n  if (value === \".\") {\n    logger.throwArgumentError(\"missing value\", \"value\", value);\n  } // Split it into a whole and fractional part\n\n\n  var comps = value.split(\".\");\n\n  if (comps.length > 2) {\n    logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n  }\n\n  var whole = comps[0],\n      fraction = comps[1];\n\n  if (!whole) {\n    whole = \"0\";\n  }\n\n  if (!fraction) {\n    fraction = \"0\";\n  } // Prevent underflow\n\n\n  if (fraction.length > multiplier.length - 1) {\n    throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n  } // Fully pad the string with zeros to get to wei\n\n\n  while (fraction.length < multiplier.length - 1) {\n    fraction += \"0\";\n  }\n\n  var wholeValue = bignumber_1.BigNumber.from(whole);\n  var fractionValue = bignumber_1.BigNumber.from(fraction);\n  var wei = wholeValue.mul(multiplier).add(fractionValue);\n\n  if (negative) {\n    wei = wei.mul(NegativeOne);\n  }\n\n  return wei;\n}\n\nexports.parseFixed = parseFixed;\n\nvar FixedFormat =\n/** @class */\nfunction () {\n  function FixedFormat(constructorGuard, signed, width, decimals) {\n    this.signed = signed;\n    this.width = width;\n    this.decimals = decimals;\n    this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    this._multiplier = getMultiplier(decimals);\n    Object.freeze(this);\n  }\n\n  FixedFormat.from = function (value) {\n    if (value instanceof FixedFormat) {\n      return value;\n    }\n\n    var signed = true;\n    var width = 128;\n    var decimals = 18;\n\n    if (typeof value === \"string\") {\n      if (value === \"fixed\") {// defaults...\n      } else if (value === \"ufixed\") {\n        signed = false;\n      } else if (value != null) {\n        var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n\n        if (!match) {\n          logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n        }\n\n        signed = match[1] !== \"u\";\n        width = parseInt(match[2]);\n        decimals = parseInt(match[3]);\n      }\n    } else if (value) {\n      var check = function (key, type, defaultValue) {\n        if (value[key] == null) {\n          return defaultValue;\n        }\n\n        if (typeof value[key] !== type) {\n          logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n        }\n\n        return value[key];\n      };\n\n      signed = check(\"signed\", \"boolean\", signed);\n      width = check(\"width\", \"number\", width);\n      decimals = check(\"decimals\", \"number\", decimals);\n    }\n\n    if (width % 8) {\n      logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n    }\n\n    if (decimals > 80) {\n      logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n    }\n\n    return new FixedFormat(_constructorGuard, signed, width, decimals);\n  };\n\n  return FixedFormat;\n}();\n\nexports.FixedFormat = FixedFormat;\n\nvar FixedNumber =\n/** @class */\nfunction () {\n  function FixedNumber(constructorGuard, hex, value, format) {\n    var _newTarget = this.constructor;\n    logger.checkNew(_newTarget, FixedNumber);\n    this.format = format;\n    this._hex = hex;\n    this._value = value;\n    this._isFixedNumber = true;\n    Object.freeze(this);\n  }\n\n  FixedNumber.prototype._checkFormat = function (other) {\n    if (this.format.name !== other.format.name) {\n      logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n  };\n\n  FixedNumber.prototype.addUnsafe = function (other) {\n    this._checkFormat(other);\n\n    var a = parseFixed(this._value, this.format.decimals);\n    var b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n  };\n\n  FixedNumber.prototype.subUnsafe = function (other) {\n    this._checkFormat(other);\n\n    var a = parseFixed(this._value, this.format.decimals);\n    var b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n  };\n\n  FixedNumber.prototype.mulUnsafe = function (other) {\n    this._checkFormat(other);\n\n    var a = parseFixed(this._value, this.format.decimals);\n    var b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n  };\n\n  FixedNumber.prototype.divUnsafe = function (other) {\n    this._checkFormat(other);\n\n    var a = parseFixed(this._value, this.format.decimals);\n    var b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n  }; // @TODO: Support other rounding algorithms\n\n\n  FixedNumber.prototype.round = function (decimals) {\n    if (decimals == null) {\n      decimals = 0;\n    }\n\n    if (decimals < 0 || decimals > 80 || decimals % 1) {\n      logger.throwArgumentError(\"invalid decimal cound\", \"decimals\", decimals);\n    } // If we are already in range, we're done\n\n\n    var comps = this.toString().split(\".\");\n\n    if (comps[1].length <= decimals) {\n      return this;\n    } // Bump the value up by the 0.00...0005\n\n\n    var bump = \"0.\" + zeros.substring(0, decimals) + \"5\";\n    comps = this.addUnsafe(FixedNumber.fromString(bump, this.format))._value.split(\".\"); // Now it is safe to truncate\n\n    return FixedNumber.fromString(comps[0] + \".\" + comps[1].substring(0, decimals));\n  };\n\n  FixedNumber.prototype.toString = function () {\n    return this._value;\n  };\n\n  FixedNumber.prototype.toHexString = function (width) {\n    if (width == null) {\n      return this._hex;\n    }\n\n    if (width % 8) {\n      logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n    }\n\n    var hex = bignumber_1.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n    return bytes_1.hexZeroPad(hex, width / 8);\n  };\n\n  FixedNumber.prototype.toUnsafeFloat = function () {\n    return parseFloat(this.toString());\n  };\n\n  FixedNumber.prototype.toFormat = function (format) {\n    return FixedNumber.fromString(this._value, format);\n  };\n\n  FixedNumber.fromValue = function (value, decimals, format) {\n    // If decimals looks more like a format, and there is no format, shift the parameters\n    if (format == null && decimals != null && !bignumber_1.isBigNumberish(decimals)) {\n      format = decimals;\n      decimals = null;\n    }\n\n    if (decimals == null) {\n      decimals = 0;\n    }\n\n    if (format == null) {\n      format = \"fixed\";\n    }\n\n    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n  };\n\n  FixedNumber.fromString = function (value, format) {\n    if (format == null) {\n      format = \"fixed\";\n    }\n\n    var fixedFormat = FixedFormat.from(format);\n    var numeric = parseFixed(value, fixedFormat.decimals);\n\n    if (!fixedFormat.signed && numeric.lt(Zero)) {\n      throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n    }\n\n    var hex = null;\n\n    if (fixedFormat.signed) {\n      hex = numeric.toTwos(fixedFormat.width).toHexString();\n    } else {\n      hex = numeric.toHexString();\n      hex = bytes_1.hexZeroPad(hex, fixedFormat.width / 8);\n    }\n\n    var decimal = formatFixed(numeric, fixedFormat.decimals);\n    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n  };\n\n  FixedNumber.fromBytes = function (value, format) {\n    if (format == null) {\n      format = \"fixed\";\n    }\n\n    var fixedFormat = FixedFormat.from(format);\n\n    if (bytes_1.arrayify(value).length > fixedFormat.width / 8) {\n      throw new Error(\"overflow\");\n    }\n\n    var numeric = bignumber_1.BigNumber.from(value);\n\n    if (fixedFormat.signed) {\n      numeric = numeric.fromTwos(fixedFormat.width);\n    }\n\n    var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n    var decimal = formatFixed(numeric, fixedFormat.decimals);\n    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n  };\n\n  FixedNumber.from = function (value, format) {\n    if (typeof value === \"string\") {\n      return FixedNumber.fromString(value, format);\n    }\n\n    if (bytes_1.isBytes(value)) {\n      return FixedNumber.fromBytes(value, format);\n    }\n\n    try {\n      return FixedNumber.fromValue(value, 0, format);\n    } catch (error) {\n      // Allow NUMERIC_FAULT to bubble up\n      if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT) {\n        throw error;\n      }\n    }\n\n    return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n  };\n\n  FixedNumber.isFixedNumber = function (value) {\n    return !!(value && value._isFixedNumber);\n  };\n\n  return FixedNumber;\n}();\n\nexports.FixedNumber = FixedNumber;","map":null,"metadata":{},"sourceType":"script"}