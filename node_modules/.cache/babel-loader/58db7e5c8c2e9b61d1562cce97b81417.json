{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar async = require('async');\n\nvar utils = require('ethereumjs-util');\n\nvar BN = utils.BN;\n\nvar Bloom = require('./bloom.js');\n\nvar Block = require('ethereumjs-block');\n/**\n * Process a transaction. Run the vm. Transfers eth. Checks balances.\n * @method processTx\n * @param opts\n * @param opts.tx {Transaction} - a transaction\n * @param opts.skipNonce - skips the nonce check\n * @param opts.skipBalance - skips the balance check\n * @param opts.block {Block} needed to process the transaction, if no block is given a default one is created\n * @param cb {Function} - the callback\n */\n\n\nmodule.exports = function (opts, cb) {\n  var self = this;\n  var block = opts.block;\n  var tx = opts.tx;\n  var gasLimit;\n  var results;\n  var basefee; // create a reasonable default if no block is given\n\n  if (!block) {\n    block = new Block();\n  }\n\n  if (new BN(block.header.gasLimit).lt(new BN(tx.gasLimit))) {\n    cb(new Error('tx has a higher gas limit than the block'));\n    return;\n  }\n\n  if (opts.populateCache === undefined) {\n    opts.populateCache = true;\n  } // run everything\n\n\n  async.series([populateCache, runTxHook, runCall, saveTries, flushCache, runAfterTxHook], function (err) {\n    cb(err, results);\n  }); // run the transaction hook\n\n  function runTxHook(cb) {\n    self.emit('beforeTx', tx, cb);\n  } // run the transaction hook\n\n\n  function runAfterTxHook(cb) {\n    self.emit('afterTx', results, cb);\n  }\n  /**\n   * populates the cache with the 'to' and 'from' of the tx\n   */\n\n\n  function populateCache(cb) {\n    var accounts = new Set();\n    accounts.add(tx.from.toString('hex'));\n    accounts.add(block.header.coinbase.toString('hex'));\n\n    if (tx.to.toString('hex') !== '') {\n      accounts.add(tx.to.toString('hex'));\n    }\n\n    if (opts.populateCache === false) {\n      return cb();\n    }\n\n    self.stateManager.warmCache(accounts, cb);\n  } // sets up the environment and runs a `call`\n\n\n  function runCall(cb) {\n    // check to the sender's account to make sure it has enough wei and the correct nonce\n    var fromAccount = self.stateManager.cache.get(tx.from);\n    var message;\n\n    if (!opts.skipBalance && new BN(fromAccount.balance).lt(tx.getUpfrontCost())) {\n      message = \"sender doesn't have enough funds to send tx. The upfront cost is: \" + tx.getUpfrontCost().toString() + ' and the sender\\'s account only has: ' + new BN(fromAccount.balance).toString();\n      cb(new Error(message));\n      return;\n    } else if (!opts.skipNonce && !new BN(fromAccount.nonce).eq(new BN(tx.nonce))) {\n      message = \"the tx doesn't have the correct nonce. account has nonce of: \" + new BN(fromAccount.nonce).toString() + ' tx has nonce of: ' + new BN(tx.nonce).toString();\n      cb(new Error(message));\n      return;\n    } // increment the nonce\n\n\n    fromAccount.nonce = new BN(fromAccount.nonce).addn(1);\n    basefee = tx.getBaseFee();\n    gasLimit = new BN(tx.gasLimit);\n\n    if (gasLimit.lt(basefee)) {\n      return cb(new Error('base fee exceeds gas limit'));\n    }\n\n    gasLimit.isub(basefee);\n    fromAccount.balance = new BN(fromAccount.balance).sub(new BN(tx.gasLimit).mul(new BN(tx.gasPrice)));\n    self.stateManager.cache.put(tx.from, fromAccount);\n    var options = {\n      caller: tx.from,\n      gasLimit: gasLimit,\n      gasPrice: tx.gasPrice,\n      to: tx.to,\n      value: tx.value,\n      data: tx.data,\n      block: block,\n      populateCache: false\n    };\n\n    if (tx.to.toString('hex') === '') {\n      delete options.to;\n    } // run call\n\n\n    self.runCall(options, parseResults);\n\n    function parseResults(err, _results) {\n      if (err) return cb(err);\n      results = _results; // generate the bloom for the tx\n\n      results.bloom = txLogsBloom(results.vm.logs);\n      fromAccount = self.stateManager.cache.get(tx.from); // caculate the total gas used\n\n      results.gasUsed = results.gasUsed.add(basefee); // process any gas refund\n\n      results.gasRefund = results.vm.gasRefund;\n\n      if (results.gasRefund) {\n        if (results.gasRefund.lt(results.gasUsed.divn(2))) {\n          results.gasUsed.isub(results.gasRefund);\n        } else {\n          results.gasUsed.isub(results.gasUsed.divn(2));\n        }\n      }\n\n      results.amountSpent = results.gasUsed.mul(new BN(tx.gasPrice));\n      async.series([updateFromAccount, updateMinerAccount, cleanupAccounts], cb);\n\n      function updateFromAccount(next) {\n        // refund the leftover gas amount\n        var finalFromBalance = new BN(tx.gasLimit).sub(results.gasUsed).mul(new BN(tx.gasPrice)).add(new BN(fromAccount.balance));\n        fromAccount.balance = finalFromBalance;\n        self.stateManager.putAccountBalance(utils.toBuffer(tx.from), finalFromBalance, next);\n      }\n\n      function updateMinerAccount(next) {\n        var minerAccount = self.stateManager.cache.get(block.header.coinbase); // add the amount spent on gas to the miner's account\n\n        minerAccount.balance = new BN(minerAccount.balance).add(results.amountSpent); // save the miner's account\n\n        if (!new BN(minerAccount.balance).isZero()) {\n          self.stateManager.cache.put(block.header.coinbase, minerAccount);\n        }\n\n        next(null);\n      }\n\n      function cleanupAccounts(next) {\n        if (!results.vm.selfdestruct) {\n          results.vm.selfdestruct = {};\n        }\n\n        var keys = Object.keys(results.vm.selfdestruct);\n        keys.forEach(function (s) {\n          self.stateManager.cache.del(Buffer.from(s, 'hex'));\n        });\n        self.stateManager.cleanupTouchedAccounts(next);\n      }\n    }\n  }\n\n  function saveTries(cb) {\n    self.stateManager.commitContracts(cb);\n  }\n\n  function flushCache(cb) {\n    self.stateManager.cache.flush(function () {\n      if (opts.populateCache) {\n        self.stateManager.cache.clear();\n      }\n\n      cb();\n    });\n  }\n};\n/**\n * @method txLogsBloom\n */\n\n\nfunction txLogsBloom(logs) {\n  var bloom = new Bloom();\n\n  if (logs) {\n    for (var i = 0; i < logs.length; i++) {\n      var log = logs[i]; // add the address\n\n      bloom.add(log[0]); // add the topics\n\n      var topics = log[1];\n\n      for (var q = 0; q < topics.length; q++) {\n        bloom.add(topics[q]);\n      }\n    }\n  }\n\n  return bloom;\n}","map":null,"metadata":{},"sourceType":"script"}