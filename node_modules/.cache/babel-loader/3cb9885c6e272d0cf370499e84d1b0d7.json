{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bignumber_1 = require(\"@ethersproject/bignumber\");\n\nvar constants_1 = require(\"@ethersproject/constants\");\n\nvar abstract_coder_1 = require(\"./abstract-coder\");\n\nvar NumberCoder =\n/** @class */\nfunction (_super) {\n  __extends(NumberCoder, _super);\n\n  function NumberCoder(size, signed, localName) {\n    var _this = this;\n\n    var name = (signed ? \"int\" : \"uint\") + size * 8;\n    _this = _super.call(this, name, name, localName, false) || this;\n    _this.size = size;\n    _this.signed = signed;\n    return _this;\n  }\n\n  NumberCoder.prototype.encode = function (writer, value) {\n    var v = bignumber_1.BigNumber.from(value); // Check bounds are safe for encoding\n\n    var maxUintValue = constants_1.MaxUint256.maskn(writer.wordSize * 8);\n\n    if (this.signed) {\n      var bounds = maxUintValue.maskn(this.size * 8 - 1);\n\n      if (v.gt(bounds) || v.lt(bounds.add(constants_1.One).mul(constants_1.NegativeOne))) {\n        this._throwError(\"value out-of-bounds\", value);\n      }\n    } else if (v.lt(constants_1.Zero) || v.gt(maxUintValue.maskn(this.size * 8))) {\n      this._throwError(\"value out-of-bounds\", value);\n    }\n\n    v = v.toTwos(this.size * 8).maskn(this.size * 8);\n\n    if (this.signed) {\n      v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n    }\n\n    return writer.writeValue(v);\n  };\n\n  NumberCoder.prototype.decode = function (reader) {\n    var value = reader.readValue().maskn(this.size * 8);\n\n    if (this.signed) {\n      value = value.fromTwos(this.size * 8);\n    }\n\n    return reader.coerce(this.name, value);\n  };\n\n  return NumberCoder;\n}(abstract_coder_1.Coder);\n\nexports.NumberCoder = NumberCoder;","map":null,"metadata":{},"sourceType":"script"}