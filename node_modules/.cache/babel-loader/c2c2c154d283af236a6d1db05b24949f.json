{"ast":null,"code":"\"use strict\";\n/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n/**\n * Verifies a Merkle Proof.\n * @param rootHash the rootHash of the Trie\n * @param path the path to proof\n * @param proof the serialized nodes\n * @param expectedValue expected value, if null, this function verifies for non existing node.\n * @param errorMsg the error message that should be used in case of not verifiable.\n *\n * The function will return the value of the last node if it was successfull or throw otherwise.\n */\n\n\nfunction verify(rootHash, path, proof, expectedValue, errorMsg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // prepare Error-Message\n    const errorPrefix = errorMsg ? errorMsg + ' : ' : ''; // create the nibbles to iterate over the path\n\n    const key = stringToNibbles(path); // start with the root-Hash\n\n    let wantedHash = rootHash;\n    let lastNode = null; // iterate through the nodes starting at root\n\n    for (let i = 0; i < proof.length; i++) {\n      const p = proof[i];\n      const hash = ethereumjs_util_1.keccak(p); // verify the hash of the node\n\n      if (Buffer.compare(hash, wantedHash)) throw new Error('Bad proof node ' + i + ': hash mismatch'); // create the node\n\n      const node = lastNode = new Node(ethereumjs_util_1.rlp.decode(p));\n\n      switch (node.type) {\n        case 'empty':\n          if (i == 0 && expectedValue === null) return null;\n          throw new Error('invalid empty node here');\n\n        case 'branch':\n          // we reached the end of the path\n          if (key.length === 0) {\n            if (i !== proof.length - 1) throw new Error(errorPrefix + 'Additional nodes at end of proof (branch)'); // our value is a branch, but we can return the value\n            // TODO does this make sense?\n\n            return node.value;\n          } // find the childHash\n\n\n          const childHash = node.raw[key[0]]; // remove the first item\n\n          key.splice(0, 1);\n\n          if (childHash.length === 2) {\n            const embeddedNode = new Node(childHash);\n            if (i !== proof.length - 1) throw new Error(errorPrefix + 'Additional nodes at end of proof (embeddedNode)');\n            if (matchingNibbleLength(embeddedNode.key, key) !== embeddedNode.key.length) throw new Error(errorPrefix + 'Key length does not match with the proof one (embeddedNode)');\n            key.splice(0, embeddedNode.key.length);\n            if (key.length !== 0) throw new Error(errorPrefix + 'Key does not match with the proof one (embeddedNode)'); // all is fine we return the value\n\n            return embeddedNode.value;\n          } else wantedHash = childHash;\n\n          break;\n\n        case 'leaf':\n        case 'extension':\n          const val = node.value; // if the relativeKey in the leaf does not math our rest key, we throw!\n\n          if (matchingNibbleLength(node.key, key) !== node.key.length) {\n            // so we have a wrong leaf here, if we actually expected this node to not exist,\n            // the last node in this path may be a different leaf or a branch with a empty hash\n            if (key.length === node.key.length && i === proof.length - 1 && expectedValue === null) return val;\n            throw new Error(errorPrefix + 'Key does not match with the proof one (extention|leaf)');\n          } // remove the items\n\n\n          key.splice(0, node.key.length);\n\n          if (key.length === 0) {\n            if (i !== proof.length - 1) throw new Error(errorPrefix + 'Additional nodes at end of proof (extention|leaf)'); // if we are expecting a value we need to check\n\n            if (expectedValue && expectedValue.compare(val)) throw new Error(errorPrefix + ' The proven value was expected to be ' + expectedValue.toString('hex') + ' but is ' + val.toString('hex')); // if we are proven a value which shouldn't exist this must throw an error\n\n            if (expectedValue === null) throw new Error(errorPrefix + ' The value shouldn\\'t exist, but is ' + val.toString('hex'));\n            return val;\n          } else // we continue with the hash \n            wantedHash = val;\n\n          break;\n\n        default:\n          throw new Error(errorPrefix + 'Invalid node type');\n      }\n    } // if we expected this to be null and there is not further node since wantedHash is empty or we had a extension as last element, than it is ok not to find leafs\n\n\n    if (expectedValue === null && (lastNode === null || lastNode.type === 'extension' || wantedHash.length === 0)) return null; // we reached the end of the proof, but not of the path\n\n    throw new Error('Unexpected end of proof');\n  });\n}\n\nexports.default = verify;\n\nfunction matchingNibbleLength(a, b) {\n  const i = a.findIndex((_, i) => _ !== b[i]);\n  return i < 0 ? a.length : i + 1;\n}\n\nclass Node {\n  constructor(data) {\n    this.raw = data;\n\n    if (data.length === 17) {\n      this.type = 'branch';\n      this.value = data[16];\n    } else if (data.length === 2) {\n      this.type = data[0][0] >> 4 > 1 ? 'leaf' : 'extension';\n      this.value = data[1];\n      this.key = stringToNibbles(data[0]).slice((data[0][0] >> 4) % 2 ? 1 : 2);\n    } else if (data.length === 0) this.type = 'empty';\n  }\n\n} // create the nibbles of a path\n\n\nconst hexToInt = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15\n};\n\nfunction stringToNibbles(bkey) {\n  return bkey.toString('hex').split('').map(_ => hexToInt[_]);\n}\n\nexports.stringToNibbles = stringToNibbles;","map":null,"metadata":{},"sourceType":"script"}