{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar async = require('async');\n\nvar ethUtil = require('ethereumjs-util');\n\nvar Bloom = require('./bloom.js');\n\nvar common = require('ethereum-common');\n\nvar rlp = ethUtil.rlp;\n\nvar Trie = require('merkle-patricia-tree');\n\nvar BN = ethUtil.BN;\nvar minerReward = new BN(common.minerReward.v);\n/**\n * process the transaction in a block and pays the miners\n * @param opts\n * @param opts.block {Block} the block we are processing\n * @param opts.generate {Boolean} [gen=false] whether to generate the stateRoot\n * @param cb {Function} the callback which is given an error string\n */\n\nmodule.exports = function (opts, cb) {\n  var self = this; // parse options\n\n  var block = opts.block;\n  var generateStateRoot = !!opts.generate;\n  var validateStateRoot = !generateStateRoot;\n  var bloom = new Bloom();\n  var receiptTrie = new Trie(); // the total amount of gas used processing this block\n\n  var gasUsed = new BN(0); // miner account\n\n  var minerAccount;\n  var receipts = [];\n  var txResults = [];\n  var result;\n\n  if (opts.root) {\n    self.stateManager.trie.root = opts.root;\n  }\n\n  this.trie.checkpoint(); // run everything\n\n  async.series([beforeBlock, populateCache, processTransactions], parseBlockResults);\n\n  function beforeBlock(cb) {\n    self.emit('beforeBlock', opts.block, cb);\n  }\n\n  function afterBlock(cb) {\n    self.emit('afterBlock', result, cb);\n  } // populates the cache with accounts that we know we will need\n\n\n  function populateCache(cb) {\n    var accounts = new Set();\n    accounts.add(block.header.coinbase.toString('hex'));\n    block.transactions.forEach(function (tx) {\n      accounts.add(tx.getSenderAddress().toString('hex'));\n      accounts.add(tx.to.toString('hex'));\n    });\n    block.uncleHeaders.forEach(function (uh) {\n      accounts.add(uh.coinbase.toString('hex'));\n    });\n    self.populateCache(accounts, cb);\n  }\n  /**\n   * Processes all of the transaction in the block\n   * @method processTransaction\n   * @param {Function} cb the callback is given error if there are any\n   */\n\n\n  function processTransactions(cb) {\n    var validReceiptCount = 0;\n    async.eachSeries(block.transactions, processTx, cb);\n\n    function processTx(tx, cb) {\n      var gasLimitIsHigherThanBlock = new BN(block.header.gasLimit).lt(new BN(tx.gasLimit).add(gasUsed));\n\n      if (gasLimitIsHigherThanBlock) {\n        cb(new Error('tx has a higher gas limit than the block'));\n        return;\n      } // run the tx through the VM\n\n\n      self.runTx({\n        tx: tx,\n        block: block,\n        populateCache: false\n      }, parseTxResult);\n\n      function parseTxResult(err, result) {\n        txResults.push(result); // var receiptResult = new BN(1)\n        // abort if error\n\n        if (err) {\n          receipts.push(null);\n          cb(err);\n          return;\n        }\n\n        gasUsed = gasUsed.add(result.gasUsed); // combine blooms via bitwise OR\n\n        bloom.or(result.bloom);\n\n        if (generateStateRoot) {\n          block.header.bloom = bloom.bitvector;\n        }\n\n        var txLogs = result.vm.logs || [];\n        var rawTxReceipt = [result.vm.exception ? 1 : 0, // result.vm.exception is 0 when an exception occurs, and 1 when it doesn't.  TODO make this the opposite\n        gasUsed.toArrayLike(Buffer), result.bloom.bitvector, txLogs];\n        var txReceipt = {\n          status: rawTxReceipt[0],\n          gasUsed: rawTxReceipt[1],\n          bitvector: rawTxReceipt[2],\n          logs: rawTxReceipt[3]\n        };\n        receipts.push(txReceipt);\n        receiptTrie.put(rlp.encode(validReceiptCount), rlp.encode(rawTxReceipt));\n        validReceiptCount++;\n        cb();\n      }\n    }\n  } // handle results or error from block run\n\n\n  function parseBlockResults(err) {\n    if (err) {\n      self.trie.revert();\n      cb(err);\n      return;\n    } // credit all block rewards\n\n\n    payOmmersAndMiner(); // credit all block rewards\n\n    if (generateStateRoot) {\n      block.header.stateRoot = self.trie.root;\n    }\n\n    self.trie.commit(function (err) {\n      self.stateManager.cache.flush(function () {\n        if (validateStateRoot) {\n          if (receiptTrie.root && receiptTrie.root.toString('hex') !== block.header.receiptTrie.toString('hex')) {\n            err = new Error((err || '') + 'invalid receiptTrie ');\n          }\n\n          if (bloom.bitvector.toString('hex') !== block.header.bloom.toString('hex')) {\n            err = new Error((err || '') + 'invalid bloom ');\n          }\n\n          if (ethUtil.bufferToInt(block.header.gasUsed) !== Number(gasUsed)) {\n            err = new Error((err || '') + 'invalid gasUsed ');\n          }\n\n          if (self.trie.root.toString('hex') !== block.header.stateRoot.toString('hex')) {\n            err = new Error((err || '') + 'invalid block stateRoot ');\n          }\n        }\n\n        self.stateManager.cache.clear();\n        result = {\n          receipts: receipts,\n          results: txResults,\n          error: err\n        };\n        afterBlock(cb.bind(this, err, result));\n      });\n    });\n  } // credit all block rewards\n\n\n  function payOmmersAndMiner() {\n    var ommers = block.uncleHeaders; // pay each ommer\n\n    ommers.forEach(rewardOmmer); // calculate nibling reward\n\n    var niblingReward = minerReward.divn(32);\n    var totalNiblingReward = niblingReward.muln(ommers.length);\n    minerAccount = self.stateManager.cache.get(block.header.coinbase); // give miner the block reward\n\n    minerAccount.balance = new BN(minerAccount.balance).add(minerReward).add(totalNiblingReward);\n    self.stateManager.cache.put(block.header.coinbase, minerAccount);\n  } // credit ommer\n\n\n  function rewardOmmer(ommer) {\n    // calculate reward\n    var heightDiff = new BN(block.header.number).sub(new BN(ommer.number));\n    var reward = new BN(8).sub(heightDiff).mul(minerReward.divn(8));\n\n    if (reward.ltn(0)) {\n      reward = new BN(0);\n    } // credit miners account\n\n\n    var ommerAccount = self.stateManager.cache.get(ommer.coinbase);\n    ommerAccount.balance = reward.add(new BN(ommerAccount.balance));\n    self.stateManager.cache.put(ommer.coinbase, ommerAccount);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}