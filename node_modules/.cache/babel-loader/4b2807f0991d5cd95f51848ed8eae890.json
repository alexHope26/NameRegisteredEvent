{"ast":null,"code":"const levelup = require('levelup');\n\nconst memdown = require('memdown');\n\nconst async = require('async');\n\nconst inherits = require('util').inherits;\n\nconst Readable = require('readable-stream').Readable;\n\nconst levelws = require('level-ws');\n\nconst callTogether = require('./util').callTogether;\n\nmodule.exports = checkpointInterface;\n\nfunction checkpointInterface(trie) {\n  this._scratch = null;\n  trie._checkpoints = [];\n  Object.defineProperty(trie, 'isCheckpoint', {\n    get: function () {\n      return !!trie._checkpoints.length;\n    }\n  }); // new methods\n\n  trie.checkpoint = checkpoint;\n  trie.commit = commit;\n  trie.revert = revert;\n  trie._enterCpMode = _enterCpMode;\n  trie._exitCpMode = _exitCpMode;\n  trie.createScratchReadStream = createScratchReadStream; // overwrites\n\n  trie.copy = copy.bind(trie, trie.copy.bind(trie));\n}\n/**\n * Creates a checkpoint that can later be reverted to or committed. After this is called, no changes to the trie will be permanently saved until `commit` is called\n * @method checkpoint\n */\n\n\nfunction checkpoint() {\n  var self = this;\n  var wasCheckpoint = self.isCheckpoint;\n\n  self._checkpoints.push(self.root);\n\n  if (!wasCheckpoint && self.isCheckpoint) {\n    self._enterCpMode();\n  }\n}\n/**\n * commits a checkpoint to disk\n * @method commit\n * @param {Function} cb the callback\n */\n\n\nfunction commit(cb) {\n  var self = this;\n  cb = callTogether(cb, self.sem.leave);\n  self.sem.take(function () {\n    if (self.isCheckpoint) {\n      self._checkpoints.pop();\n\n      if (!self.isCheckpoint) {\n        self._exitCpMode(true, cb);\n      } else {\n        cb();\n      }\n    } else {\n      throw new Error('trying to commit when not checkpointed');\n    }\n  });\n}\n/**\n * Reverts the trie to the state it was at when `checkpoint` was first called.\n * @method revert\n * @param {Function} cb the callback\n */\n\n\nfunction revert(cb) {\n  var self = this;\n  cb = callTogether(cb, self.sem.leave);\n  self.sem.take(function () {\n    if (self.isCheckpoint) {\n      self.root = self._checkpoints.pop();\n\n      if (!self.isCheckpoint) {\n        self._exitCpMode(false, cb);\n\n        return;\n      }\n    }\n\n    cb();\n  });\n} // enter into checkpoint mode\n\n\nfunction _enterCpMode() {\n  this._scratch = levelup('', {\n    db: memdown\n  });\n  this._getDBs = [this._scratch].concat(this._getDBs);\n  this.__putDBs = this._putDBs;\n  this._putDBs = [this._scratch];\n  this._putRaw = this.putRaw;\n  this.putRaw = putRaw;\n} // exit from checkpoint mode\n\n\nfunction _exitCpMode(commitState, cb) {\n  var self = this;\n  var scratch = this._scratch;\n  this._scratch = null;\n  this._getDBs = this._getDBs.slice(1);\n  this._putDBs = this.__putDBs;\n  this.putRaw = this._putRaw;\n\n  function flushScratch(db, cb) {\n    if (!db.createWriteStream) {\n      db = levelws(db);\n    }\n\n    self.createScratchReadStream(scratch).pipe(db.createWriteStream()).on('close', cb);\n  }\n\n  if (commitState) {\n    async.map(this._putDBs, flushScratch, cb);\n  } else {\n    cb();\n  }\n} // adds the interface when copying the trie\n\n\nfunction copy(_super) {\n  var trie = _super();\n\n  checkpointInterface.call(trie, trie);\n  trie._scratch = this._scratch; // trie._checkpoints = this._checkpoints.slice()\n\n  return trie;\n}\n\nfunction putRaw(key, val, cb) {\n  function dbPut(db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2);\n  }\n\n  async.each(this.__putDBs, dbPut, cb);\n}\n\nfunction createScratchReadStream(scratch) {\n  var trie = this.copy();\n  scratch = scratch || this._scratch; // only read from the scratch\n\n  trie._getDBs = [scratch];\n  trie._scratch = scratch;\n  return new ScratchReadStream(trie);\n} // ScratchReadStream\n// this is used to minimally dump the scratch into the db\n\n\ninherits(ScratchReadStream, Readable);\n\nfunction ScratchReadStream(trie) {\n  this.trie = trie;\n  this.next = null;\n  Readable.call(this, {\n    objectMode: true\n  });\n}\n\nScratchReadStream.prototype._read = function () {\n  var self = this;\n\n  if (!self._started) {\n    self._started = true;\n\n    self.trie._findDbNodes(function (nodeRef, node, key, next) {\n      self.push({\n        key: nodeRef,\n        value: node.serialize()\n      });\n      next();\n    }, function () {\n      // close stream\n      self.push(null);\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}