{"ast":null,"code":"\"use strict\";\n/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it    *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst Tx = require(\"ethereumjs-tx\");\n\nconst util_1 = require(\"../../util/util\");\n/** RLP-functions */\n\n\nexports.rlp = ethUtil.rlp;\n/** serialize the data  */\n\nexports.serialize = val => exports.rlp.encode(val);\n/** returns the hash of the object */\n\n\nexports.hash = val => Array.isArray(val) ? ethUtil.rlphash(val) : ethUtil.keccak(val); // types ...\n\n/** converts it to a Buffer with 256 bytes length */\n\n\nexports.bytes256 = val => util_1.toBuffer(val, 256);\n/** converts it to a Buffer with 32 bytes length */\n\n\nexports.bytes32 = val => util_1.toBuffer(val, 32);\n/** converts it to a Buffer with 8 bytes length */\n\n\nexports.bytes8 = val => util_1.toBuffer(val, 8);\n/** converts it to a Buffer  */\n\n\nexports.bytes = val => util_1.toBuffer(val);\n/** converts it to a Buffer with 20 bytes length */\n\n\nexports.address = val => util_1.toBuffer(val, 20);\n/** converts it to a Buffer with a variable length. 0 = length 0*/\n\n\nexports.uint = val => util_1.toBuffer(val, 0);\n\nexports.uint64 = val => util_1.toBuffer(val, 8);\n/** create a Buffer[] from RPC-Response */\n\n\nexports.toBlockHeader = block => [exports.bytes32(block.parentHash), exports.bytes32(block.sha3Uncles), exports.address(block.miner || block.coinbase), exports.bytes32(block.stateRoot), exports.bytes32(block.transactionsRoot), exports.bytes32(block.receiptsRoot || block.receiptRoot), exports.bytes256(block.logsBloom), exports.uint(block.difficulty), exports.uint(block.number), exports.uint(block.gasLimit), exports.uint(block.gasUsed), exports.uint(block.timestamp), exports.bytes(block.extraData), ...(block.sealFields ? block.sealFields.map(s => exports.rlp.decode(exports.bytes(s))) : [exports.bytes32(block.mixHash), exports.bytes8(block.nonce)])];\n/** create a Buffer[] from RPC-Response */\n\n\nexports.toTransaction = tx => [exports.uint(tx.nonce), exports.uint(tx.gasPrice), exports.uint(tx.gas || tx.gasLimit), tx.to ? exports.address(tx.to) : Buffer.alloc(0), exports.uint(tx.value), exports.bytes(tx.input || tx.data), exports.uint(tx.v), exports.uint(tx.r), exports.uint(tx.s)]; // encode the account\n\n\nexports.toAccount = account => [exports.uint(account.nonce), exports.uint(account.balance), exports.bytes32(account.storageHash || ethUtil.KECCAK256_RLP), exports.bytes32(account.codeHash || ethUtil.KECCAK256_NULL)];\n/** create a Buffer[] from RPC-Response */\n\n\nexports.toReceipt = r => [exports.uint(r.status || r.root), exports.uint(r.cumulativeGasUsed), exports.bytes256(r.logsBloom), r.logs.map(l => [exports.address(l.address), l.topics.map(exports.bytes32), exports.bytes(l.data)])].slice(r.status === null && r.root === null ? 1 : 0);\n/**\n * encodes and decodes the blockheader\n */\n\n\nclass Block {\n  get parentHash() {\n    return this.raw[0];\n  }\n\n  get uncleHash() {\n    return this.raw[1];\n  }\n\n  get coinbase() {\n    return this.raw[2];\n  }\n\n  get stateRoot() {\n    return this.raw[3];\n  }\n\n  get transactionsTrie() {\n    return this.raw[4];\n  }\n\n  get receiptTrie() {\n    return this.raw[5];\n  }\n\n  get bloom() {\n    return this.raw[6];\n  }\n\n  get difficulty() {\n    return this.raw[7];\n  }\n\n  get number() {\n    return this.raw[8];\n  }\n\n  get gasLimit() {\n    return this.raw[9];\n  }\n\n  get gasUsed() {\n    return this.raw[10];\n  }\n\n  get timestamp() {\n    return this.raw[11];\n  }\n\n  get extra() {\n    return this.raw[12];\n  }\n\n  get sealedFields() {\n    return this.raw.slice(13);\n  }\n  /** creates a Block-Onject from either the block-data as returned from rpc, a buffer or a hex-string of the encoded blockheader */\n\n\n  constructor(data) {\n    if (Buffer.isBuffer(data)) this.raw = ethUtil.rlp.decode(data);else if (typeof data === 'string') this.raw = ethUtil.rlp.decode(Buffer.from(data.replace('0x', ''), 'hex'));else if (typeof data === 'object') {\n      this.raw = exports.toBlockHeader(data);\n      if (data.transactions && typeof data.transactions[0] === 'object') this.transactions = data.transactions.map(createTx);\n    }\n  }\n  /** the blockhash as buffer */\n\n\n  hash() {\n    return exports.hash(this.raw);\n  }\n  /** the blockhash as buffer without the seal fields*/\n\n\n  bareHash() {\n    return exports.hash(this.raw.slice(0, 13));\n  }\n  /** the serialized header as buffer */\n\n\n  serializeHeader() {\n    return exports.serialize(this.raw);\n  }\n\n}\n\nexports.Block = Block;\n/** creates a Transaction-object from the rpc-transaction-data */\n\nfunction createTx(transaction) {\n  const txParams = Object.assign({}, transaction, {\n    nonce: util_1.toHex(transaction.nonce) || '0x00',\n    gasPrice: util_1.toHex(transaction.gasPrice) || '0x00',\n    value: util_1.toHex(transaction.value || 0),\n    gasLimit: util_1.toHex(transaction.gasLimit === undefined ? transaction.gas : transaction.gasLimit),\n    data: util_1.toHex(transaction.gasLimit === undefined ? transaction.input : transaction.data),\n    to: transaction.to ? ethUtil.setLengthLeft(ethUtil.toBuffer(transaction.to), 20) : null,\n    v: transaction.v < 27 ? transaction.v + 27 : transaction.v\n  });\n  const fromAddress = ethUtil.toBuffer(txParams.from);\n  delete txParams.from;\n  const tx = new Tx(txParams);\n  tx._from = fromAddress;\n\n  tx.getSenderAddress = function () {\n    return fromAddress;\n  };\n\n  if (txParams.hash && txParams.hash !== '0x' + ethUtil.keccak(tx.serialize()).toString('hex')) throw new Error('wrong txhash! : ' + (txParams.hash + '!== 0x' + ethUtil.keccak(tx.serialize()).toString('hex')) + '  full tx=' + tx.serialize().toString('hex')); // override hash\n\n  const txHash = ethUtil.toBuffer(txParams.hash);\n  if (txParams.hash) tx.hash = function () {\n    return txHash;\n  };\n  return tx;\n}\n\nexports.createTx = createTx;\n/** converts blockdata to a hexstring*/\n\nfunction blockToHex(block) {\n  return util_1.toHex(new Block(block).serializeHeader());\n}\n\nexports.blockToHex = blockToHex;\n/** converts a hexstring to a block-object */\n\nfunction blockFromHex(hex) {\n  return new Block(hex);\n}\n\nexports.blockFromHex = blockFromHex;","map":null,"metadata":{},"sourceType":"script"}