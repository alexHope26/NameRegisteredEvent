{"ast":null,"code":"\"use strict\";\n/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst cbor = require(\"cbor\");\n/**\n * turn\n */\n\n\nfunction encodeRequests(requests) {\n  return cbor.encode(requests.map(r => [r.id, r.method, convertToBuffer(r.params), convertToBuffer(r.in3)]));\n}\n\nexports.encodeRequests = encodeRequests;\n\nfunction decodeRequests(request) {\n  return cbor.decode(request).map(r => ({\n    jsonrpc: '2.0',\n    id: r[0],\n    method: r[1],\n    params: convertToHex(r[2]),\n    in3: convertToHex(r[3])\n  }));\n}\n\nexports.decodeRequests = decodeRequests;\n\nfunction encodeResponses(responses) {\n  return cbor.encode(responses.map(r => [r.id, convertToBuffer(r.result), r.error, convertToBuffer(r.in3)]));\n}\n\nexports.encodeResponses = encodeResponses;\n\nfunction decodeResponses(responses) {\n  return cbor.decode(responses).map(r => ({\n    jsonrpc: '2.0',\n    id: r[0],\n    result: convertToHex(r[1]),\n    error: r[2],\n    in3: convertToHex(r[3])\n  }));\n}\n\nexports.decodeResponses = decodeResponses;\n\nfunction convertToBuffer(val) {\n  switch (typeof val) {\n    case 'string':\n      return val.startsWith('0x') ? Buffer.from((val.length % 2 ? '0' : '') + val.substr(2), 'hex') : val;\n\n    case 'object':\n      if (val === null) return null;\n      return Array.isArray(val) ? val.map(convertToBuffer) : Object.keys(val).reduce((p, c) => {\n        p[c] = convertToBuffer(val[c]);\n        return p;\n      }, {});\n\n    default:\n      return val;\n  }\n}\n\nfunction convertToHex(val) {\n  if (Buffer.isBuffer(val)) return '0x' + val.toString('hex');\n\n  switch (typeof val) {\n    case 'object':\n      if (val === null) return null;\n      return Array.isArray(val) ? val.map(convertToHex) : Object.keys(val).reduce((p, c) => {\n        p[c] = convertToHex(val[c]);\n        return p;\n      }, {});\n\n    default:\n      return val;\n  }\n}\n\nfunction createRefs(val, cache = []) {\n  switch (typeof val) {\n    case 'string':\n      const s = val;\n\n      if (s.startsWith('0x')) {\n        const i = cache.indexOf(s);\n        if (i >= 0) return ':' + i;\n        cache.push(s);\n      }\n\n      return val;\n\n    case 'object':\n      if (val === null) return null;\n      return Array.isArray(val) ? val.map(_ => createRefs(_, cache)) : Object.keys(val).reduce((p, c) => {\n        p[c] = createRefs(val[c], cache);\n        return p;\n      }, {});\n\n    default:\n      return val;\n  }\n}\n\nexports.createRefs = createRefs;\n\nfunction resolveRefs(val, cache = []) {\n  switch (typeof val) {\n    case 'string':\n      const s = val;\n      if (s.startsWith('0x')) cache.push(s);\n      if (s.startsWith(':')) return cache[parseInt(s.substr(1))];\n      return val;\n\n    case 'object':\n      if (val === null) return null;\n      return Array.isArray(val) ? val.map(_ => resolveRefs(_, cache)) : Object.keys(val).reduce((p, c) => {\n        p[c] = resolveRefs(val[c], cache);\n        return p;\n      }, {});\n\n    default:\n      return val;\n  }\n}\n\nexports.resolveRefs = resolveRefs;","map":null,"metadata":{},"sourceType":"script"}