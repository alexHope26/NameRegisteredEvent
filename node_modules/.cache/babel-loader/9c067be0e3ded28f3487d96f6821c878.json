{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar async = require('async');\n\nvar ethUtil = require('ethereumjs-util');\n\nvar BN = ethUtil.BN;\n\nvar fees = require('ethereum-common');\n\nvar exceptions = require('./exceptions.js');\n\nvar ERROR = exceptions.ERROR;\n/**\n * runs a CALL operation\n * @method runCall\n * @param opts\n * @param opts.block {Block}\n * @param opts.caller {Buffer}\n * @param opts.code {Buffer} this is for CALLCODE where the code to load is different than the code from the to account.\n * @param opts.data {Buffer}\n * @param opts.gasLimit {Buffer | BN.js }\n * @param opts.gasPrice {Buffer}\n * @param opts.origin {Buffer} []\n * @param opts.to {Buffer}\n * @param opts.value {Buffer}\n */\n\nmodule.exports = function (opts, cb) {\n  var self = this;\n  var stateManager = self.stateManager;\n  var vmResults = {};\n  var toAccount;\n  var toAddress = opts.to;\n  var createdAddress;\n  var txValue = opts.value || Buffer.from([0]);\n  var caller = opts.caller;\n  var account = stateManager.cache.get(caller);\n  var block = opts.block;\n  var code = opts.code;\n  var txData = opts.data;\n  var gasLimit = opts.gasLimit || new BN(0xffffff);\n  gasLimit = new BN(opts.gasLimit); // make sure is a BN\n\n  var gasPrice = opts.gasPrice;\n  var gasUsed = new BN(0);\n  var origin = opts.origin;\n  var isCompiled = opts.compiled;\n  var depth = opts.depth; // opts.suicides is kept for backward compatiblity with pre-EIP6 syntax\n\n  var selfdestruct = opts.selfdestruct || opts.suicides;\n  var delegatecall = opts.delegatecall || false;\n  var isStatic = opts.static || false;\n  txValue = new BN(txValue);\n  stateManager.checkpoint(); // run and parse\n\n  async.series([subTxValue, loadToAccount, addTxValue, loadCode, runCode, saveCode], parseCallResult);\n\n  function loadToAccount(done) {\n    // get receiver's account\n    // toAccount = stateManager.cache.get(toAddress)\n    if (!toAddress) {\n      // generate a new contract if no `to`\n      code = txData;\n      txData = undefined;\n      var newNonce = new BN(account.nonce).subn(1);\n      createdAddress = toAddress = ethUtil.generateAddress(caller, newNonce.toArray());\n      stateManager.getAccount(createdAddress, function (err, account) {\n        toAccount = account;\n        var NONCE_OFFSET = 1;\n        toAccount.nonce = new BN(toAccount.nonce).addn(NONCE_OFFSET).toArrayLike(Buffer);\n        done(err);\n      });\n    } else {\n      // else load the `to` account\n      toAccount = stateManager.cache.get(toAddress);\n      done();\n    }\n  }\n\n  function subTxValue(cb) {\n    if (delegatecall) {\n      cb();\n      return;\n    }\n\n    var newBalance = new BN(account.balance).sub(txValue);\n    account.balance = newBalance;\n    stateManager.putAccountBalance(ethUtil.toBuffer(caller), newBalance, cb);\n  }\n\n  function addTxValue(cb) {\n    if (delegatecall) {\n      cb();\n      return;\n    } // add the amount sent to the `to` account\n\n\n    var newBalance = new BN(toAccount.balance).add(txValue);\n    toAccount.balance = newBalance; // putAccount as the nonce may have changed for contract creation\n\n    stateManager.putAccount(ethUtil.toBuffer(toAddress), toAccount, cb);\n  }\n\n  function loadCode(cb) {\n    // loads the contract's code if the account is a contract\n    if (code || !(toAccount.isContract() || self._precompiled[toAddress.toString('hex')])) {\n      cb();\n      return;\n    }\n\n    if (self._precompiled[toAddress.toString('hex')]) {\n      isCompiled = true;\n      code = self._precompiled[toAddress.toString('hex')];\n      cb();\n      return;\n    }\n\n    stateManager.getContractCode(toAddress, function (err, c, comp) {\n      if (err) return cb(err);\n      isCompiled = comp;\n      code = c;\n      cb();\n    });\n  }\n\n  function runCode(cb) {\n    if (!code) {\n      vmResults.exception = 1;\n      stateManager.commit(cb);\n      return;\n    }\n\n    var runCodeOpts = {\n      code: code,\n      data: txData,\n      gasLimit: gasLimit,\n      gasPrice: gasPrice,\n      address: toAddress,\n      origin: origin,\n      caller: caller,\n      value: txValue.toArrayLike(Buffer),\n      block: block,\n      depth: depth,\n      selfdestruct: selfdestruct,\n      populateCache: false,\n      static: isStatic // run Code through vm\n\n    };\n    var codeRunner = isCompiled ? self.runJIT : self.runCode;\n    codeRunner.call(self, runCodeOpts, parseRunResult);\n\n    function parseRunResult(err, results) {\n      toAccount = self.stateManager.cache.get(toAddress);\n      vmResults = results;\n\n      if (createdAddress) {\n        // fee for size of the return value\n        var totalGas = results.gasUsed;\n\n        if (!results.runState.vmError) {\n          var returnFee = new BN(results.return.length * fees.createDataGas.v);\n          totalGas = totalGas.add(returnFee);\n        } // if not enough gas\n\n\n        if (totalGas.lte(gasLimit) && (self.allowUnlimitedContractSize || results.return.length <= 24576)) {\n          results.gasUsed = totalGas;\n        } else {\n          results.return = Buffer.alloc(0); // since Homestead\n\n          results.exception = 0;\n          err = results.exceptionError = ERROR.OUT_OF_GAS;\n          results.gasUsed = gasLimit;\n        }\n      }\n\n      gasUsed = results.gasUsed;\n\n      if (err) {\n        results.logs = [];\n        stateManager.revert(cb);\n      } else {\n        stateManager.commit(cb);\n      }\n    }\n  }\n\n  function saveCode(cb) {\n    // store code for a new contract\n    if (createdAddress && !vmResults.runState.vmError && vmResults.return && vmResults.return.toString() !== '') {\n      stateManager.putContractCode(createdAddress, vmResults.return, cb);\n    } else {\n      cb();\n    }\n  }\n\n  function parseCallResult(err) {\n    if (err) return cb(err);\n    var results = {\n      gasUsed: gasUsed,\n      createdAddress: createdAddress,\n      vm: vmResults\n    };\n    cb(null, results);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}