{"ast":null,"code":"'use strict';\n\nvar async = require('async');\n/**\n * processes blocks and adds them to the blockchain\n * @method onBlock\n * @param blockchain\n */\n\n\nmodule.exports = function (blockchain, cb) {\n  var self = this;\n  var headBlock, parentState;\n  self.blockchain = self.stateManager.blockchain; // parse arguments\n\n  if (typeof blockchain === 'function') {\n    cb = blockchain;\n  } else if (blockchain) {\n    self.blockchain = blockchain;\n  } // setup blockchain iterator\n\n\n  self.blockchain.iterator('vm', processBlock, cb);\n\n  function processBlock(block, reorg, cb) {\n    async.series([getStartingState, runBlock], cb); // determine starting state for block run\n\n    function getStartingState(cb) {\n      // if we are just starting or if a chain re-org has happened\n      if (!headBlock || reorg) {\n        self.blockchain.getBlock(block.header.parentHash, function (err, parentBlock) {\n          parentState = parentBlock.header.stateRoot; // generate genesis state if we are at the genesis block\n          // we don't have the genesis state\n\n          if (!headBlock) {\n            return self.stateManager.generateCanonicalGenesis(cb);\n          } else {\n            cb(err);\n          }\n        });\n      } else {\n        parentState = headBlock.header.stateRoot;\n        cb();\n      }\n    } // run block, update head if valid\n\n\n    function runBlock(cb) {\n      self.runBlock({\n        block: block,\n        root: parentState\n      }, function (err, results) {\n        if (err) {\n          // remove invalid block\n          console.log('Invalid block error:', err);\n          self.blockchain.delBlock(block.header.hash(), cb);\n        } else {\n          // set as new head block\n          headBlock = block;\n          cb();\n        }\n      });\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}