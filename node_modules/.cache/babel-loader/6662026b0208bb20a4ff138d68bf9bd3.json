{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar logger_1 = require(\"@ethersproject/logger\");\n\nvar _version_1 = require(\"./_version\");\n\nvar logger = new logger_1.Logger(_version_1.version); ///////////////////////////////\n\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\n\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n  };\n\n  return array;\n}\n\nfunction isBytesLike(value) {\n  return isHexString(value) && !(value.length % 2) || isBytes(value);\n}\n\nexports.isBytesLike = isBytesLike;\n\nfunction isBytes(value) {\n  if (value == null) {\n    return false;\n  }\n\n  if (value.constructor === Uint8Array) {\n    return true;\n  }\n\n  if (typeof value === \"string\") {\n    return false;\n  }\n\n  if (value.length == null) {\n    return false;\n  }\n\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n\n    if (v < 0 || v >= 256 || v % 1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isBytes = isBytes;\n\nfunction arrayify(value, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid arrayify value\");\n    var result = [];\n\n    while (value) {\n      result.unshift(value & 0xff);\n      value /= 256;\n    }\n\n    if (result.length === 0) {\n      result.push(0);\n    }\n\n    return addSlice(new Uint8Array(result));\n  }\n\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n\n  if (isHexString(value)) {\n    var hex = value.substring(2);\n\n    if (!options.allowOddLength && hex.length % 2) {\n      logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n    }\n\n    var result = [];\n\n    for (var i = 0; i < hex.length; i += 2) {\n      result.push(parseInt(hex.substring(i, i + 2), 16));\n    }\n\n    return addSlice(new Uint8Array(result));\n  }\n\n  if (isBytes(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n\n  return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexports.arrayify = arrayify;\n\nfunction concat(items) {\n  var objects = items.map(function (item) {\n    return arrayify(item);\n  });\n  var length = objects.reduce(function (accum, item) {\n    return accum + item.length;\n  }, 0);\n  var result = new Uint8Array(length);\n  objects.reduce(function (offset, object) {\n    result.set(object, offset);\n    return offset + object.length;\n  }, 0);\n  return addSlice(result);\n}\n\nexports.concat = concat;\n\nfunction stripZeros(value) {\n  var result = arrayify(value);\n\n  if (result.length === 0) {\n    return result;\n  } // Find the first non-zero entry\n\n\n  var start = 0;\n\n  while (start < result.length && result[start] === 0) {\n    start++;\n  } // If we started with zeros, strip them\n\n\n  if (start) {\n    result = result.slice(start);\n  }\n\n  return result;\n}\n\nexports.stripZeros = stripZeros;\n\nfunction zeroPad(value, length) {\n  value = arrayify(value);\n\n  if (value.length > length) {\n    logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n  }\n\n  var result = new Uint8Array(length);\n  result.set(value, length - value.length);\n  return addSlice(result);\n}\n\nexports.zeroPad = zeroPad;\n\nfunction isHexString(value, length) {\n  if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isHexString = isHexString;\nvar HexCharacters = \"0123456789abcdef\";\n\nfunction hexlify(value, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid hexlify value\");\n    var hex = \"\";\n\n    while (value) {\n      hex = HexCharacters[value & 0x0f] + hex;\n      value = Math.floor(value / 16);\n    }\n\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = \"0\" + hex;\n      }\n\n      return \"0x\" + hex;\n    }\n\n    return \"0x00\";\n  }\n\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n\n  if (isHexString(value)) {\n    if (!options.allowOddLength && value.length % 2) {\n      logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n    }\n\n    return value.toLowerCase();\n  }\n\n  if (isBytes(value)) {\n    var result = \"0x\";\n\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n      result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n\n    return result;\n  }\n\n  return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\nexports.hexlify = hexlify;\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\n\nfunction hexDataLength(data) {\n  if (typeof data !== \"string\") {\n    data = hexlify(data);\n  } else if (!isHexString(data) || data.length % 2) {\n    return null;\n  }\n\n  return (data.length - 2) / 2;\n}\n\nexports.hexDataLength = hexDataLength;\n\nfunction hexDataSlice(data, offset, endOffset) {\n  if (typeof data !== \"string\") {\n    data = hexlify(data);\n  } else if (!isHexString(data) || data.length % 2) {\n    logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n  }\n\n  offset = 2 + 2 * offset;\n\n  if (endOffset != null) {\n    return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n  }\n\n  return \"0x\" + data.substring(offset);\n}\n\nexports.hexDataSlice = hexDataSlice;\n\nfunction hexConcat(items) {\n  var result = \"0x\";\n  items.forEach(function (item) {\n    result += hexlify(item).substring(2);\n  });\n  return result;\n}\n\nexports.hexConcat = hexConcat;\n\nfunction hexValue(value) {\n  var trimmed = hexStripZeros(hexlify(value, {\n    allowOddLength: true\n  }));\n\n  if (trimmed === \"0x\") {\n    return \"0x0\";\n  }\n\n  return trimmed;\n}\n\nexports.hexValue = hexValue;\n\nfunction hexStripZeros(value) {\n  if (typeof value !== \"string\") {\n    value = hexlify(value);\n  }\n\n  if (!isHexString(value)) {\n    logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n  }\n\n  value = value.substring(2);\n  var offset = 0;\n\n  while (offset < value.length && value[offset] === \"0\") {\n    offset++;\n  }\n\n  return \"0x\" + value.substring(offset);\n}\n\nexports.hexStripZeros = hexStripZeros;\n\nfunction hexZeroPad(value, length) {\n  if (typeof value !== \"string\") {\n    value = hexlify(value);\n  } else if (!isHexString(value)) {\n    logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n  }\n\n  if (value.length > 2 * length + 2) {\n    logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n  }\n\n  while (value.length < 2 * length + 2) {\n    value = \"0x0\" + value.substring(2);\n  }\n\n  return value;\n}\n\nexports.hexZeroPad = hexZeroPad;\n\nfunction splitSignature(signature) {\n  var result = {\n    r: \"0x\",\n    s: \"0x\",\n    _vs: \"0x\",\n    recoveryParam: 0,\n    v: 0\n  };\n\n  if (isBytesLike(signature)) {\n    var bytes = arrayify(signature);\n\n    if (bytes.length !== 65) {\n      logger.throwArgumentError(\"invalid signature string; must be 65 bytes\", \"signature\", signature);\n    } // Get the r and s\n\n\n    result.r = hexlify(bytes.slice(0, 32));\n    result.s = hexlify(bytes.slice(32, 64)); // Reduce v to the canonical 27 or 28\n\n    result.v = bytes[64];\n\n    if (result.v !== 27 && result.v !== 28) {\n      result.v = 27 + result.v % 2;\n    } // Compute recoveryParam from v\n\n\n    result.recoveryParam = result.v - 27; // Compute _vs from recoveryParam and s\n\n    if (result.recoveryParam) {\n      bytes[32] |= 0x80;\n    }\n\n    result._vs = hexlify(bytes.slice(32, 64));\n  } else {\n    result.r = signature.r;\n    result.s = signature.s;\n    result.v = signature.v;\n    result.recoveryParam = signature.recoveryParam;\n    result._vs = signature._vs; // Normalize v into a canonical 27 or 28\n\n    if (result.v != null && !(result.v == 27 || result.v == 28)) {\n      result.v = 27 + result.v % 2;\n    } // Populate a missing v or recoveryParam if possible\n\n\n    if (result.recoveryParam == null && result.v != null) {\n      result.recoveryParam = 1 - result.v % 2;\n    } else if (result.recoveryParam != null && result.v == null) {\n      result.v = 27 + result.recoveryParam;\n    } else if (result.recoveryParam != null && result.v != null) {\n      if (result.v !== 27 + result.recoveryParam) {\n        logger.throwArgumentError(\"signature v mismatch recoveryParam\", \"signature\", signature);\n      }\n    } // Make sure r and s are padded properly\n\n\n    if (result.r != null) {\n      result.r = hexZeroPad(result.r, 32);\n    }\n\n    if (result.s != null) {\n      result.s = hexZeroPad(result.s, 32);\n    } // If the _vs is available, use it to populate missing s, v and recoveryParam\n    // and verify non-missing s, v and recoveryParam\n\n\n    if (result._vs != null) {\n      result._vs = hexZeroPad(result._vs, 32);\n\n      if (result._vs.length > 66) {\n        logger.throwArgumentError(\"signature _vs overflow\", \"signature\", signature);\n      }\n\n      var vs = arrayify(result._vs);\n      var recoveryParam = vs[0] >= 128 ? 1 : 0;\n      var v = 27 + result.recoveryParam; // Use _vs to compute s\n\n      vs[0] &= 0x7f;\n      var s = hexlify(vs); // Check _vs aggress with other parameters\n\n      if (result.s == null) {\n        result.s = s;\n      } else if (result.s !== s) {\n        logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n      }\n\n      if (result.v == null) {\n        result.v = v;\n      } else if (result.v !== v) {\n        logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n      }\n\n      if (recoveryParam == null) {\n        result.recoveryParam = recoveryParam;\n      } else if (result.recoveryParam !== recoveryParam) {\n        logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n      }\n    } // After all populating, both v and recoveryParam are still missing...\n\n\n    if (result.v == null && result.recoveryParam == null) {\n      logger.throwArgumentError(\"signature requires at least one of recoveryParam, v or _vs\", \"signature\", signature);\n    } // Check for canonical v\n\n\n    if (result.v !== 27 && result.v !== 28) {\n      logger.throwArgumentError(\"signature v not canonical\", \"signature\", signature);\n    } // Check that r and s are in range\n\n\n    if (result.r.length > 66 || result.s.length > 66) {\n      logger.throwArgumentError(\"signature overflow r or s\", \"signature\", signature);\n    }\n\n    if (result._vs == null) {\n      var vs = arrayify(result.s);\n\n      if (vs[0] >= 128) {\n        logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n      }\n\n      if (result.recoveryParam) {\n        vs[0] |= 0x80;\n      }\n\n      result._vs = hexlify(vs);\n    }\n  }\n\n  return result;\n}\n\nexports.splitSignature = splitSignature;\n\nfunction joinSignature(signature) {\n  signature = splitSignature(signature);\n  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? \"0x1c\" : \"0x1b\"]));\n}\n\nexports.joinSignature = joinSignature;","map":null,"metadata":{},"sourceType":"script"}