{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _permanentCensorErrors = false;\nvar _censorErrors = false;\nvar LogLevels = {\n  debug: 1,\n  \"default\": 2,\n  info: 2,\n  warn: 3,\n  error: 4,\n  off: 5\n};\nvar LogLevel = LogLevels[\"default\"];\n\nvar _version_1 = require(\"./_version\");\n\nvar _globalLogger = null;\n\nfunction _checkNormalize() {\n  try {\n    var missing_1 = []; // Make sure all forms of normalization are supported\n\n    [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach(function (form) {\n      try {\n        if (\"test\".normalize(form) !== \"test\") {\n          throw new Error(\"bad normalize\");\n        }\n\n        ;\n      } catch (error) {\n        missing_1.push(form);\n      }\n    });\n\n    if (missing_1.length) {\n      throw new Error(\"missing \" + missing_1.join(\", \"));\n    }\n\n    if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n      throw new Error(\"broken implementation\");\n    }\n  } catch (error) {\n    return error.message;\n  }\n\n  return null;\n}\n\nvar _normalizeError = _checkNormalize();\n\nvar Logger =\n/** @class */\nfunction () {\n  function Logger(version) {\n    Object.defineProperty(this, \"version\", {\n      enumerable: true,\n      value: version,\n      writable: false\n    });\n  }\n\n  Logger.prototype.setLogLevel = function (logLevel) {\n    var level = LogLevels[logLevel];\n\n    if (level == null) {\n      this.warn(\"invliad log level - \" + logLevel);\n      return;\n    }\n\n    LogLevel = level;\n  };\n\n  Logger.prototype._log = function (logLevel, args) {\n    if (LogLevel > LogLevels[logLevel]) {\n      return;\n    }\n\n    console.log.apply(console, args);\n  };\n\n  Logger.prototype.debug = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    this._log(Logger.levels.DEBUG, args);\n  };\n\n  Logger.prototype.info = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    this._log(Logger.levels.INFO, args);\n  };\n\n  Logger.prototype.warn = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    this._log(Logger.levels.WARNING, args);\n  };\n\n  Logger.prototype.makeError = function (message, code, params) {\n    if (_censorErrors) {\n      return new Error(\"unknown error\");\n    }\n\n    if (!code) {\n      code = Logger.errors.UNKNOWN_ERROR;\n    }\n\n    if (!params) {\n      params = {};\n    }\n\n    var messageDetails = [];\n    Object.keys(params).forEach(function (key) {\n      try {\n        messageDetails.push(key + \"=\" + JSON.stringify(params[key]));\n      } catch (error) {\n        messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n      }\n    });\n    messageDetails.push(\"version=\" + this.version);\n    var reason = message;\n\n    if (messageDetails.length) {\n      message += \" (\" + messageDetails.join(\", \") + \")\";\n    } // @TODO: Any??\n\n\n    var error = new Error(message);\n    error.reason = reason;\n    error.code = code;\n    Object.keys(params).forEach(function (key) {\n      error[key] = params[key];\n    });\n    return error;\n  };\n\n  Logger.prototype.throwError = function (message, code, params) {\n    throw this.makeError(message, code, params);\n  };\n\n  Logger.prototype.throwArgumentError = function (message, name, value) {\n    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n      argument: name,\n      value: value\n    });\n  };\n\n  Logger.prototype.checkNormalize = function (message) {\n    if (message == null) {\n      message = \"platform missing String.prototype.normalize\";\n    }\n\n    if (_normalizeError) {\n      this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"String.prototype.normalize\",\n        form: _normalizeError\n      });\n    }\n  };\n\n  Logger.prototype.checkSafeUint53 = function (value, message) {\n    if (typeof value !== \"number\") {\n      return;\n    }\n\n    if (message == null) {\n      message = \"value not safe\";\n    }\n\n    if (value < 0 || value >= 0x1fffffffffffff) {\n      this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n        operation: \"checkSafeInteger\",\n        fault: \"out-of-safe-range\",\n        value: value\n      });\n    }\n\n    if (value % 1) {\n      this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n        operation: \"checkSafeInteger\",\n        fault: \"non-integer\",\n        value: value\n      });\n    }\n  };\n\n  Logger.prototype.checkArgumentCount = function (count, expectedCount, message) {\n    if (message) {\n      message = \": \" + message;\n    } else {\n      message = \"\";\n    }\n\n    if (count < expectedCount) {\n      this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n        count: count,\n        expectedCount: expectedCount\n      });\n    }\n\n    if (count > expectedCount) {\n      this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n        count: count,\n        expectedCount: expectedCount\n      });\n    }\n  };\n\n  Logger.prototype.checkNew = function (target, kind) {\n    if (target === Object || target == null) {\n      this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n        name: kind.name\n      });\n    }\n  };\n\n  Logger.prototype.checkAbstract = function (target, kind) {\n    if (target === kind) {\n      this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, {\n        name: target.name,\n        operation: \"new\"\n      });\n    } else if (target === Object || target == null) {\n      this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n        name: kind.name\n      });\n    }\n  };\n\n  Logger.globalLogger = function () {\n    if (!_globalLogger) {\n      _globalLogger = new Logger(_version_1.version);\n    }\n\n    return _globalLogger;\n  };\n\n  Logger.setCensorship = function (censorship, permanent) {\n    if (_permanentCensorErrors) {\n      if (!censorship) {\n        return;\n      }\n\n      this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"setCensorship\"\n      });\n    }\n\n    _censorErrors = !!censorship;\n    _permanentCensorErrors = !!permanent;\n  };\n\n  Logger.errors = {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    UNKNOWN_ERROR: \"UNKNOWN_ERROR\",\n    // Not Implemented\n    NOT_IMPLEMENTED: \"NOT_IMPLEMENTED\",\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION: \"UNSUPPORTED_OPERATION\",\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    NETWORK_ERROR: \"NETWORK_ERROR\",\n    // Some sort of bad response from the server\n    SERVER_ERROR: \"SERVER_ERROR\",\n    // Timeout\n    TIMEOUT: \"TIMEOUT\",\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    BUFFER_OVERRUN: \"BUFFER_OVERRUN\",\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT: \"NUMERIC_FAULT\",\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW: \"MISSING_NEW\",\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT: \"INVALID_ARGUMENT\",\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT: \"MISSING_ARGUMENT\",\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT: \"UNEXPECTED_ARGUMENT\",\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION: \"CALL_EXCEPTION\",\n    // Insufficien funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS: \"INSUFFICIENT_FUNDS\",\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED: \"NONCE_EXPIRED\",\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED: \"REPLACEMENT_UNDERPRICED\",\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT: \"UNPREDICTABLE_GAS_LIMIT\"\n  };\n  Logger.levels = {\n    DEBUG: \"DEBUG\",\n    INFO: \"INFO\",\n    WARNING: \"WARNING\",\n    ERROR: \"ERROR\",\n    OFF: \"OFF\"\n  };\n  return Logger;\n}();\n\nexports.Logger = Logger;","map":null,"metadata":{},"sourceType":"script"}