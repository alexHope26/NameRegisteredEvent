{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bignumber_1 = require(\"@ethersproject/bignumber\");\n\nvar properties_1 = require(\"@ethersproject/properties\");\n\nvar logger_1 = require(\"@ethersproject/logger\");\n\nvar _version_1 = require(\"./_version\");\n\nvar logger = new logger_1.Logger(_version_1.version);\n;\nvar _constructorGuard = {};\nvar ModifiersBytes = {\n  calldata: true,\n  memory: true,\n  storage: true\n};\n\nfunction checkModifier(type, name) {\n  if (type === \"bytes\" || type === \"string\") {\n    if (ModifiersBytes[name]) {\n      return true;\n    }\n  } else if (type === \"address\") {\n    if (name === \"payable\") {\n      return true;\n    }\n  }\n\n  if (ModifiersBytes[name] || name === \"payable\") {\n    logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n  }\n\n  return false;\n} // @TODO: Make sure that children of an indexed tuple are marked with a null indexed\n\n\nfunction parseParamType(param, allowIndexed) {\n  var originalParam = param;\n\n  function throwError(i) {\n    throw new Error(\"unexpected character '\" + originalParam[i] + \"' at position \" + i + \" in '\" + originalParam + \"'\");\n  }\n\n  param = param.replace(/\\s/g, \" \");\n\n  function newNode(parent) {\n    var node = {\n      type: \"\",\n      name: \"\",\n      parent: parent,\n      state: {\n        allowType: true\n      }\n    };\n\n    if (allowIndexed) {\n      node.indexed = false;\n    }\n\n    return node;\n  }\n\n  var parent = {\n    type: \"\",\n    name: \"\",\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n\n    switch (c) {\n      case \"(\":\n        if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [newNode(node)];\n        node = node.components[0];\n        break;\n\n      case \")\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case \",\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        var sibling = newNode(node.parent); //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case \" \":\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== \"\") {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== \"\") {\n            if (node.name === \"indexed\") {\n              if (!allowIndexed) {\n                throwError(i);\n              }\n\n              if (node.indexed) {\n                throwError(i);\n              }\n\n              node.indexed = true;\n              node.name = \"\";\n            } else if (checkModifier(node.type, node.name)) {\n              node.name = \"\";\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n\n        break;\n\n      case \"[\":\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n\n      case \"]\":\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    throw new Error(\"unexpected eof\");\n  }\n\n  delete parent.state;\n\n  if (node.name === \"indexed\") {\n    if (!allowIndexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    if (node.indexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    node.indexed = true;\n    node.name = \"\";\n  } else if (checkModifier(node.type, node.name)) {\n    node.name = \"\";\n  }\n\n  parent.type = verifyType(parent.type);\n  return parent;\n}\n\nfunction populate(object, params) {\n  for (var key in params) {\n    properties_1.defineReadOnly(object, key, params[key]);\n  }\n}\n\nexports.FormatTypes = Object.freeze({\n  // Bare formatting, as is needed for computing a sighash of an event or function\n  sighash: \"sighash\",\n  // Human-Readable with Minimal spacing and without names (compact human-readable)\n  minimal: \"minimal\",\n  // Human-Readble with nice spacing, including all names\n  full: \"full\",\n  // JSON-format a la Solidity\n  json: \"json\"\n});\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nvar ParamType =\n/** @class */\nfunction () {\n  function ParamType(constructorGuard, params) {\n    if (constructorGuard !== _constructorGuard) {\n      throw new Error(\"use fromString\");\n    }\n\n    populate(this, params);\n    var match = this.type.match(paramTypeArray);\n\n    if (match) {\n      populate(this, {\n        arrayLength: parseInt(match[2] || \"-1\"),\n        arrayChildren: ParamType.fromObject({\n          type: match[1],\n          components: this.components\n        }),\n        baseType: \"array\"\n      });\n    } else {\n      populate(this, {\n        arrayLength: null,\n        arrayChildren: null,\n        baseType: this.components != null ? \"tuple\" : this.type\n      });\n    }\n\n    this._isParamType = true;\n    Object.freeze(this);\n  } // Format the parameter fragment\n  //   - sighash: \"(uint256,address)\"\n  //   - minimal: \"tuple(uint256,address) indexed\"\n  //   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\n\n\n  ParamType.prototype.format = function (format) {\n    if (!format) {\n      format = exports.FormatTypes.sighash;\n    }\n\n    if (!exports.FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === exports.FormatTypes.json) {\n      var result_1 = {\n        type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n        name: this.name || undefined\n      };\n\n      if (typeof this.indexed === \"boolean\") {\n        result_1.indexed = this.indexed;\n      }\n\n      if (this.components) {\n        result_1.components = this.components.map(function (comp) {\n          return JSON.parse(comp.format(format));\n        });\n      }\n\n      return JSON.stringify(result_1);\n    }\n\n    var result = \"\"; // Array\n\n    if (this.baseType === \"array\") {\n      result += this.arrayChildren.format(format);\n      result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n    } else {\n      if (this.baseType === \"tuple\") {\n        if (format !== exports.FormatTypes.sighash) {\n          result += this.type;\n        }\n\n        result += \"(\" + this.components.map(function (comp) {\n          return comp.format(format);\n        }).join(format === exports.FormatTypes.full ? \", \" : \",\") + \")\";\n      } else {\n        result += this.type;\n      }\n    }\n\n    if (format !== exports.FormatTypes.sighash) {\n      if (this.indexed === true) {\n        result += \" indexed\";\n      }\n\n      if (format === exports.FormatTypes.full && this.name) {\n        result += \" \" + this.name;\n      }\n    }\n\n    return result;\n  };\n\n  ParamType.from = function (value, allowIndexed) {\n    if (typeof value === \"string\") {\n      return ParamType.fromString(value, allowIndexed);\n    }\n\n    return ParamType.fromObject(value);\n  };\n\n  ParamType.fromObject = function (value) {\n    if (ParamType.isParamType(value)) {\n      return value;\n    }\n\n    return new ParamType(_constructorGuard, {\n      name: value.name || null,\n      type: verifyType(value.type),\n      indexed: value.indexed == null ? null : !!value.indexed,\n      components: value.components ? value.components.map(ParamType.fromObject) : null\n    });\n  };\n\n  ParamType.fromString = function (value, allowIndexed) {\n    function ParamTypify(node) {\n      return ParamType.fromObject({\n        name: node.name,\n        type: node.type,\n        indexed: node.indexed,\n        components: node.components\n      });\n    }\n\n    return ParamTypify(parseParamType(value, !!allowIndexed));\n  };\n\n  ParamType.isParamType = function (value) {\n    return !!(value != null && value._isParamType);\n  };\n\n  return ParamType;\n}();\n\nexports.ParamType = ParamType;\n;\n\nfunction parseParams(value, allowIndex) {\n  return splitNesting(value).map(function (param) {\n    return ParamType.fromString(param, allowIndex);\n  });\n}\n\nvar Fragment =\n/** @class */\nfunction () {\n  function Fragment(constructorGuard, params) {\n    if (constructorGuard !== _constructorGuard) {\n      throw new Error(\"use a static from method\");\n    }\n\n    populate(this, params);\n    this._isFragment = true;\n    Object.freeze(this);\n  }\n\n  Fragment.from = function (value) {\n    if (Fragment.isFragment(value)) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return Fragment.fromString(value);\n    }\n\n    return Fragment.fromObject(value);\n  };\n\n  Fragment.fromObject = function (value) {\n    if (Fragment.isFragment(value)) {\n      return value;\n    }\n\n    if (value.type === \"function\") {\n      return FunctionFragment.fromObject(value);\n    } else if (value.type === \"event\") {\n      return EventFragment.fromObject(value);\n    } else if (value.type === \"constructor\") {\n      return ConstructorFragment.fromObject(value);\n    } else if (value.type === \"fallback\") {\n      // @TODO:\n      return null;\n    }\n\n    return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n  };\n\n  Fragment.fromString = function (value) {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    value = value.replace(/\\s/g, \" \");\n    value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n    value = value.trim();\n\n    if (value.split(\" \")[0] === \"event\") {\n      return EventFragment.fromString(value.substring(5).trim());\n    } else if (value.split(\" \")[0] === \"function\") {\n      return FunctionFragment.fromString(value.substring(8).trim());\n    } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n      return ConstructorFragment.fromString(value.trim());\n    }\n\n    throw new Error(\"unknown fragment\");\n  };\n\n  Fragment.isFragment = function (value) {\n    return !!(value && value._isFragment);\n  };\n\n  return Fragment;\n}();\n\nexports.Fragment = Fragment;\n\nvar EventFragment =\n/** @class */\nfunction (_super) {\n  __extends(EventFragment, _super);\n\n  function EventFragment() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  EventFragment.prototype.format = function (format) {\n    if (!format) {\n      format = exports.FormatTypes.sighash;\n    }\n\n    if (!exports.FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === exports.FormatTypes.json) {\n      return JSON.stringify({\n        type: \"event\",\n        anonymous: this.anonymous,\n        name: this.name,\n        inputs: this.inputs.map(function (input) {\n          return JSON.parse(input.format(format));\n        })\n      });\n    }\n\n    var result = \"\";\n\n    if (format !== exports.FormatTypes.sighash) {\n      result += \"event \";\n    }\n\n    result += this.name + \"(\" + this.inputs.map(function (input) {\n      return input.format(format);\n    }).join(format === exports.FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (format !== exports.FormatTypes.sighash) {\n      if (this.anonymous) {\n        result += \"anonymous \";\n      }\n    }\n\n    return result.trim();\n  };\n\n  EventFragment.from = function (value) {\n    if (typeof value === \"string\") {\n      return EventFragment.fromString(value);\n    }\n\n    return EventFragment.fromObject(value);\n  };\n\n  EventFragment.fromObject = function (value) {\n    if (EventFragment.isEventFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"event\") {\n      throw new Error(\"invalid event object - \" + value.type);\n    }\n\n    return new EventFragment(_constructorGuard, {\n      name: verifyIdentifier(value.name),\n      anonymous: value.anonymous,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      type: \"event\"\n    });\n  };\n\n  EventFragment.fromString = function (value) {\n    var match = value.match(regexParen);\n\n    if (!match) {\n      throw new Error(\"invalid event: \" + value);\n    }\n\n    var anonymous = false;\n    match[3].split(\" \").forEach(function (modifier) {\n      switch (modifier.trim()) {\n        case \"anonymous\":\n          anonymous = true;\n          break;\n\n        case \"\":\n          break;\n\n        default:\n          logger.warn(\"unknown modifier: \" + modifier);\n      }\n    });\n    return EventFragment.fromObject({\n      name: match[1].trim(),\n      anonymous: anonymous,\n      inputs: parseParams(match[2], true),\n      type: \"event\"\n    });\n  };\n\n  EventFragment.isEventFragment = function (value) {\n    return value && value._isFragment && value.type === \"event\";\n  };\n\n  return EventFragment;\n}(Fragment);\n\nexports.EventFragment = EventFragment;\n\nfunction parseGas(value, params) {\n  params.gas = null;\n  var comps = value.split(\"@\");\n\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      throw new Error(\"invalid signature\");\n    }\n\n    if (!comps[1].match(/^[0-9]+$/)) {\n      throw new Error(\"invalid signature gas\");\n    }\n\n    params.gas = bignumber_1.BigNumber.from(comps[1]);\n    return comps[0];\n  }\n\n  return value;\n}\n\nfunction parseModifiers(value, params) {\n  params.constant = false;\n  params.payable = false;\n  params.stateMutability = \"nonpayable\";\n  value.split(\" \").forEach(function (modifier) {\n    switch (modifier.trim()) {\n      case \"constant\":\n        params.constant = true;\n        break;\n\n      case \"payable\":\n        params.payable = true;\n        params.stateMutability = \"payable\";\n        break;\n\n      case \"pure\":\n        params.constant = true;\n        params.stateMutability = \"pure\";\n        break;\n\n      case \"view\":\n        params.constant = true;\n        params.stateMutability = \"view\";\n        break;\n\n      case \"external\":\n      case \"public\":\n      case \"\":\n        break;\n\n      default:\n        console.log(\"unknown modifier: \" + modifier);\n    }\n  });\n}\n\nfunction verifyState(value) {\n  var result = {\n    constant: false,\n    payable: true,\n    stateMutability: \"payable\"\n  };\n\n  if (value.stateMutability != null) {\n    result.stateMutability = value.stateMutability;\n    result.constant = result.stateMutability === \"view\" || result.stateMutability === \"pure\";\n\n    if (value.constant != null) {\n      if (!!value.constant !== result.constant) {\n        throw new Error(\"cannot have constant function with mutability \" + result.stateMutability);\n      }\n    }\n\n    result.payable = result.stateMutability === \"payable\";\n\n    if (value.payable != null) {\n      if (!!value.payable !== result.payable) {\n        throw new Error(\"cannot have payable function with mutability \" + result.stateMutability);\n      }\n    }\n  } else if (value.payable != null) {\n    result.payable = !!value.payable;\n    result.stateMutability = result.payable ? \"payable\" : \"nonpayable\";\n    result.constant = !result.payable;\n\n    if (value.constant != null && value.constant !== result.constant) {\n      throw new Error(\"cannot have constant payable function\");\n    }\n  } else if (value.constant != null) {\n    result.constant = !!value.constant;\n    result.payable = !result.constant;\n    result.stateMutability = result.constant ? \"view\" : \"payable\";\n  }\n\n  return result;\n}\n\nvar ConstructorFragment =\n/** @class */\nfunction (_super) {\n  __extends(ConstructorFragment, _super);\n\n  function ConstructorFragment() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ConstructorFragment.prototype.format = function (format) {\n    if (!format) {\n      format = exports.FormatTypes.sighash;\n    }\n\n    if (!exports.FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === exports.FormatTypes.json) {\n      return JSON.stringify({\n        type: \"constructor\",\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payble: this.payable,\n        gas: this.gas ? this.gas.toNumber() : undefined,\n        inputs: this.inputs.map(function (input) {\n          return JSON.parse(input.format(format));\n        })\n      });\n    }\n\n    if (format === exports.FormatTypes.sighash) {\n      logger.throwError(\"cannot format a constructor for sighash\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"format(sighash)\"\n      });\n    }\n\n    var result = \"constructor(\" + this.inputs.map(function (input) {\n      return input.format(format);\n    }).join(format === exports.FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n      result += this.stateMutability + \" \";\n    }\n\n    return result.trim();\n  };\n\n  ConstructorFragment.from = function (value) {\n    if (typeof value === \"string\") {\n      return ConstructorFragment.fromString(value);\n    }\n\n    return ConstructorFragment.fromObject(value);\n  };\n\n  ConstructorFragment.fromObject = function (value) {\n    if (ConstructorFragment.isConstructorFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"constructor\") {\n      throw new Error(\"invalid constructor object - \" + value.type);\n    }\n\n    var state = verifyState(value);\n\n    if (state.constant) {\n      throw new Error(\"constructor cannot be constant\");\n    }\n\n    return new ConstructorFragment(_constructorGuard, {\n      type: value.type,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      payable: state.payable,\n      gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null\n    });\n  };\n\n  ConstructorFragment.fromString = function (value) {\n    var params = {\n      type: \"constructor\"\n    };\n    value = parseGas(value, params);\n    var parens = value.match(regexParen);\n\n    if (!parens) {\n      throw new Error(\"invalid constructor: \" + value);\n    }\n\n    if (parens[1].trim() !== \"constructor\") {\n      throw new Error(\"invalid constructor\");\n    }\n\n    params.inputs = parseParams(parens[2].trim(), false);\n    parseModifiers(parens[3].trim(), params);\n    return ConstructorFragment.fromObject(params);\n  };\n\n  ConstructorFragment.isConstructorFragment = function (value) {\n    return value && value._isFragment && value.type === \"constructor\";\n  };\n\n  return ConstructorFragment;\n}(Fragment);\n\nexports.ConstructorFragment = ConstructorFragment;\n\nvar FunctionFragment =\n/** @class */\nfunction (_super) {\n  __extends(FunctionFragment, _super);\n\n  function FunctionFragment() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FunctionFragment.prototype.format = function (format) {\n    if (!format) {\n      format = exports.FormatTypes.sighash;\n    }\n\n    if (!exports.FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === exports.FormatTypes.json) {\n      return JSON.stringify({\n        type: \"function\",\n        name: this.name,\n        constant: this.constant,\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payble: this.payable,\n        gas: this.gas ? this.gas.toNumber() : undefined,\n        inputs: this.inputs.map(function (input) {\n          return JSON.parse(input.format(format));\n        }),\n        ouputs: this.outputs.map(function (output) {\n          return JSON.parse(output.format(format));\n        })\n      });\n    }\n\n    var result = \"\";\n\n    if (format !== exports.FormatTypes.sighash) {\n      result += \"function \";\n    }\n\n    result += this.name + \"(\" + this.inputs.map(function (input) {\n      return input.format(format);\n    }).join(format === exports.FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (format !== exports.FormatTypes.sighash) {\n      if (this.stateMutability) {\n        if (this.stateMutability !== \"nonpayable\") {\n          result += this.stateMutability + \" \";\n        }\n      } else if (this.constant) {\n        result += \"view \";\n      }\n\n      if (this.outputs && this.outputs.length) {\n        result += \"returns (\" + this.outputs.map(function (output) {\n          return output.format(format);\n        }).join(\", \") + \") \";\n      }\n\n      if (this.gas != null) {\n        result += \"@\" + this.gas.toString() + \" \";\n      }\n    }\n\n    return result.trim();\n  };\n\n  FunctionFragment.from = function (value) {\n    if (typeof value === \"string\") {\n      return FunctionFragment.fromString(value);\n    }\n\n    return FunctionFragment.fromObject(value);\n  };\n\n  FunctionFragment.fromObject = function (value) {\n    if (FunctionFragment.isFunctionFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"function\") {\n      throw new Error(\"invalid function object - \" + value.type);\n    }\n\n    var state = verifyState(value);\n    return new FunctionFragment(_constructorGuard, {\n      type: value.type,\n      name: verifyIdentifier(value.name),\n      constant: state.constant,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],\n      payable: state.payable,\n      stateMutability: state.stateMutability,\n      gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null\n    });\n  };\n\n  FunctionFragment.fromString = function (value) {\n    var params = {\n      type: \"function\"\n    };\n    value = parseGas(value, params);\n    var comps = value.split(\" returns \");\n\n    if (comps.length > 2) {\n      throw new Error(\"invalid function\");\n    }\n\n    var parens = comps[0].match(regexParen);\n\n    if (!parens) {\n      throw new Error(\"invalid signature\");\n    }\n\n    params.name = parens[1].trim();\n\n    if (!params.name.match(regexIdentifier)) {\n      throw new Error(\"invalid identifier: '\" + params.name + \"'\");\n    }\n\n    params.inputs = parseParams(parens[2], false);\n    parseModifiers(parens[3].trim(), params); // We have outputs\n\n    if (comps.length > 1) {\n      var returns = comps[1].match(regexParen);\n\n      if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n        throw new Error(\"unexpected tokens\");\n      }\n\n      params.outputs = parseParams(returns[2], false);\n    } else {\n      params.outputs = [];\n    }\n\n    return FunctionFragment.fromObject(params);\n  };\n\n  FunctionFragment.isFunctionFragment = function (value) {\n    return value && value._isFragment && value.type === \"function\";\n  };\n\n  return FunctionFragment;\n}(ConstructorFragment);\n\nexports.FunctionFragment = FunctionFragment; //export class ErrorFragment extends Fragment {\n//}\n//export class StructFragment extends Fragment {\n//}\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = \"uint256\" + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = \"int256\" + type.substring(3);\n  } // @TODO: more verification\n\n\n  return type;\n}\n\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\n\nfunction verifyIdentifier(value) {\n  if (!value || !value.match(regexIdentifier)) {\n    throw new Error(\"invalid identifier: '\" + value + \"'\");\n  }\n\n  return value;\n}\n\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value) {\n  value = value.trim();\n  var result = [];\n  var accum = \"\";\n  var depth = 0;\n\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n\n    if (c === \",\" && depth === 0) {\n      result.push(accum);\n      accum = \"\";\n    } else {\n      accum += c;\n\n      if (c === \"(\") {\n        depth++;\n      } else if (c === \")\") {\n        depth--;\n\n        if (depth === -1) {\n          throw new Error(\"unbalanced parenthsis\");\n        }\n      }\n    }\n  }\n\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}