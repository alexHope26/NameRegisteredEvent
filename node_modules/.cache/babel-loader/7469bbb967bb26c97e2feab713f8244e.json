{"ast":null,"code":"\"use strict\";\n/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it    *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst util_1 = require(\"../../util/util\");\n\nconst serialize_1 = require(\"./serialize\");\n\nconst transport_1 = require(\"../../util/transport\");\n/**\n * calc the storrage array key\n */\n\n\nfunction getStorageArrayKey(pos, arrayIndex, structSize = 1, structPos = 0) {\n  return arrayIndex === undefined ? serialize_1.bytes32(pos) : serialize_1.bytes32(exports.toBN(ethereumjs_util_1.keccak256(serialize_1.bytes32(pos))).add(exports.toBN(arrayIndex * structSize + structPos)));\n}\n\nexports.getStorageArrayKey = getStorageArrayKey;\n/**\n * calcs the storage Map key.\n * @param pos position of the map in the contract\n * @param key key to search for\n * @param structPos if the value is a struct - the position in the struct\n */\n\nfunction getStorageMapKey(pos, key, structPos = 0) {\n  return serialize_1.bytes32(exports.toBN(ethereumjs_util_1.keccak256(Buffer.concat([serialize_1.bytes32(key), serialize_1.bytes32(pos)]))).add(exports.toBN(structPos)));\n}\n\nexports.getStorageMapKey = getStorageMapKey;\n/**\n * creates a string from storage.\n * @param data the data of the frst slot.\n * @param storageKey  the key.\n * if the length is bigger than 32, this function will return the keys needed in order to create the value, otherwise the string is returned.\n */\n\nfunction getStringValue(data, storageKey) {\n  if (data.length > 32) throw new Error('storrage value is too long. Must be 32bytes!');\n  if (data[31] % 2 === 0) return data.slice(0, data[31] / 2).toString('utf8');\n  const len = (util_1.toNumber(data) - 1) / 2;\n  const slot = exports.toBN(ethereumjs_util_1.keccak256(storageKey));\n  const storageKeys = [];\n\n  for (let i = 0; i < len / 32; i++) storageKeys.push(serialize_1.bytes32(slot.add(exports.toBN(i))));\n\n  return {\n    len,\n    storageKeys\n  };\n}\n\nexports.getStringValue = getStringValue;\n/**\n * concats the storage values to a string.\n * @param values\n * @param len\n */\n\nfunction getStringValueFromList(values, len) {\n  return Buffer.concat(values).slice(0, len).toString('utf8');\n}\n\nexports.getStringValueFromList = getStringValueFromList;\n/**\n * converts any value to BN\n */\n\nexports.toBN = val => new ethereumjs_util_1.BN(util_1.toHex(val).substr(2), 16);\n/**\n * get a storage value from the server\n * @param rpc url of the client\n * @param contract address of the contract\n * @param pos position in the contract\n * @param type type of the value\n * @param keyOrIndex if number this is in the index in the array if hex, this is the key in the map\n * @param structSize size if the value in the array of map\n * @param structPos position in the struct-value in the array of map\n */\n\n\nfunction getStorageValue(rpc, contract, pos, type, keyOrIndex, structSize, structPos) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const t = new transport_1.AxiosTransport();\n    const storageKey = keyOrIndex === undefined ? getStorageArrayKey(pos) : structSize ? getStorageArrayKey(pos, keyOrIndex, structSize, structPos) : getStorageMapKey(pos, keyOrIndex, structPos);\n    const val = yield t.handle(rpc, {\n      id: 1,\n      jsonrpc: '2.0',\n      method: 'eth_getStorageAt',\n      params: [contract, util_1.toHex(storageKey)]\n    }).then(_ => _.result);\n    if (type === 'int') return exports.toBN(val);else if (type === 'bytes32') return val;else if (type === 'bytes16') return val.substr(34, 32);else if (type === 'bytes4') return val.substr(58, 8);else if (type === 'address') return ethereumjs_util_1.toChecksumAddress('0x' + val.substr(26));\n    const stringValue = getStringValue(serialize_1.bytes32(val), storageKey);\n    if (typeof stringValue === 'string') return stringValue;else return t.handle(rpc, stringValue.storageKeys.map((sk, i) => ({\n      id: i + 1,\n      jsonrpc: '2.0',\n      method: 'eth_getStorageAt',\n      params: [contract, util_1.toHex(sk)]\n    }))).then(all => getStringValueFromList(all.map(serialize_1.bytes32), stringValue.len));\n  });\n}\n\nexports.getStorageValue = getStorageValue;","map":null,"metadata":{},"sourceType":"script"}