{"ast":null,"code":"/* Copyright (c) 2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/Level/level-ws/master/LICENSE>\n */\nvar Writable = require('stream').Writable || require('readable-stream').Writable,\n    inherits = require('util').inherits,\n    extend = require('xtend'),\n    defaultOptions = {\n  type: 'put',\n  keyEncoding: 'utf8',\n  valueEncoding: 'utf8' // copied from LevelUP\n\n},\n    encodingNames = ['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le'] // copied from LevelUP\n,\n    encodingOpts = function () {\n  var eo = {};\n  encodingNames.forEach(function (e) {\n    eo[e] = {\n      valueEncoding: e\n    };\n  });\n  return eo;\n}(); // copied from LevelUP\n\n\nfunction getOptions(levelup, options) {\n  var s = typeof options == 'string'; // just an encoding\n\n  if (!s && options && options.encoding && !options.valueEncoding) options.valueEncoding = options.encoding;\n  return extend(levelup && levelup.options || {}, s ? encodingOpts[options] || encodingOpts[defaultOptions.valueEncoding] : options);\n}\n\nfunction WriteStream(options, db) {\n  if (!(this instanceof WriteStream)) return new WriteStream(options, db);\n  Writable.call(this, {\n    objectMode: true\n  });\n  this._options = extend(defaultOptions, getOptions(db, options));\n  this._db = db;\n  this._buffer = [];\n  this.writable = true;\n  this.readable = false;\n  var self = this;\n  this.on('finish', function f() {\n    if (self._buffer && self._buffer.length) {\n      return self._flush(f);\n    }\n\n    self.writable = false;\n    self.emit('close');\n  });\n}\n\ninherits(WriteStream, Writable);\n\nWriteStream.prototype._write = function write(d, enc, next) {\n  var self = this;\n  if (self._destroyed) return;\n  if (!self._db.isOpen()) return self._db.once('ready', function () {\n    write.call(self, d, enc, next);\n  });\n\n  if (self._options.maxBufferLength && self._buffer.length > self._options.maxBufferLength) {\n    self.once('_flush', next);\n  } else {\n    if (self._buffer.length === 0) process.nextTick(function () {\n      self._flush();\n    });\n\n    self._buffer.push(d);\n\n    next();\n  }\n};\n\nWriteStream.prototype._flush = function (f) {\n  var self = this,\n      buffer = self._buffer;\n  if (self._destroyed || !buffer) return;\n\n  if (!self._db.isOpen()) {\n    return self._db.on('ready', function () {\n      self._flush(f);\n    });\n  }\n\n  self._buffer = [];\n\n  self._db.batch(buffer.map(function (d) {\n    return {\n      type: d.type || self._options.type,\n      key: d.key,\n      value: d.value,\n      keyEncoding: d.keyEncoding || self._options.keyEncoding,\n      valueEncoding: d.valueEncoding || d.encoding || self._options.valueEncoding\n    };\n  }), cb);\n\n  function cb(err) {\n    if (err) {\n      self.writable = false;\n      self.emit('error', err);\n    } else {\n      if (f) f();\n      self.emit('_flush');\n    }\n  }\n};\n\nWriteStream.prototype.toString = function () {\n  return 'LevelUP.WriteStream';\n};\n\nWriteStream.prototype.destroy = function () {\n  if (this._destroyed) return;\n  this._buffer = null;\n  this._destroyed = true;\n  this.writable = false;\n  this.emit('close');\n};\n\nWriteStream.prototype.destroySoon = function () {\n  this.end();\n};\n\nmodule.exports = function (db) {\n  db.writeStream = db.createWriteStream = function (options) {\n    return new WriteStream(options, db);\n  };\n\n  return db;\n};\n\nmodule.exports.WriteStream = WriteStream;","map":null,"metadata":{},"sourceType":"script"}