{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/edgarrodriguezzavala/Workspace/programing-test-named-registered/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ethereumjs_abi_1 = require(\"ethereumjs-abi\");\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst ETx = require(\"ethereumjs-tx\");\n\nconst util_1 = require(\"../../util/util\");\n\nconst serialize_1 = require(\"./serialize\");\n\nconst BN = require(\"bn.js\");\n\nconst abi_1 = require(\"@ethersproject/abi\");\n\nclass EthAPI {\n  constructor(client) {\n    this.client = client;\n  }\n\n  send(name, ...params) {\n    return this.client.sendRPC(name, params || []).then(r => {\n      if (r.error) throw new Error(r.error.message || r.error);\n      return r.result;\n    });\n  }\n  /**\n   * Returns the number of most recent block. (as number)\n   */\n\n\n  blockNumber() {\n    return this.send('eth_blockNumber').then(parseInt);\n  }\n  /**\n   * Returns the current price per gas in wei. (as number)\n   */\n\n\n  gasPrice() {\n    return this.send('eth_gasPrice').then(parseInt);\n  }\n  /**\n   * Executes a new message call immediately without creating a transaction on the block chain.\n   */\n\n\n  call(tx, block = 'latest') {\n    return this.send('eth_call', tx, toHexBlock(block));\n  }\n  /**\n   * Executes a function of a contract, by passing a [method-signature](https://github.com/ethereumjs/ethereumjs-abi/blob/master/README.md#simple-encoding-and-decoding) and the arguments, which will then be ABI-encoded and send as eth_call.\n   */\n\n\n  callFn(to, method, ...args) {\n    const t = createCallParams(method, args || []);\n    return this.send('eth_call', {\n      to,\n      data: t.txdata\n    }, 'latest').then(t.convert);\n  }\n  /**\n   * Returns the EIP155 chain ID used for transaction signing at the current best block. Null is returned if not available.\n   */\n\n\n  chainId() {\n    return this.send('eth_chainId');\n  }\n  /**\n   * Makes a call or transaction, which won’t be added to the blockchain and returns the used gas, which can be used for estimating the used gas.\n   */\n\n\n  estimateGas(tx\n  /*, block: BlockType = 'latest'*/\n  ) {\n    return this.send('eth_estimateGas', tx\n    /*, toHexBlock(block)*/\n    ).then(parseInt);\n  }\n  /**\n   * Returns the balance of the account of given address in wei (as hex).\n   */\n\n\n  getBalance(address, block = 'latest') {\n    return this.send('eth_getBalance', address, toHexBlock(block)).then(util_1.toBN);\n  }\n  /**\n   * Returns code at a given address.\n   */\n\n\n  getCode(address, block = 'latest') {\n    return this.send('eth_getCode', address, block);\n  }\n  /**\n   * Returns the value from a storage position at a given address.\n   */\n\n\n  getStorageAt(address, pos, block = 'latest') {\n    return this.send('eth_getStorageAt', address, pos, toHexBlock(block));\n  }\n  /**\n   * Returns information about a block by hash.\n   */\n\n\n  getBlockByHash(hash, includeTransactions = false) {\n    return this.send('eth_getBlockByHash', hash, includeTransactions);\n  }\n  /**\n   * Returns information about a block by block number.\n   */\n\n\n  getBlockByNumber(block = 'latest', includeTransactions = false) {\n    return this.send('eth_getBlockByNumber', toHexBlock(block), includeTransactions);\n  }\n  /**\n   * Returns the number of transactions in a block from a block matching the given block hash.\n   */\n\n\n  getBlockTransactionCountByHash(block) {\n    return this.send('eth_getBlockTransactionCountByHash', block).then(parseInt);\n  }\n  /**\n   * Returns the number of transactions in a block from a block matching the given block number.\n   */\n\n\n  getBlockTransactionCountByNumber(block) {\n    return this.send('eth_getBlockTransactionCountByNumber', block).then(parseInt);\n  }\n  /**\n   * Polling method for a filter, which returns an array of logs which occurred since last poll.\n   */\n\n\n  getFilterChanges(id) {\n    return this.send('eth_getFilterChanges', id);\n  }\n  /**\n   * Returns an array of all logs matching filter with given id.\n   */\n\n\n  getFilterLogs(id) {\n    return this.send('eth_getFilterLogs', id);\n  }\n  /**\n   * Returns an array of all logs matching a given filter object.\n   */\n\n\n  getLogs(filter) {\n    if (filter.fromBlock) filter.fromBlock = toHexBlock(filter.fromBlock);\n    if (filter.toBlock) filter.toBlock = toHexBlock(filter.toBlock);\n    if (filter.limit) filter.limit = util_1.toNumber(filter.limit);\n    return this.send('eth_getLogs', filter);\n  }\n  /**\n   * Returns information about a transaction by block hash and transaction index position.\n   */\n\n\n  getTransactionByBlockHashAndIndex(hash, pos) {\n    return this.send('eth_getTransactionByBlockHashAndIndex', hash, pos);\n  }\n  /**\n   * Returns information about a transaction by block number and transaction index position.\n   */\n\n\n  getTransactionByBlockNumberAndIndex(block, pos) {\n    return this.send('eth_getTransactionByBlockNumberAndIndex', toHexBlock(block), pos);\n  }\n  /**\n   * Returns the information about a transaction requested by transaction hash.\n   */\n\n\n  getTransactionByHash(hash) {\n    return this.send('eth_getTransactionByHash', hash);\n  }\n  /**\n   * Returns the number of transactions sent from an address. (as number)\n   */\n\n\n  getTransactionCount(address, block = 'latest') {\n    return this.send('eth_getTransactionCount', address, block).then(parseInt);\n  }\n  /**\n   * Returns the receipt of a transaction by transaction hash.\n   * Note That the receipt is available even for pending transactions.\n   */\n\n\n  getTransactionReceipt(hash) {\n    return this.send('eth_getTransactionReceipt', hash).then(_ => !_ ? null : Object.assign({}, _, {\n      contractAddress: _.contractAddress && ethereumjs_util_1.toChecksumAddress(_.contractAddress),\n      from: _.from && ethereumjs_util_1.toChecksumAddress(_.from)\n    }));\n  }\n  /**\n   * Returns information about a uncle of a block by hash and uncle index position.\n   * Note: An uncle doesn’t contain individual transactions.\n   */\n\n\n  getUncleByBlockHashAndIndex(hash, pos) {\n    return this.send('eth_getUncleByBlockHashAndIndex', hash, pos);\n  }\n  /**\n   * Returns information about a uncle of a block number and uncle index position.\n   * Note: An uncle doesn’t contain individual transactions.\n   */\n\n\n  getUncleByBlockNumberAndIndex(block, pos) {\n    return this.send('eth_getUncleByBlockNumberAndIndex', block, pos);\n  }\n  /**\n   * Returns the number of uncles in a block from a block matching the given block hash.\n   */\n\n\n  getUncleCountByBlockHash(hash) {\n    return this.send('eth_getUncleCountByBlockHash', hash).then(parseInt);\n  }\n  /**\n   * Returns the number of uncles in a block from a block matching the given block hash.\n   */\n\n\n  getUncleCountByBlockNumber(block) {\n    return this.send('eth_getUncleCountByBlockNumber', block).then(parseInt);\n  }\n  /**\n   * Creates a filter in the node, to notify when a new block arrives. To check if the state has changed, call eth_getFilterChanges.\n   */\n\n\n  newBlockFilter() {\n    return this.send('eth_newBlockFilter');\n  }\n  /**\n   * Creates a filter object, based on filter options, to notify when the state changes (logs). To check if the state has changed, call eth_getFilterChanges.\n   *\n   * A note on specifying topic filters:\n   * Topics are order-dependent. A transaction with a log with topics [A, B] will be matched by the following topic filters:\n   *\n   * [] “anything”\n   * [A] “A in first position (and anything after)”\n   * [null, B] “anything in first position AND B in second position (and anything after)”\n   * [A, B] “A in first position AND B in second position (and anything after)”\n   * [[A, B], [A, B]] “(A OR B) in first position AND (A OR B) in second position (and anything after)”\n   */\n\n\n  newFilter(filter) {\n    return this.send('eth_newFilter', filter);\n  }\n  /**\n   * Creates a filter in the node, to notify when new pending transactions arrive.\n   *\n   * To check if the state has changed, call eth_getFilterChanges.\n   */\n\n\n  newPendingTransactionFilter() {\n    return this.send('eth_newPendingTransactionFilter');\n  }\n  /**\n   * Uninstalls a filter with given id. Should always be called when watch is no longer needed. Additonally Filters timeout when they aren’t requested with eth_getFilterChanges for a period of time.\n   */\n\n\n  uninstallFilter(id) {\n    return this.send('eth_uninstallFilter');\n  }\n  /**\n   * Returns the current ethereum protocol version.\n   */\n\n\n  protocolVersion() {\n    return this.send('eth_protocolVersion');\n  }\n  /**\n    * Returns the current ethereum protocol version.\n    */\n\n\n  syncing() {\n    return this.send('eth_syncing');\n  }\n  /**\n   * Creates new message call transaction or a contract creation for signed transactions.\n   */\n\n\n  sendRawTransaction(data) {\n    return this.send('eth_sendRawTransaction', data);\n  }\n  /**\n   * signs any kind of message using the `\\x19Ethereum Signed Message:\\n`-prefix\n   * @param account the address to sign the message with (if this is a 32-bytes hex-string it will be used as private key)\n   * @param data the data to sign (Buffer, hexstring or utf8-string)\n   */\n\n\n  sign(account, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // prepare data\n      const d = util_1.toBuffer(data);\n      const hash = ethereumjs_util_1.keccak(Buffer.concat([Buffer.from('\\x19Ethereum Signed Message:\\n' + d.length, 'utf8'), d]));\n      let s = {\n        message: data,\n        messageHash: util_1.toHex(hash)\n      };\n      if (account && account.length == 66) s = Object.assign({}, s, ethereumjs_util_1.ecsign(hash, util_1.toBuffer(account)));else if (this.signer && (yield this.signer.hasAccount(account))) s = Object.assign({}, s, (yield this.signer.sign(hash, account)));\n      s.signature = util_1.toHex(s.r) + util_1.toHex(s.s).substr(2) + util_1.toHex(s.v).substr(2);\n      return s;\n    });\n  }\n  /** sends a Transaction */\n\n\n  sendTransaction(args) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!args.pk && (!this.signer || !(yield this.signer.hasAccount(args.from)))) throw new Error('missing private key!'); // prepare\n\n      const tx = yield prepareTransaction(args, this);\n      let etx = null;\n\n      if (args.pk) {\n        // sign it with the raw keyx\n        etx = new ETx(Object.assign({}, tx, {\n          gasLimit: tx.gas\n        }));\n        etx.sign(util_1.toBuffer(args.pk));\n      } else if (this.signer && args.from) {\n        const t = this.signer.prepareTransaction ? yield this.signer.prepareTransaction(this.client, tx) : tx;\n        etx = new ETx(Object.assign({}, t, {\n          gasLimit: t.gas\n        }));\n        const signature = yield this.signer.sign(etx.hash(false), args.from);\n        if (etx._chainId > 0) signature.v = util_1.toHex(util_1.toNumber(signature.v) + etx._chainId * 2 + 8);\n        Object.assign(etx, signature);\n      } else throw new Error('Invalid transaction-data');\n\n      const txHash = yield this.sendRawTransaction(util_1.toHex(etx.serialize()));\n      if (args.confirmations === undefined) args.confirmations = 1; // send it\n\n      return args.confirmations ? confirm(txHash, this, parseInt(tx.gas), args.confirmations) : txHash;\n    });\n  }\n\n  contractAt(abi, address) {\n    const api = this,\n          ob = {\n      _address: address,\n      _eventHashes: {},\n      events: {},\n      _abi: abi,\n      _in3: this.client\n    };\n\n    for (const def of abi.filter(_ => _.type == 'function')) {\n      const method = def.name + createSignature(def.inputs);\n\n      if (def.constant) {\n        const signature = method + ':' + createSignature(def.outputs);\n\n        ob[def.name] = function (...args) {\n          return api.callFn(address, signature, ...args).then(r => {\n            if (def.outputs.length > 1) {\n              let o = {};\n              def.outputs.forEach((d, i) => o[i] = o[d.name] = r[i]);\n              return o;\n            }\n\n            return r;\n          });\n        };\n      } else {\n        ob[def.name] = function (...args) {\n          let tx = {};\n          if (args.length > def.inputs.length) tx = args.pop();\n          tx.method = method;\n          tx.args = args.slice(0, def.name.length);\n          tx.confirmations = tx.confirmations || 1;\n          tx.to = address;\n          return api.sendTransaction(tx);\n        };\n      }\n\n      ob[def.name].encode = (...args) => createCallParams(method, args.slice(0, def.name.length)).txdata;\n    }\n\n    for (const def of abi.filter(_ => _.type == 'event')) {\n      const eHash = '0x' + ethereumjs_util_1.keccak(Buffer.from(def.name + createSignature(def.inputs), 'utf8')).toString('hex');\n      ob._eventHashes[def.name] = eHash;\n      ob._eventHashes[eHash] = def;\n      ob.events[def.name] = {\n        getLogs(options = {}) {\n          return api.getLogs({\n            address,\n            fromBlock: options.fromBlock || 'latest',\n            toBlock: options.toBlock || 'latest',\n            topics: options.topics || [eHash, ...(!options.filter ? [] : def.inputs.filter(_ => _.indexed).map(d => options.filter[d.name] ? '0x' + serialize_1.bytes32(options.filter[d.name]).toString('hex') : null))],\n            limit: options.limit || 50\n          }).then(logs => logs.map(_ => {\n            const event = ob.events.decode(_);\n            return Object.assign({}, event, {\n              log: _,\n              event\n            });\n          }));\n        }\n\n      };\n    }\n\n    ob.events.decode = function (log) {\n      return decodeEventData(log, ob);\n    };\n\n    ob.events.all = {\n      getLogs(options = {}) {\n        return api.getLogs({\n          address,\n          fromBlock: options.fromBlock || 'latest',\n          toBlock: options.toBlock || 'latest',\n          topics: options.topics || [],\n          limit: options.limit || 50\n        }).then(logs => logs.map(_ => {\n          const event = ob.events.decode(_);\n          return Object.assign({}, event, {\n            log: _,\n            event\n          });\n        }));\n      }\n\n    };\n    return ob;\n  }\n\n  decodeEventData(log, d) {\n    return decodeEvent(log, d);\n  }\n\n  hashMessage(data) {\n    const d = util_1.toBuffer(data);\n    return ethereumjs_util_1.keccak(Buffer.concat([Buffer.from('\\x19Ethereum Signed Message:\\n' + d.length, 'utf8'), d]));\n  }\n\n}\n\nexports.default = EthAPI;\n\nfunction confirm(txHash, api, gasPaid, confirmations, timeout = 10) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let steps = 200;\n    const start = Date.now();\n\n    while (Date.now() - start < timeout * 1000) {\n      const receipt = yield api.getTransactionReceipt(txHash);\n\n      if (receipt) {\n        if (!receipt.status && gasPaid && gasPaid === parseInt(receipt.gasUsed)) throw new Error('Transaction failed and all gas was used up gasPaid=' + gasPaid);\n        if (receipt.status && receipt.status == '0x0') throw new Error('The Transaction failed because it returned status=0');\n\n        if (confirmations > 1) {\n          const start = parseInt(receipt.blockNumber);\n\n          while (start + confirmations - 1 > (yield api.blockNumber())) yield new Promise(_ => setTimeout(_, 10));\n\n          return api.getTransactionReceipt(txHash);\n        }\n\n        return receipt;\n      } // wait a second and try again\n\n\n      yield new Promise(_ => setTimeout(_, Math.min(timeout * 200, steps *= 2)));\n    }\n\n    throw new Error('Error waiting for the transaction to confirm');\n  });\n}\n\nfunction prepareTransaction(args, api) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const sender = args.from || args.pk && ethereumjs_util_1.toChecksumAddress(ethereumjs_util_1.privateToAddress(util_1.toBuffer(args.pk)).toString('hex'));\n    const tx = {};\n    if (args.to) tx.to = util_1.toHex(args.to);\n\n    if (args.method) {\n      tx.data = createCallParams(args.method, args.args).txdata;\n      if (args.data) tx.data = args.data + tx.data.substr(10); // this is the case  for deploying contracts\n    } else if (args.data) tx.data = util_1.toHex(args.data);\n\n    if (sender || args.nonce) tx.nonce = util_1.toMinHex(args.nonce || api && (yield api.getTransactionCount(sender, 'pending')));\n    if (api) tx.gasPrice = util_1.toMinHex(args.gasPrice || Math.round(1.3 * util_1.toNumber((yield api.gasPrice()))));\n    tx.value = util_1.toMinHex(args.value || 0);\n    if (sender) tx.from = sender;\n\n    try {\n      tx.gas = util_1.toMinHex(args.gas || api && util_1.toNumber((yield api.estimateGas(tx))) + 1000 || 3000000);\n    } catch (ex) {\n      throw new Error('The Transaction ' + JSON.stringify(args, null, 2) + ' will not be succesfully executed, since estimating gas failed with: ' + ex);\n    }\n\n    return tx;\n  });\n}\n\nfunction convertToType(solType, v) {\n  // check for arrays\n  const list = solType.lastIndexOf('[');\n\n  if (list >= 0) {\n    if (!Array.isArray(v)) throw new Error('Invalid result for type ' + solType + '. Value must be an array, but is not!');\n    solType = solType.substr(0, list);\n    return v.map(_ => convertToType(solType, _));\n  } // convert integers\n\n\n  if (solType.startsWith('uint')) return parseInt(solType.substr(4)) <= 32 ? util_1.toNumber(v) : util_1.toBN(v);\n  if (solType.startsWith('int')) return parseInt(solType.substr(3)) <= 32 ? util_1.toNumber(v) : util_1.toBN(v); // TODO handle negative values\n\n  if (solType === 'bool') return typeof v === 'boolean' ? v : util_1.toNumber(v) ? true : false;\n  if (solType === 'string') return v.toString('utf8');\n  if (solType === 'address') return ethereumjs_util_1.toChecksumAddress(util_1.toHex(v)); //    if (solType === 'bytes') return toBuffer(v)\n  // everything else will be hexcoded string\n\n  if (Buffer.isBuffer(v)) return '0x' + v.toString('hex');\n  if (v && v.ixor) return '0x' + v.toString(16);\n  return v[1] !== 'x' ? '0x' + v : v;\n}\n\nfunction decodeResult(types, result) {\n  const abiCoder = new abi_1.AbiCoder();\n  return abiCoder.decode(types, result).map((v, i) => convertToType(types[i], v));\n}\n\nfunction createCallParams(method, values) {\n  if (!method) throw new Error('method needs to be a valid contract method signature');\n  if (method.indexOf('(') < 0) method += '()';\n  const methodRegex = /^\\w+\\((.*)\\)$/gm;\n  let convert = null;\n\n  if (method.indexOf(':') > 0) {\n    const srcFullMethod = method;\n    const retTypes = method.split(':')[1].substr(1).replace(')', ' ').trim().split(',');\n\n    convert = result => {\n      if (result) result = decodeResult(retTypes, Buffer.from(result.substr(2), 'hex'));\n      if (Array.isArray(result) && (!srcFullMethod.endsWith(')') || result.length == 1)) result = result[0];\n      return result;\n    };\n\n    method = method.substr(0, method.indexOf(':'));\n  }\n\n  const m = methodRegex.exec(method);\n  if (!m) throw new Error('No valid method signature for ' + method);\n  const types = m[1].split(',').filter(_ => _);\n  if (values.length < types.length) throw new Error('invalid number of arguments. Must be at least ' + types.length);\n  values.forEach((v, i) => {\n    if (types[i] === 'bytes') values[i] = util_1.toBuffer(v);\n  });\n  return {\n    txdata: '0x' + (values.length ? encodeFunction(method, values) : ethereumjs_abi_1.methodID(method.substr(0, method.indexOf('(')), []).toString('hex')),\n    convert\n  };\n}\n\nfunction createSignatureHash(def) {\n  return ethereumjs_util_1.keccak(def.name + createSignature(def.inputs));\n}\n\nexports.createSignatureHash = createSignatureHash;\n\nfunction createSignature(fields) {\n  return '(' + fields.map(f => {\n    let baseType = f.type;\n    const t = baseType.indexOf('[');\n    if (t > 0) baseType = baseType.substr(0, t);\n    if (baseType === 'uint' || baseType === 'int') baseType += '256';\n    return baseType + (t < 0 ? '' : f.type.substr(t));\n  }).join(',') + ')';\n}\n\nexports.createSignature = createSignature;\n\nfunction parseABIString(def) {\n  const _def$split = def.split(/[\\(\\)]/),\n        _def$split2 = _slicedToArray(_def$split, 2),\n        name = _def$split2[0],\n        args = _def$split2[1];\n\n  return {\n    name,\n    type: 'event',\n    inputs: args.split(',').filter(_ => _).map(_ => _.split(' ').filter(z => z)).map(_ => ({\n      type: _[0],\n      name: _[_.length - 1],\n      indexed: _[1] == 'indexed'\n    }))\n  };\n}\n\nfunction decodeEventData(log, def) {\n  let d = typeof def === 'object' ? def._eventHashes[log.topics[0]] : parseABIString(def);\n  if (!d) return null; //throw new Error('Could not find the ABI')\n\n  return decodeEvent(log, d);\n}\n\nfunction decodeEvent(log, d) {\n  const indexed = d.inputs.filter(_ => _.indexed),\n        unindexed = d.inputs.filter(_ => !_.indexed),\n        r = {\n    event: d && d.name\n  };\n  if (indexed.length) decodeResult(indexed.map(_ => _.type), Buffer.concat(log.topics.slice(1).map(serialize_1.bytes))).forEach((v, i) => r[indexed[i].name] = v);\n  if (unindexed.length) decodeResult(unindexed.map(_ => _.type), serialize_1.bytes(log.data)).forEach((v, i) => r[unindexed[i].name] = v);\n  return r;\n}\n\nexports.decodeEvent = decodeEvent;\n\nclass SimpleSigner {\n  constructor(...pks) {\n    this.accounts = {};\n    if (pks) pks.forEach(_ => this.addAccount(_));\n  }\n\n  addAccount(pk) {\n    const adr = ethereumjs_util_1.toChecksumAddress(util_1.toHex(ethereumjs_util_1.privateToAddress(util_1.toBuffer(pk))));\n    this.accounts[adr] = pk;\n    return adr;\n  }\n\n  hasAccount(account) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return !!this.accounts[ethereumjs_util_1.toChecksumAddress(account)];\n    });\n  }\n\n  sign(data, account) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const pk = util_1.toBuffer(this.accounts[ethereumjs_util_1.toChecksumAddress(account)]);\n      if (!pk || pk.length != 32) throw new Error('Account not found for signing ' + account);\n      const sig = ethereumjs_util_1.ecsign(data, pk);\n      return {\n        messageHash: util_1.toHex(data),\n        v: util_1.toHex(sig.v),\n        r: util_1.toHex(sig.r),\n        s: util_1.toHex(sig.s),\n        message: util_1.toHex(data)\n      };\n    });\n  }\n\n}\n\nexports.SimpleSigner = SimpleSigner;\n\nfunction encodeEtheresBN(val) {\n  return val && BN.isBN(val) ? util_1.toHex(val) : val;\n}\n\nfunction soliditySha3(...args) {\n  const abiCoder = new abi_1.AbiCoder();\n  return util_1.toHex(ethereumjs_util_1.keccak(abiCoder.encode(args.map(_ => {\n    switch (typeof _) {\n      case 'number':\n        return _ < 0 ? 'int256' : 'uint256';\n\n      case 'string':\n        return _.substr(0, 2) === '0x' ? 'bytes' : 'string';\n\n      case 'boolean':\n        return 'bool';\n\n      default:\n        return BN.isBN(_) ? 'uint256' : 'bytes';\n    }\n  }), args.map(encodeEtheresBN))));\n}\n\nexports.soliditySha3 = soliditySha3;\n\nfunction toHexBlock(b) {\n  return typeof b === 'string' ? b : util_1.toMinHex(b);\n}\n\nfunction fixTypeTest(input, type) {\n  switch (type) {\n    case \"bytes32\":\n      return \"0x\" + util_1.toBuffer(input, 32).toString('hex');\n\n    case \"bytes4\":\n      return \"0x\" + util_1.toBuffer(input, 4).toString('hex');\n\n    default:\n      return input;\n  }\n}\n\nfunction encodeFunction(signature, args) {\n  const inputParams = signature.split(':')[0];\n  const abiCoder = new abi_1.AbiCoder();\n  const typeTemp = inputParams.substring(inputParams.indexOf('(') + 1, inputParams.indexOf(')'));\n  const typeArray = typeTemp.length > 0 ? typeTemp.split(\",\") : [];\n  const methodHash = ethereumjs_abi_1.methodID(signature.substr(0, signature.indexOf('(')), typeArray).toString('hex');\n\n  for (let i = 0; i < args.length; i++) {\n    args[i] = fixTypeTest(args[i], typeArray[i]);\n  }\n\n  try {\n    return methodHash + abiCoder.encode(typeArray, args.map(encodeEtheresBN)).substr(2);\n  } catch (e) {\n    throw new Error(\"Error trying to encode \".concat(signature, \" with the params \").concat(args, \": \").concat(e));\n  }\n}\n\nexports.encodeFunction = encodeFunction;\n\nfunction decodeFunction(signature, args) {\n  const outputParams = signature.split(':')[1];\n  const abiCoder = new abi_1.AbiCoder();\n  const typeTemp = outputParams.substring(outputParams.indexOf('(') + 1, outputParams.indexOf(')'));\n  const typeArray = typeTemp.length > 0 ? typeTemp.split(\",\") : [];\n\n  try {\n    return abiCoder.decode(typeArray, util_1.toBuffer(args));\n  } catch (e) {\n    throw new Error(\"Error trying to decode \".concat(signature, \" with the params \").concat(args, \": \").concat(e));\n  }\n}\n\nexports.decodeFunction = decodeFunction;","map":null,"metadata":{},"sourceType":"script"}