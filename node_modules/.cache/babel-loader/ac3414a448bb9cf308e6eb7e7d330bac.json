{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar Tree = require('functional-red-black-tree');\n\nvar Account = require('ethereumjs-account');\n\nvar async = require('async');\n\nvar Cache = module.exports = function (trie) {\n  this._cache = Tree();\n  this._checkpoints = [];\n  this._deletes = [];\n  this._trie = trie;\n};\n\nCache.prototype.put = function (key, val, fromTrie) {\n  var modified = !fromTrie;\n\n  this._update(key, val, modified, true);\n}; // returns the queried account or an empty account\n\n\nCache.prototype.get = function (key) {\n  var account = this.lookup(key);\n\n  if (!account) {\n    account = new Account();\n    account.exists = false;\n  }\n\n  return account;\n}; // returns the queried account or undefined\n\n\nCache.prototype.lookup = function (key) {\n  key = key.toString('hex');\n\n  var it = this._cache.find(key);\n\n  if (it.node) {\n    var account = new Account(it.value.val);\n    account.exists = it.value.exists;\n    return account;\n  }\n};\n\nCache.prototype._lookupAccount = function (address, cb) {\n  var self = this;\n\n  self._trie.get(address, function (err, raw) {\n    if (err) return cb(err);\n    var account = new Account(raw);\n    var exists = !!raw;\n    account.exists = exists;\n    cb(null, account, exists);\n  });\n};\n\nCache.prototype.getOrLoad = function (key, cb) {\n  var self = this;\n  var account = this.lookup(key);\n\n  if (account) {\n    cb(null, account);\n  } else {\n    self._lookupAccount(key, function (err, account, exists) {\n      if (err) return cb(err);\n\n      self._update(key, account, false, exists);\n\n      cb(null, account);\n    });\n  }\n};\n\nCache.prototype.warm = function (addresses, cb) {\n  var self = this; // shim till async supports iterators\n\n  var accountArr = [];\n  addresses.forEach(function (val) {\n    if (val) accountArr.push(val);\n  });\n  async.eachSeries(accountArr, function (addressHex, done) {\n    var address = Buffer.from(addressHex, 'hex');\n\n    self._lookupAccount(address, function (err, account) {\n      if (err) return done(err);\n\n      self._update(address, account, false, account.exists);\n\n      done();\n    });\n  }, cb);\n};\n\nCache.prototype.flush = function (cb) {\n  var it = this._cache.begin;\n  var self = this;\n  var next = true;\n  async.whilst(function () {\n    return next;\n  }, function (done) {\n    if (it.value && it.value.modified) {\n      it.value.modified = false;\n      it.value.val = it.value.val.serialize();\n\n      self._trie.put(Buffer.from(it.key, 'hex'), it.value.val, function () {\n        next = it.hasNext;\n        it.next();\n        done();\n      });\n    } else {\n      next = it.hasNext;\n      it.next();\n      done();\n    }\n  }, function () {\n    async.eachSeries(self._deletes, function (address, done) {\n      self._trie.del(address, done);\n    }, function () {\n      self._deletes = [];\n      cb();\n    });\n  });\n};\n\nCache.prototype.checkpoint = function () {\n  this._checkpoints.push(this._cache);\n};\n\nCache.prototype.revert = function () {\n  this._cache = this._checkpoints.pop(this._cache);\n};\n\nCache.prototype.commit = function () {\n  this._checkpoints.pop();\n};\n\nCache.prototype.clear = function () {\n  this._deletes = [];\n  this._cache = Tree();\n};\n\nCache.prototype.del = function (key) {\n  this._deletes.push(key);\n\n  key = key.toString('hex');\n  this._cache = this._cache.remove(key);\n};\n\nCache.prototype._update = function (key, val, modified, exists) {\n  key = key.toString('hex');\n\n  var it = this._cache.find(key);\n\n  if (it.node) {\n    this._cache = it.update({\n      val: val,\n      modified: modified,\n      exists: true\n    });\n  } else {\n    this._cache = this._cache.insert(key, {\n      val: val,\n      modified: modified,\n      exists: exists\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}