{"ast":null,"code":"\"use strict\";\n/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst EthChainContext_1 = require(\"./EthChainContext\");\n\nconst util = require(\"ethereumjs-util\");\n\nconst serialize_1 = require(\"./serialize\");\n\nconst util_1 = require(\"../../util/util\");\n\nconst call_1 = require(\"./call\");\n\nconst serverList_1 = require(\"../../client/serverList\");\n\nconst merkleProof_1 = require(\"../../util/merkleProof\");\n\nconst storage_1 = require(\"./storage\");\n\nconst Trie = require(\"merkle-patricia-tree\");\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst ipfs_1 = require(\"../ipfs/ipfs\");\n\nconst header_1 = require(\"./header\");\n\nconst Client_1 = require(\"../../client/Client\");\n\nconst BN = require(\"bn.js\"); // these method are accepted without proof\n\n\nconst allowedWithoutProof = ['ipfs_get', 'ipfs_put', 'eth_blockNumber', 'web3_clientVersion', 'web3_sha3', 'net_version', 'net_peerCount', 'net_listening', 'eth_protocolVersion', 'eth_syncing', 'eth_coinbase', 'eth_mining', 'eth_hashrate', 'eth_gasPrice', 'eth_accounts', 'eth_sign', 'eth_sendRawTransaction', 'eth_estimateGas', 'eth_getCompilers', 'eth_compileLLL', 'eth_compileSolidity', 'eth_compileSerpent', 'eth_getWork', 'eth_submitWork', 'eth_submitHashrate'];\nconst N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n/** verify the signatures of a blockhash */\n\nfunction verifyBlock(b, proof, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // calculate the blockHash\n    const blockHash = b.hash();\n    if (proof.expectedBlockHash && !blockHash.equals(proof.expectedBlockHash)) throw new Error('The BlockHash is not the expected one!'); // if we don't expect signatures\n\n    if (!proof.expectedSigners || proof.expectedSigners.length === 0) {\n      const spec = ctx && ctx.getChainSpec(util_1.toNumber(b.number)); // for proof of authorities we can verify the signatures\n\n      if (spec && (spec.engine === 'authorityRound' || spec.engine === 'clique')) {\n        const finality = yield header_1.checkBlockSignatures([b, ...(proof.proof && proof.proof.finalityBlocks || [])], _ => header_1.getChainSpec(_, ctx));\n        if (proof.finality && proof.finality > finality) throw new Error('we have only a finality of ' + finality + ' but expected was ' + proof.finality);\n      } // no expected signatures - no need to verify here\n\n\n      return;\n    } // we are not allowing block verification without signature\n\n\n    if (!proof.proof.signatures) throw new Error('No signatures found ');\n    const existing = ctx && ctx instanceof EthChainContext_1.default && ctx.getBlockHeaderByHash(blockHash); // filter valid signatures for the current block\n\n    const signaturesForBlock = proof.proof.signatures.filter(_ => _ && util_1.toNumber(_.block) === util_1.toNumber(b.number) && (!_.blockHash || blockHash.equals(serialize_1.bytes32(_.blockHash))));\n\n    if (signaturesForBlock.length === 0) {\n      // if the blockhash is already verified, we don't need a signature\n      if (existing) return;\n      throw new Client_1.BlackListError('No signatures found for block ', proof.expectedSigners.map(_ => ethUtil.toChecksumAddress(util_1.toHex(_))));\n    } // verify the signatures for only the blocks matching the given\n\n\n    const messageHash = util.keccak(Buffer.concat([blockHash, serialize_1.bytes32(b.number)]));\n    if (!signaturesForBlock.reduce((p, signature, i) => {\n      if (!messageHash.equals(serialize_1.bytes32(signature.msgHash))) throw new Client_1.BlackListError('The signature signed the wrong message!', proof.expectedSigners.map(_ => ethUtil.toChecksumAddress(util_1.toHex(_)))); // recover the signer from the signature\n\n      const signer = util.pubToAddress(util.ecrecover(messageHash, util_1.toNumber(signature.v), serialize_1.bytes(signature.r), serialize_1.bytes(signature.s))); // make sure the signer is the expected one\n\n      if (!signer.equals(proof.expectedSigners[i])) throw new Error('The signature was not signed by ' + proof.expectedSigners[i]); // we have at least one valid signature, so we can try to cache it.\n\n      if (ctx && ctx instanceof EthChainContext_1.default && ctx.client.defConfig.maxBlockCache) ctx.addBlockHeader(util_1.toNumber(b.number), b.serializeHeader()); // looks good ;-)\n\n      return true;\n    }, true)) throw new Error('No valid signature');\n  });\n}\n\nexports.verifyBlock = verifyBlock;\n/** verifies a TransactionProof */\n\nfunction verifyTransactionProof(txHash, headerProof, txData, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!txData) throw new Error('No TransactionData!'); // decode the blockheader\n\n    const block = serialize_1.blockFromHex(headerProof.proof.block); // verify the blockhash and the signatures\n\n    yield verifyBlock(block, Object.assign({}, headerProof, {\n      expectedBlockHash: serialize_1.bytes32(txData.blockHash)\n    }), ctx);\n    verifyTransaction(txData);\n    const tx = serialize_1.toTransaction(txData);\n    const txHashofData = serialize_1.hash(tx);\n    if (util_1.toNumber(block.number) != util_1.toNumber(txData.blockNumber)) throw new Error('invalid blockNumber');\n    if (!serialize_1.bytes32(txData.hash).equals(txHashofData)) throw new Error('invalid txhash');\n    if (headerProof.proof.txIndex != util_1.toNumber(txData.transactionIndex)) throw new Error('invalid txIndex');\n    if (!txHashofData.equals(txHash)) throw new Error('The transactiondata were manipulated'); // verifiy the proof\n\n    yield merkleProof_1.default(block.transactionsTrie, // expected merkle root\n    util.rlp.encode(util_1.toNumber(headerProof.proof.txIndex)), // path, which is the transsactionIndex\n    headerProof.proof.merkleProof.map(serialize_1.bytes), // array of Buffer with the merkle-proof-data\n    serialize_1.serialize(tx), 'The Transaction can not be verified');\n  });\n}\n\nexports.verifyTransactionProof = verifyTransactionProof;\n/** verifies a TransactionProof */\n\nfunction verifyTransactionByBlockProof(request, headerProof, txData, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // decode the blockheader\n    const block = serialize_1.blockFromHex(headerProof.proof.block);\n    const txIndex = serialize_1.bytes32(request.params[1]);\n\n    if (!txData) {\n      yield merkleProof_1.default(block.transactionsTrie, // expected merkle root\n      util.rlp.encode(util_1.toNumber(txIndex)), // path, which is the transsactionIndex\n      headerProof.proof.merkleProof.map(serialize_1.bytes), // array of Buffer with the merkle-proof-data\n      null, 'The Transaction can not be verified');\n    } else {\n      // verify the blockhash and the signatures\n      verifyTransaction(txData);\n      const tx = serialize_1.toTransaction(txData);\n      const txHashofData = serialize_1.hash(tx);\n\n      if (request.method == \"eth_getTransactionByBlockHashAndIndex\") {\n        if (!serialize_1.bytes32(txData.blockHash).equals(serialize_1.bytes32(request.params[0]))) throw new Error('invalid blockHash in transaction data');\n        yield verifyBlock(block, Object.assign({}, headerProof, {\n          expectedBlockHash: serialize_1.bytes32(request.params[0])\n        }), ctx);\n      } else if (request.method == \"eth_getTransactionByBlockNumberAndIndex\") {\n        if (util_1.toNumber(serialize_1.bytes32(request.params[0])) != util_1.toNumber(block.number)) throw new Error('invalid blockNumber in request');\n        yield verifyBlock(block, Object.assign({}, headerProof, {\n          expectedBlockHash: serialize_1.bytes32(txData.blockHash)\n        }), ctx);\n      }\n\n      if (util_1.toNumber(block.number) != util_1.toNumber(txData.blockNumber)) throw new Error('invalid blockNumber');\n      if (!serialize_1.bytes32(txData.hash).equals(txHashofData)) throw new Error('invalid txhash');\n      if (util_1.toNumber(txIndex) != util_1.toNumber(headerProof.proof.txIndex)) throw new Error('invalid txIndex in request');\n      if (util_1.toNumber(txIndex) != util_1.toNumber(txData.transactionIndex)) throw new Error('invalid txIndex in transaction data'); // verifiy the proof\n\n      yield merkleProof_1.default(block.transactionsTrie, // expected merkle root\n      util.rlp.encode(util_1.toNumber(txIndex)), // path, which is the transsactionIndex\n      headerProof.proof.merkleProof.map(serialize_1.bytes), // array of Buffer with the merkle-proof-data\n      serialize_1.serialize(tx), 'The Transaction can not be verified');\n    }\n  });\n}\n\nexports.verifyTransactionByBlockProof = verifyTransactionByBlockProof;\n\nfunction verifyLog(l, block, blockHash, index, txIndex, txHash) {\n  if (l.blockHash !== blockHash) throw new Error('invalid blockhash');\n  if (util_1.toNumber(l.blockNumber) !== util_1.toNumber(block.number)) throw new Error('invalid blocknumber');\n  if (util_1.toNumber(l.logIndex) !== index) throw new Error('invalid logIndex');\n  if (l.transactionHash != txHash) throw new Error('invalid txHash');\n  if (util_1.toNumber(l.transactionIndex) != txIndex) throw new Error('invalid txIndex');\n}\n/** verifies a TransactionProof */\n\n\nfunction verifyTransactionReceiptProof(txHash, headerProof, receipt, ctx, useFullProof) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!receipt) throw new Error('No ReceiptData!');\n    if (useFullProof && headerProof.proof.txIndex > 0 && !headerProof.proof.merkleProofPrev) throw new Error('For Fullproof we expect the merkleProofPrev, which is missing!'); // decode the blockheader\n\n    const block = serialize_1.blockFromHex(headerProof.proof.block); // verify the blockhash and the signatures\n\n    yield verifyBlock(block, Object.assign({}, headerProof, {\n      expectedBlockHash: serialize_1.bytes32(receipt.blockHash)\n    }), ctx);\n    if (headerProof.proof.txIndex === 0 && receipt.cumulativeGasUsed !== receipt.gasUsed) throw new Error('gasUsed must match cumulativeGasUsed'); // since the blockhash is verified, we have the correct transaction root\n    // we use the txIndex, so only if both (the transaction matches the hash and ther receiptproof is verified, we know it is the right receipt)\n\n    if (util_1.toNumber(receipt.blockNumber) != util_1.toNumber(block.number)) throw new Error('Invalid BlockNumber');\n    if (!serialize_1.bytes32(receipt.transactionHash).equals(txHash)) throw new Error('Invalid txHash');\n    if (util_1.toNumber(receipt.transactionIndex) !== headerProof.proof.txIndex) throw new Error('Invalid txIndex'); // make sure the data in the receipts are correct\n\n    receipt.logs.forEach((t, i) => verifyLog(t, block, receipt.blockHash, i, util_1.toNumber(receipt.transactionIndex), receipt.transactionHash)); // verifiy the proof\n\n    return Promise.all([merkleProof_1.default(block.receiptTrie, // expected merkle root\n    util.rlp.encode(util_1.toNumber(headerProof.proof.txIndex)), // path, which is the transsactionIndex\n    headerProof.proof.merkleProof.map(serialize_1.bytes), // array of Buffer with the merkle-proof-data\n    serialize_1.serialize(serialize_1.toReceipt(receipt)), 'The TransactionReceipt can not be verified'), // prev\n    useFullProof && headerProof.proof.txIndex > 0 && merkleProof_1.default(block.receiptTrie, // expected merkle root\n    util.rlp.encode(util_1.toNumber(headerProof.proof.txIndex - 1)), // path, which is the transsactionIndex\n    headerProof.proof.merkleProof.map(serialize_1.bytes), undefined).then(r => {\n      const prevReceipt = serialize_1.rlp.decode(r);\n      const gasUsed = util_1.toNumber(receipt.cumulativeGasUsed) - util_1.toNumber(prevReceipt[prevReceipt.length - 3]);\n      if (util_1.toNumber(receipt.gasUsed) != gasUsed) throw new Error('The Transaction did consumed ' + gasUsed);\n    }), merkleProof_1.default(block.transactionsTrie, // expected merkle root\n    util.rlp.encode(util_1.toNumber(headerProof.proof.txIndex)), // path, which is the transsactionIndex\n    headerProof.proof.txProof.map(serialize_1.bytes), // array of Buffer with the merkle-proof-data\n    undefined, 'The TransactionIndex can not be verified').then(val => {\n      if (!serialize_1.hash(val).equals(txHash)) throw new Error('The TransactionHash does not match the prooved one');\n    })]);\n  });\n}\n\nexports.verifyTransactionReceiptProof = verifyTransactionReceiptProof;\n/** verifies a TransactionProof */\n\nfunction verifyLogProof(headerProof, logs, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!logs) throw new Error('No Logs!');\n    if (!logs.length) return;\n    if (!headerProof.proof.logProof) throw new Error('Missing LogProof');\n    const receiptData = {};\n    const blockHashes = {};\n    yield Promise.all(Object.keys(headerProof.proof.logProof).map(bn => __awaiter(this, void 0, void 0, function* () {\n      const blockProof = headerProof.proof.logProof[bn]; // decode the blockheader\n\n      const block = serialize_1.blockFromHex(blockProof.block);\n      blockHashes[bn] = block.hash();\n      if (util_1.toHex(blockProof.number) !== bn) throw new Error('wrong blocknumber'); // verify the blockhash and the signatures\n\n      yield verifyBlock(block, headerProof, ctx); // verifiy all merkle-Trees of the receipts\n\n      yield Promise.all(Object.keys(blockProof.receipts).map(txHash => merkleProof_1.default(block.receiptTrie, // expected merkle root\n      util.rlp.encode(blockProof.receipts[txHash].txIndex), // path, which is the transsactionIndex\n      blockProof.receipts[txHash].proof.map(serialize_1.bytes), // array of Buffer with the merkle-proof-data\n      undefined // we don't want to check, but use the found value in the next step\n      ).then(value => receiptData[txHash] = util.rlp.decode(value)))), // verifiy all merkle-Trees of the receipts\n      yield Promise.all(Object.keys(blockProof.receipts).map(txHash => merkleProof_1.default(block.transactionsTrie, // expected merkle root\n      util.rlp.encode(blockProof.receipts[txHash].txIndex), // path, which is the transsactionIndex\n      blockProof.receipts[txHash].txProof.map(serialize_1.bytes), // array of Buffer with the merkle-proof-data\n      undefined // we don't want to check, but use the found value in the next step\n      ).then(value => serialize_1.bytes32(txHash).equals(serialize_1.hash(value)) && serialize_1.bytes32(txHash).equals(serialize_1.bytes32(blockProof.receipts[txHash].txHash)) || Promise.reject(new Error('wrong txhash')))));\n    }))); // now verify the logdata\n\n    logs.forEach(l => {\n      const receipt = receiptData[l.transactionHash];\n      if (!receipt) throw new Error('The receipt ' + l.transactionHash + 'is missing in the proof');\n      const logData = receipt[receipt.length - 1][util_1.toNumber(l.transactionLogIndex)];\n      if (!logData) throw new Error('Log not found in Transaction');\n      if (!logData[0].equals(serialize_1.address(l.address))) throw new Error('Wrong address in log ');\n      if (logData[1].map(util_1.toHex).join() !== l.topics.join()) throw new Error('Wrong Topics in log ');\n      if (!logData[2].equals(serialize_1.bytes(l.data))) throw new Error('Wrong data in log ');\n      const bp = headerProof.proof.logProof[util_1.toHex(l.blockNumber)];\n      if (!bp) throw new Error('wrong blockNumber');\n      if (!blockHashes[util_1.toHex(l.blockNumber)].equals(serialize_1.bytes32(l.blockHash))) throw new Error('wrong blockhash');\n      if (!bp.receipts[l.transactionHash]) throw new Error('wrong transactionHash');\n      if (util_1.toNumber(bp.receipts[l.transactionHash].txIndex) !== util_1.toNumber(l.transactionIndex)) throw new Error('wrong transactionIndex');\n    });\n  });\n}\n\nexports.verifyLogProof = verifyLogProof;\n/** verifies a TransactionProof */\n\nfunction verifyBlockProof(request, data, headerProof, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // decode the blockheader\n    const block = new serialize_1.Block(headerProof.proof.block || data);\n    if (headerProof.proof.transactions) block.transactions = headerProof.proof.transactions.map(serialize_1.createTx);\n    let requiredHash = null;\n    if (request.method.endsWith('ByHash')) requiredHash = serialize_1.bytes32(request.params[0]);else if (parseInt(request.params[0]) && util_1.toNumber(request.params[0]) !== util_1.toNumber(block.number)) throw new Error('The Block does not contain the required blocknumber');\n    if (!requiredHash && request.method.indexOf('Count') < 0 && data) requiredHash = serialize_1.bytes32(data.hash); // we only need to verify the uncles, if they are actually part of the data\n\n    if (data && data.uncles) {\n      const bd = data;\n\n      if (bd.uncles.length === 0) {\n        if (!serialize_1.bytes32(bd.sha3Uncles).equals(serialize_1.bytes('0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347'))) throw new Error('Wrong uncle-hash');\n      } else if (request.in3.useFullProof) {\n        if (!headerProof.proof.uncles || headerProof.proof.uncles.length != bd.uncles.length) throw new Error('The Uncles are missing or wrong size!'); // we only verify uncles for full proof\n\n        const trie = new Trie();\n        yield Promise.all(headerProof.proof.uncles.map((b, i) => {\n          const header = util_1.toBuffer(b);\n          if (!serialize_1.hash(header).equals(util_1.toBuffer(bd.uncles[i]))) throw new Error('The uncle hash of uncle ' + i + ' is wrong');\n          return util_1.promisify(trie, trie.put, util.rlp.encode(i), header);\n        }));\n        if (!trie.root.equals(block.uncleHash)) throw new Error('The UncleRoot do not match uncles!');\n      }\n    } // verify the blockhash and the signatures\n\n\n    yield verifyBlock(block, Object.assign({}, headerProof, {\n      expectedBlockHash: requiredHash\n    }), ctx); // verify additional fields\n\n    if (data && request.method.indexOf('Count') < 0) {\n      const bd = data;\n      const d = data;\n      if (d.author && d.author !== bd.miner) throw new Error('Invalid author');\n      if (d.hash && !serialize_1.bytes32(d.hash).equals(requiredHash || block.hash())) throw new Error('Invalid hash');\n      if (d.mixHash && !serialize_1.bytes32(d.mixHash).equals(block.sealedFields[0])) throw new Error('Invalid mixHash');\n      if (d.nonce && !serialize_1.bytes8(d.nonce).equals(block.sealedFields[1])) throw new Error('Invalid nonce');\n    } // verify the transactions\n\n\n    if (block.transactions) {\n      const trie = new Trie();\n      yield Promise.all(block.transactions.map((tx, i) => util_1.promisify(trie, trie.put, util.rlp.encode(i), tx.serialize())));\n      const thash = block.transactions.length ? trie.root : util.KECCAK256_RLP;\n      if (!thash.equals(block.transactionsTrie)) throw new Error('The Transactions do not match transactionRoot!');\n    }\n\n    if (data && data.transactions) {\n      const rtransactions = data.transactions;\n      const blockTransactionLength = block.transactions && block.transactions.length || 0;\n      if (rtransactions.length != blockTransactionLength) throw new Error('wrong number of transactions in block');\n      if (request.params.length == 2 && request.params[1]) rtransactions.forEach((t, i) => {\n        if (t.blockHash && !serialize_1.bytes32(t.blockHash).equals(requiredHash || block.hash())) throw new Error('Invalid hash in tx');\n        if (t.blockNumber && util_1.toNumber(t.blockNumber) != util_1.toNumber(block.number)) throw new Error('Invalid blocknumber');\n        if (util_1.toNumber(t.transactionIndex) != i) throw new Error('Wrong transactionIndex');\n        verifyTransaction(t);\n      });else rtransactions.forEach((t, i) => {\n        if (!block.transactions[i].hash().equals(serialize_1.bytes32(t))) throw new Error('Invalid TransactionHash');\n      });\n    }\n\n    if (request.method.indexOf('Count') > 0 && util_1.toHex(block.transactions.length) != util_1.toHex(data)) throw new Error('The number of transaction does not match');\n  });\n}\n\nexports.verifyBlockProof = verifyBlockProof;\n\nfunction verifyTransaction(t) {\n  const raw = serialize_1.toTransaction(t);\n  let rawHash,\n      v = ethUtil.bufferToInt(serialize_1.bytes(t.v));\n\n  if (t.chainId) {\n    rawHash = serialize_1.hash([...raw.slice(0, 6), serialize_1.uint(t.chainId), Buffer.allocUnsafe(0), Buffer.allocUnsafe(0)]);\n    v -= util_1.toNumber(t.chainId) * 2 + 8;\n  } else rawHash = serialize_1.hash(raw.slice(0, 6));\n\n  if (new BN(t.s).cmp(N_DIV_2) === 1) throw new Error('Invalid signature');\n  const senderPubKey = ethUtil.ecrecover(rawHash, v, serialize_1.bytes(t.r), serialize_1.bytes(t.s));\n  if (!serialize_1.bytes(t.publicKey).equals(senderPubKey)) throw new Error('Invalid public key');\n  if (!serialize_1.address(t.from).equals(ethUtil.publicToAddress(senderPubKey))) throw new Error('Invalid from');\n  if (t.raw && !serialize_1.bytes(t.raw).equals(ethUtil.rlp.encode(raw))) throw new Error('Invalid Raw data');\n  if (t.standardV && util_1.toNumber(t.standardV) != v - 27) throw new Error('Invalid stanardV ');\n}\n\nexports.verifyTransaction = verifyTransaction;\n/** verifies a TransactionProof */\n\nfunction verifyAccountProof(request, value, headerProof, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!value) throw new Error('No Accountdata!'); // get the account this proof is based on\n\n    const account = serialize_1.address(request.method === 'in3_nodeList' ? value.contract : request.params[0]); // verify the blockhash and the signatures\n\n    const block = new serialize_1.Block(headerProof.proof.block); // TODO if we expect a specific block in the request, we should also check if the block is the one requested\n\n    yield verifyBlock(block, headerProof, ctx); // get the account-proof\n\n    const accountProof = headerProof.proof.accounts[Object.keys(headerProof.proof.accounts)[0]];\n    if (!accountProof) throw new Error('Missing Account in Account-Proof'); // verify the result\n\n    if (!account.equals(serialize_1.address(accountProof.address))) throw new Error('The Account does not match the account in the proof');\n\n    switch (request.method) {\n      case 'eth_getBalance':\n        if (!util_1.toBN(value).eq(util_1.toBN(accountProof.balance))) throw new Error('The Balance does not match the one in the proof');\n        break;\n\n      case 'eth_getStorageAt':\n        checkStorage(accountProof, serialize_1.bytes32(request.params[1]), serialize_1.bytes32(value));\n        break;\n\n      case 'eth_getCode':\n        if (!serialize_1.bytes32(accountProof.codeHash).equals(util.keccak(value))) throw new Error('The codehash in the proof does not match the code');\n        break;\n\n      case 'eth_getTransactionCount':\n        if (!util_1.toBN(accountProof.nonce).eq(util_1.toBN(value))) throw new Error('The nonce in the proof does not match the returned');\n        break;\n\n      case 'in3_nodeList':\n        verifyNodeListData(value, headerProof.proof, block, request); // the contract must be checked later in the updateList -function\n\n        break;\n\n      default:\n        throw new Error('Unsupported Account-Proof for ' + request.method);\n    } // verify the merkle tree of the account proof\n\n\n    yield verifyAccount(accountProof, block);\n  });\n}\n\nexports.verifyAccountProof = verifyAccountProof;\n\nfunction verifyNodeListData(nl, proof, block, request) {\n  // get the one account to check with\n  const accountProof = proof.accounts[Object.keys(proof.accounts)[0]];\n  if (!accountProof) throw new Error('Missing Account in Account-Proof'); // check the total servercount\n\n  checkStorage(accountProof, storage_1.getStorageArrayKey(0), serialize_1.bytes32(nl.totalServers), 'wrong number of servers '); // check blocknumber\n\n  if (util_1.toNumber(block.number) < nl.lastBlockNumber) throw new Error('The signature is based on older block!'); // if we requested a limit, we need to find out if the correct nodes where send.\n\n  const limit = request.params[0];\n\n  if (limit && limit < nl.totalServers) {\n    if (limit !== nl.nodes.length) throw new Error('The number of returned nodes must be ' + limit + ', since this was required and there are ' + nl.totalServers + ' servers'); // try to find the addresses in the node list\n\n    const idxs = (request.params[2] || []).map(adr => {\n      const a = nl.nodes.find(_ => _.address === adr);\n      if (!a) throw new Error('The required address ' + adr + ' is not part of the list!');\n      return a.index;\n    }); // create the index the same way the server should\n\n    serverList_1.createRandomIndexes(nl.totalServers, limit, serialize_1.bytes32(request.params[1]), idxs); // veryfy the index is in the same order\n\n    if (idxs.length !== limit) throw new Error('wrong number of index');\n    idxs.forEach((index, i) => {\n      if (nl.nodes[i].index !== index) throw new Error('the index of node nr. ' + (i + 1) + ' needs to be ' + index);\n    });\n  } else {\n    // check server count\n    if (nl.nodes.length !== nl.totalServers) throw new Error('Wrong number of nodes!'); // check the index of the result\n\n    const failedNode = nl.nodes.find((n, i) => n.index !== i);\n    if (failedNode) throw new Error('The node ' + failedNode.url + ' has the wrong index!');\n  } // verify the values of the proof\n\n\n  for (const n of nl.nodes) {\n    checkStorage(accountProof, storage_1.getStorageArrayKey(0, n.index, 6, 1), serialize_1.bytes32(Buffer.concat([serialize_1.uint64(n.timeout ? n.timeout : 0), serialize_1.address(n.address)])), 'wrong owner '); // when checking the deposit we have to take into account the fact, that anumber only support 53bits and may not be able to hit the exact ammount, but it should always be equals\n\n    const deposit = getStorageValue(accountProof, storage_1.getStorageArrayKey(0, n.index, 6, 2));\n    if (parseInt(util_1.toBN(deposit).toString()) != parseInt(n.deposit)) throw new Error('wrong deposit '); //    checkStorage(accountProof, getStorageArrayKey(0, n.index, 6, 2), bytes32(n.deposit), 'wrong deposit ')\n\n    const props = serialize_1.bytes32(n.props);\n    if (n.capacity) props.writeUInt32BE(n.capacity, 12);\n    checkStorage(accountProof, storage_1.getStorageArrayKey(0, n.index, 6, 3), props, 'wrong props ');\n    const urlKey = storage_1.getStorageArrayKey(0, n.index, 6, 0);\n    const urlVal = storage_1.getStringValue(getStorageValue(accountProof, urlKey), urlKey);\n\n    if (typeof urlVal === 'string') {\n      if (urlVal !== n.url) throw new Error('Wrong url in proof ' + n.url);\n    } else {\n      const url = Buffer.concat(urlVal.storageKeys.map(_ => getStorageValue(accountProof, _))).slice(0, urlVal.len).toString('utf8');\n      if (url !== n.url) throw new Error('Wrong url in proof ' + n.url);\n    }\n  }\n}\n\nfunction checkStorage(ap, key, value, msg) {\n  if (!getStorageValue(ap, key).equals(value)) throw new Error(msg + ('The key has the wrong value (expected: ' + util_1.toMinHex(value) + ' proven:' + util_1.toMinHex(getStorageValue(ap, key))));\n}\n\nfunction getStorageValue(ap, storageKey) {\n  let key = util_1.toMinHex(storageKey);\n  let entry = ap.storageProof.find(_ => _.key === key);\n\n  if (!entry && key.length % 2) {\n    key = '0x0' + key.substr(2);\n    entry = ap.storageProof.find(_ => _.key === key);\n  }\n\n  if (!entry) throw new Error(' There is no storrage key ' + key + ' in the storage proof!');\n  return serialize_1.bytes32(entry.value);\n}\n\nexports.getStorageValue = getStorageValue;\n/** verifies a TransactionProof */\n\nfunction verifyCallProof(request, value, headerProof, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // verify the blockhash and the signatures\n    const block = new serialize_1.Block(headerProof.proof.block); // TODO if we expect a specific block in the request, we should also check if the block is the one requested\n\n    yield verifyBlock(block, headerProof, ctx);\n    if (!headerProof.proof.accounts) throw new Error('No Accounts to verify'); // make sure, we have all codes\n\n    const missingCode = Object.keys(headerProof.proof.accounts).filter(ac => !headerProof.proof.accounts[ac].code && headerProof.proof.accounts[ac].codeHash !== '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'); // in case there are some missing codes, we fetch them with one unproved request through the cache, since they will be verified later anyway.\n\n    if (missingCode.length && ctx && ctx instanceof EthChainContext_1.default) yield ctx.getCodeFor(missingCode.map(serialize_1.address), util_1.toHex(block.number)).then(_ => _.forEach((c, i) => headerProof.proof.accounts[missingCode[i]].code = c)); // verify all accounts\n\n    yield Promise.all(Object.keys(headerProof.proof.accounts).map(adr => verifyAccount(headerProof.proof.accounts[adr], block))); // now create a vm and run the transaction\n\n    const result = yield call_1.executeCall(request.params[0], headerProof.proof.accounts, new serialize_1.Block({\n      parentHash: block.parentHash,\n      sha3Uncles: block.uncleHash,\n      miner: block.coinbase,\n      stateRoot: block.stateRoot,\n      transactionsRoot: block.transactionsTrie,\n      receiptRoot: block.receiptTrie,\n      logsBloom: block.bloom,\n      difficulty: block.difficulty,\n      number: block.number,\n      gasLimit: block.gasLimit,\n      gasUsed: block.gasUsed,\n      timestamp: block.timestamp,\n      extraData: block.extra\n    }).serializeHeader());\n    if (!result.equals(value)) throw new Error('The result does not match the execution !');\n  });\n}\n\nexports.verifyCallProof = verifyCallProof;\n/** verify a an account */\n\nfunction verifyAccount(accountProof, block) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // if we received the code, make sure the codeHash is correct!\n    if (accountProof.code && !util.keccak(accountProof.code).equals(serialize_1.bytes32(accountProof.codeHash))) throw new Error('The code does not math the correct codehash! ');\n    const emptyAccount = isNotExistend(accountProof);\n    if (emptyAccount && accountProof.storageHash !== '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421') throw new Error('Invalid storageHash');\n    return Promise.all([merkleProof_1.default(block.stateRoot, // expected merkle root\n    util.keccak(accountProof.address), // path, which is the transsactionIndex\n    accountProof.accountProof.map(serialize_1.bytes), // array of Buffer with the merkle-proof-data\n    emptyAccount ? null : serialize_1.serialize(serialize_1.toAccount(accountProof)), 'The Account could not be verified'), // and all storage proofs\n    ...accountProof.storageProof.map(s => merkleProof_1.default(serialize_1.bytes32(accountProof.storageHash), // the storageRoot of the account\n    util.keccak(serialize_1.bytes32(s.key)), // the path, which is the hash of the key\n    s.proof.map(serialize_1.bytes), // array of Buffer with the merkle-proof-data\n    util_1.toNumber(s.value) === 0 ? null : util.rlp.encode(s.value), 'The Storage could not be verified'))]);\n  });\n}\n\nfunction isNotExistend(account) {\n  // TODO how do I determine the default nonce? It is in the chain-config\n  return util_1.toNumber(account.balance) === 0 && account.codeHash == '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470' && util_1.toNumber(account.nonce) === 0;\n}\n\nfunction checkBlock(block, ctx, blockNumber) {\n  if (!block) return block;\n\n  if (typeof block === 'string' && !block.startsWith('0x') && ctx instanceof EthChainContext_1.default) {\n    const bh = ctx.getBlockHeader(util_1.toNumber(block));\n    if (!bh) throw new Error('The server returned a not supported blockheader : ' + block);\n    return bh;\n  }\n\n  return block;\n}\n\nfunction handleBlockCache(proof, ctx) {\n  if (!ctx || !ctx.client.defConfig.maxBlockCache) return;\n  if (proof.block) proof.block = checkBlock(proof.block, ctx);\n  if (proof.logProof) Object.keys(proof.logProof).forEach(bn => {\n    const v = proof.logProof[bn];\n    v.block = checkBlock(v.block, ctx, util_1.toNumber(bn));\n  });\n}\n/** general verification-function which handles it according to its given type. */\n\n\nfunction verifyProof(request, response, allowWithoutProof = true, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // make sure we ignore errors caused by sending a trnasaction to multiple servers.\n    if (request.method === 'eth_sendRawTransaction' && response.error && (response.error.code === -32010 || response.error.toString().indexOf('already imported') >= 0)) {\n      delete response.error;\n      response.result = util_1.toHex(serialize_1.hash(serialize_1.bytes(request.params[0])), 20);\n    } // handle verification with implicit proof (like ipfs)\n\n\n    if (request.method === 'ipfs_get' && response.result) return ipfs_1.verifyIPFSHash(response.result, request.params[1] || 'base64', request.params[0]); // make sure we only throw an exception for missing proof, if the proof is possible\n\n    const proof = response && response.in3 && response.in3.proof;\n\n    if (!proof) {\n      if (allowedWithoutProof.indexOf(request.method) >= 0) return true; // exceptions\n\n      if (request.method === 'eth_getLogs' && response.result && response.result.length === 0) return true;\n      if (request.method.startsWith('eth_getTransaction') && !response.result) return true;\n      if (!allowWithoutProof && !response.error) throw new Error('the response does not contain any proof!');\n      return !!response.error || allowWithoutProof;\n    } //attach the lastValidatorChange to the chain context\n\n\n    if ((response.in3.lastValidatorChange || 0) > ctx.lastValidatorChange) ctx.lastValidatorChange = response.in3.lastValidatorChange; // check BlockCache and convert all blockheaders to buffer\n\n    handleBlockCache(proof, ctx); // convert all signatures into buffer\n\n    const headerProof = {\n      proof,\n      expectedSigners: request.in3 && request.in3.signatures && request.in3.signatures.map(serialize_1.address),\n      finality: request.in3 && request.in3.finality\n    };\n\n    switch (proof.type) {\n      case 'transactionProof':\n        if (request.method == \"eth_getTransactionByBlockHashAndIndex\" || request.method == \"eth_getTransactionByBlockNumberAndIndex\") yield verifyTransactionByBlockProof(request, headerProof, response.result, ctx);else yield verifyTransactionProof(serialize_1.bytes32(request.params[0]), headerProof, response.result, ctx);\n        break;\n\n      case 'logProof':\n        yield verifyLogProof(headerProof, response.result && response.result, ctx);\n        break;\n\n      case 'receiptProof':\n        yield verifyTransactionReceiptProof(serialize_1.bytes32(request.params[0]), headerProof, response.result && response.result, ctx, request.in3.useFullProof);\n        break;\n\n      case 'blockProof':\n        yield verifyBlockProof(request, response.result, headerProof, ctx);\n        break;\n\n      case 'accountProof':\n        yield verifyAccountProof(request, response.result, headerProof, ctx);\n        break;\n\n      case 'callProof':\n        yield verifyCallProof(request, serialize_1.bytes(response.result), headerProof, ctx);\n        break;\n\n      default:\n        throw new Error('Unsupported proof-type : ' + proof.type);\n    }\n\n    return true;\n  });\n}\n\nexports.verifyProof = verifyProof;","map":null,"metadata":{},"sourceType":"script"}