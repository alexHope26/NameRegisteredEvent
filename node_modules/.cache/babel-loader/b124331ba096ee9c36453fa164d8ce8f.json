{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar Trie = require('merkle-patricia-tree/secure.js');\n\nvar common = require('ethereum-common');\n\nvar async = require('async');\n\nvar Account = require('ethereumjs-account');\n\nvar fakeBlockchain = require('./fakeBlockChain.js');\n\nvar Cache = require('./cache.js');\n\nvar utils = require('ethereumjs-util');\n\nvar BN = utils.BN;\nvar rlp = utils.rlp;\nmodule.exports = StateManager;\n\nfunction StateManager(opts) {\n  var self = this;\n  var trie = opts.trie;\n\n  if (!trie) {\n    trie = new Trie(trie);\n  }\n\n  var blockchain = opts.blockchain;\n\n  if (!blockchain) {\n    blockchain = fakeBlockchain;\n  }\n\n  self.blockchain = blockchain;\n  self.trie = trie;\n  self._storageTries = {}; // the storage trie cache\n\n  self.cache = new Cache(trie);\n  self._touched = new Set();\n}\n\nvar proto = StateManager.prototype;\n\nproto.copy = function () {\n  return new StateManager({\n    trie: this.trie.copy(),\n    blockchain: this.blockchain\n  });\n}; // gets the account from the cache, or triggers a lookup and stores\n// the result in the cache\n\n\nproto.getAccount = function (address, cb) {\n  this.cache.getOrLoad(address, cb);\n}; // checks if an account exists\n\n\nproto.exists = function (address, cb) {\n  this.cache.getOrLoad(address, function (err, account) {\n    cb(err, account.exists);\n  });\n}; // saves the account\n\n\nproto.putAccount = function (address, account, cb) {\n  var self = this; // TODO: dont save newly created accounts that have no balance\n  // if (toAccount.balance.toString('hex') === '00') {\n  // if they have money or a non-zero nonce or code, then write to tree\n\n  self.cache.put(address, account);\n\n  self._touched.add(address.toString('hex')); // self.trie.put(addressHex, account.serialize(), cb)\n\n\n  cb();\n};\n\nproto.getAccountBalance = function (address, cb) {\n  var self = this;\n  self.getAccount(address, function (err, account) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, account.balance);\n  });\n};\n\nproto.putAccountBalance = function (address, balance, cb) {\n  var self = this;\n  self.getAccount(address, function (err, account) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (new BN(balance).isZero() && !account.exists) {\n      return cb(null);\n    }\n\n    account.balance = balance;\n    self.putAccount(address, account, cb);\n  });\n}; // sets the contract code on the account\n\n\nproto.putContractCode = function (address, value, cb) {\n  var self = this;\n  self.getAccount(address, function (err, account) {\n    if (err) {\n      return cb(err);\n    } // TODO: setCode use trie.setRaw which creates a storage leak\n\n\n    account.setCode(self.trie, value, function (err) {\n      if (err) {\n        return cb(err);\n      }\n\n      self.putAccount(address, account, cb);\n    });\n  });\n}; // given an account object, returns the code\n\n\nproto.getContractCode = function (address, cb) {\n  var self = this;\n  self.getAccount(address, function (err, account) {\n    if (err) {\n      return cb(err);\n    }\n\n    account.getCode(self.trie, cb);\n  });\n}; // creates a storage trie from the primary storage trie\n\n\nproto._lookupStorageTrie = function (address, cb) {\n  var self = this; // from state trie\n\n  self.getAccount(address, function (err, account) {\n    if (err) {\n      return cb(err);\n    }\n\n    var storageTrie = self.trie.copy();\n    storageTrie.root = account.stateRoot;\n    storageTrie._checkpoints = [];\n    cb(null, storageTrie);\n  });\n}; // gets the storage trie from the storage cache or does lookup\n\n\nproto._getStorageTrie = function (address, cb) {\n  var self = this;\n\n  var storageTrie = self._storageTries[address.toString('hex')]; // from storage cache\n\n\n  if (storageTrie) {\n    return cb(null, storageTrie);\n  } // lookup from state\n\n\n  self._lookupStorageTrie(address, cb);\n};\n\nproto.getContractStorage = function (address, key, cb) {\n  var self = this;\n\n  self._getStorageTrie(address, function (err, trie) {\n    if (err) {\n      return cb(err);\n    }\n\n    trie.get(key, function (err, value) {\n      if (err) {\n        return cb(err);\n      }\n\n      var decoded = rlp.decode(value);\n      cb(null, decoded);\n    });\n  });\n};\n\nproto.putContractStorage = function (address, key, value, cb) {\n  var self = this;\n\n  self._getStorageTrie(address, function (err, storageTrie) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (value && value.length) {\n      // format input\n      var encodedValue = rlp.encode(value);\n      storageTrie.put(key, encodedValue, finalize);\n    } else {\n      // deleting a value\n      storageTrie.del(key, finalize);\n    }\n\n    function finalize(err) {\n      if (err) return cb(err); // update storage cache\n\n      self._storageTries[address.toString('hex')] = storageTrie; // update contract stateRoot\n\n      var contract = self.cache.get(address);\n      contract.stateRoot = storageTrie.root;\n      self.putAccount(address, contract, cb);\n\n      self._touched.add(address.toString('hex'));\n    }\n  });\n};\n\nproto.commitContracts = function (cb) {\n  var self = this;\n  async.each(Object.keys(self._storageTries), function (address, cb) {\n    var trie = self._storageTries[address];\n    delete self._storageTries[address]; // TODO: this is broken on the block level; all the contracts get written to\n    // disk redardless of whether or not the block is valid\n\n    if (trie.isCheckpoint) {\n      trie.commit(cb);\n    } else {\n      cb();\n    }\n  }, cb);\n};\n\nproto.revertContracts = function () {\n  var self = this;\n  self._storageTries = {};\n\n  self._touched.clear();\n}; //\n// blockchain\n//\n\n\nproto.getBlockHash = function (number, cb) {\n  var self = this;\n  self.blockchain.getBlock(number, function (err, block) {\n    if (err) {\n      return cb(err);\n    }\n\n    var blockHash = block.hash();\n    cb(null, blockHash);\n  });\n}; //\n// revision history\n//\n\n\nproto.checkpoint = function () {\n  var self = this;\n  self.trie.checkpoint();\n  self.cache.checkpoint();\n};\n\nproto.commit = function (cb) {\n  var self = this; // setup trie checkpointing\n\n  self.trie.commit(function () {\n    // setup cache checkpointing\n    self.cache.commit();\n    cb();\n  });\n};\n\nproto.revert = function (cb) {\n  var self = this; // setup trie checkpointing\n\n  self.trie.revert(); // setup cache checkpointing\n\n  self.cache.revert();\n  cb();\n}; //\n// cache stuff\n//\n\n\nproto.getStateRoot = function (cb) {\n  var self = this;\n  self.cacheFlush(function (err) {\n    if (err) {\n      return cb(err);\n    }\n\n    var stateRoot = self.trie.root;\n    cb(null, stateRoot);\n  });\n};\n/**\n * @param {Set} address\n * @param {cb} function\n */\n\n\nproto.warmCache = function (addresses, cb) {\n  this.cache.warm(addresses, cb);\n};\n\nproto.dumpStorage = function (address, cb) {\n  var self = this;\n\n  self._getStorageTrie(address, function (err, trie) {\n    if (err) {\n      return cb(err);\n    }\n\n    var storage = {};\n    var stream = trie.createReadStream();\n    stream.on('data', function (val) {\n      storage[val.key.toString('hex')] = val.value.toString('hex');\n    });\n    stream.on('end', function () {\n      cb(storage);\n    });\n  });\n};\n\nproto.hasGenesisState = function (cb) {\n  var root = common.genesisStateRoot.v;\n  this.trie.checkRoot(root, cb);\n};\n\nproto.generateCanonicalGenesis = function (cb) {\n  var self = this;\n  this.hasGenesisState(function (err, genesis) {\n    if (!genesis && !err) {\n      self.generateGenesis(common.genesisState, cb);\n    } else {\n      cb(err);\n    }\n  });\n};\n\nproto.generateGenesis = function (initState, cb) {\n  var self = this;\n  var addresses = Object.keys(initState);\n  async.eachSeries(addresses, function (address, done) {\n    var account = new Account();\n    account.balance = new BN(initState[address]).toArrayLike(Buffer);\n    address = Buffer.from(address, 'hex');\n    self.trie.put(address, account.serialize(), done);\n  }, cb);\n};\n\nproto.accountIsEmpty = function (address, cb) {\n  var self = this;\n  self.getAccount(address, function (err, account) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, account.nonce.toString('hex') === '' && account.balance.toString('hex') === '' && account.codeHash.toString('hex') === utils.SHA3_NULL_S);\n  });\n};\n\nproto.cleanupTouchedAccounts = function (cb) {\n  var self = this;\n  var touchedArray = Array.from(self._touched);\n  async.forEach(touchedArray, function (addressHex, next) {\n    var address = Buffer.from(addressHex, 'hex');\n    self.accountIsEmpty(address, function (err, empty) {\n      if (err) {\n        next(err);\n        return;\n      }\n\n      if (empty) {\n        self.cache.del(address);\n      }\n\n      next(null);\n    });\n  }, function () {\n    self._touched.clear();\n\n    cb();\n  });\n};","map":null,"metadata":{},"sourceType":"script"}