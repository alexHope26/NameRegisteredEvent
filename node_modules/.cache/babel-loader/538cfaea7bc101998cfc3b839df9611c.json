{"ast":null,"code":"\"use strict\";\n/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst verify_1 = require(\"./verify\");\n\nconst VM = require(\"ethereumjs-vm\");\n\nconst Account = require(\"ethereumjs-account\");\n\nconst Block = require(\"ethereumjs-block\");\n\nconst Trie = require(\"merkle-patricia-tree\");\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst serialize_1 = require(\"./serialize\");\n\nconst util_1 = require(\"../../util/util\");\n/** executes a transaction-call to a smart contract */\n\n\nfunction executeCall(args, accounts, block) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // fix account-keys, so all the addresses are formated the same way\n    Object.keys(accounts).forEach(a => accounts[util_1.toHex(a, 20).toLowerCase()] = accounts[a]); // create new state for a vm\n\n    const state = new Trie();\n    const vm = new VM({\n      state\n    }); // set all storage values from the proof in the state\n\n    yield setStorageFromProof(state, accounts); // create a transaction-object\n\n    const tx = serialize_1.createTx(Object.assign({\n      gas: '0x5b8d80',\n      gasLimit: '0x5b8d80',\n      from: '0x0000000000000000000000000000000000000000'\n    }, args)); // keep track of each opcode in order to make sure, all storage-values are provided!\n\n    let missingDataError = null;\n    vm.on('step', ev => {\n      // TODO als check the following opcodes:\n      // - BLOCKHASH\n      // - COINBASE ( since we are currently not using a real block!)\n      // and we need to check if the target contract exists (even though it would most likely fail if not)\n      // - STATIONCALL\n      switch (ev.opcode.name) {\n        case 'BALANCE':\n        case 'EXTCODESIZE':\n        case 'EXTCODECOPY':\n          const balanceContract = util_1.toHex('0x' + ev.stack[ev.stack.length - 1].toString(16), 20);\n          if (!accounts[balanceContract]) missingDataError = new Error('The contract ' + balanceContract + ' is used to get the balance but is missing in the proof!');\n          break;\n\n        case 'CALL':\n        case 'CALLCODE':\n        case 'DELEGATECALL':\n        case 'STATICCALL':\n          const callContract = util_1.toHex('0x' + ev.stack[ev.stack.length - 2].toString(16), 20);\n          if (!accounts[callContract]) missingDataError = new Error('The contract ' + callContract + ' is used to get the balance but is missing in the proof!');\n          break;\n\n        case 'SLOAD':\n          const contract = util_1.toHex(ev.address, 20);\n          const key = serialize_1.bytes32(ev.stack[ev.stack.length - 1]);\n          const ac = accounts[contract]; // check if this key is part of the acountProof, if not the result can not be trusted\n\n          if (!ac) missingDataError = new Error('The contract ' + contract + ' is used but is missing in the proof! proof=' + JSON.stringify(accounts, null, 2));else if (!verify_1.getStorageValue(ac, key)) missingDataError = new Error('The storage value ' + key + ' in ' + contract + ' is used but is missing in the proof!');\n          break;\n\n        default:\n          return;\n      } //    console.log('step ' + counter + ' : ' + ev.opcode.name + ' pc:' + ev.pc + 'stack: ' + ev.stack.map(_ => _.toString(16)))\n\n    }); // run the tx\n\n    const result = yield util_1.promisify(vm, vm.runTx, {\n      tx,\n      block: new Block([block, [], []])\n    }); // return the returnValue\n\n    if (missingDataError) throw missingDataError;\n    return result.vm.return;\n  });\n}\n\nexports.executeCall = executeCall;\n\nfunction setStorageFromProof(trie, accounts) {\n  return __awaiter(this, void 0, void 0, function* () {\n    for (const adr of Object.keys(accounts)) {\n      const ac = accounts[adr]; // create an account-object\n\n      const account = new Account();\n      if (ac.balance) account.balance = ac.balance;\n      if (ac.nonce) account.nonce = ac.nonce;\n      if (ac.codeHash) account.codeHash = ac.codeHash; // if we have a code, we will set the code\n\n      if (ac.code) yield util_1.promisify(account, account.setCode, trie, util_1.toBuffer(ac.code)); // set all storage-values\n\n      for (const s of ac.storageProof) yield util_1.promisify(account, account.setStorage, trie, util_1.toBuffer(s.key, 32), ethereumjs_util_1.rlp.encode(util_1.toBuffer(s.value, 32))); // set the account data\n\n\n      yield util_1.promisify(trie, trie.put, util_1.toBuffer(adr, 20), account.serialize());\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}