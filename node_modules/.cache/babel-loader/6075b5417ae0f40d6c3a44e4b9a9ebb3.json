{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar async = require('async');\n\nvar fees = require('ethereum-common');\n\nvar utils = require('ethereumjs-util');\n\nvar BN = utils.BN;\n\nvar exceptions = require('./exceptions.js');\n\nvar logTable = require('./logTable.js');\n\nvar ERROR = exceptions.ERROR;\nvar VmError = exceptions.VmError;\nvar MASK_160 = new BN(1).shln(160).subn(1); // Find Ceil(`this` / `num`)\n\nBN.prototype.divCeil = function divCeil(num) {\n  var dm = this.divmod(num); // Fast case - exact division\n\n  if (dm.mod.isZero()) return dm.div; // Round up\n\n  return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n};\n\nfunction addressToBuffer(address) {\n  return address.and(MASK_160).toArrayLike(Buffer, 'be', 20);\n} // the opcode functions\n\n\nmodule.exports = {\n  STOP: function STOP(runState) {\n    runState.stopped = true;\n  },\n  ADD: function ADD(a, b, runState) {\n    return a.add(b).mod(utils.TWO_POW256);\n  },\n  MUL: function MUL(a, b, runState) {\n    return a.mul(b).mod(utils.TWO_POW256);\n  },\n  SUB: function SUB(a, b, runState) {\n    return a.sub(b).toTwos(256);\n  },\n  DIV: function DIV(a, b, runState) {\n    if (b.isZero()) {\n      return new BN(b);\n    } else {\n      return a.div(b);\n    }\n  },\n  SDIV: function SDIV(a, b, runState) {\n    if (b.isZero()) {\n      return new BN(b);\n    } else {\n      a = a.fromTwos(256);\n      b = b.fromTwos(256);\n      return a.div(b).toTwos(256);\n    }\n  },\n  MOD: function MOD(a, b, runState) {\n    if (b.isZero()) {\n      return new BN(b);\n    } else {\n      return a.mod(b);\n    }\n  },\n  SMOD: function SMOD(a, b, runState) {\n    if (b.isZero()) {\n      return new BN(b);\n    } else {\n      a = a.fromTwos(256);\n      b = b.fromTwos(256);\n      var r = a.abs().mod(b.abs());\n\n      if (a.isNeg()) {\n        r = r.ineg();\n      }\n\n      return r.toTwos(256);\n    }\n  },\n  ADDMOD: function ADDMOD(a, b, c, runState) {\n    if (c.isZero()) {\n      return new BN(c);\n    } else {\n      return a.add(b).mod(c);\n    }\n  },\n  MULMOD: function MULMOD(a, b, c, runState) {\n    if (c.isZero()) {\n      return new BN(c);\n    } else {\n      return a.mul(b).mod(c);\n    }\n  },\n  EXP: function EXP(base, exponent, runState) {\n    var m = BN.red(utils.TWO_POW256);\n    base = base.toRed(m);\n\n    if (!exponent.isZero()) {\n      var bytes = 1 + logTable(exponent);\n      subGas(runState, new BN(bytes).muln(fees.expByteGas.v));\n      return base.redPow(exponent);\n    } else {\n      return new BN(1);\n    }\n  },\n  SIGNEXTEND: function SIGNEXTEND(k, val, runState) {\n    val = val.toArrayLike(Buffer, 'be', 32);\n    var extendOnes = false;\n\n    if (k.lten(31)) {\n      k = k.toNumber();\n\n      if (val[31 - k] & 0x80) {\n        extendOnes = true;\n      } // 31-k-1 since k-th byte shouldn't be modified\n\n\n      for (var i = 30 - k; i >= 0; i--) {\n        val[i] = extendOnes ? 0xff : 0;\n      }\n    }\n\n    return new BN(val);\n  },\n  // 0x10 range - bit ops\n  LT: function LT(a, b, runState) {\n    return new BN(a.lt(b) ? 1 : 0);\n  },\n  GT: function GT(a, b, runState) {\n    return new BN(a.gt(b) ? 1 : 0);\n  },\n  SLT: function SLT(a, b, runState) {\n    return new BN(a.fromTwos(256).lt(b.fromTwos(256)) ? 1 : 0);\n  },\n  SGT: function SGT(a, b, runState) {\n    return new BN(a.fromTwos(256).gt(b.fromTwos(256)) ? 1 : 0);\n  },\n  EQ: function EQ(a, b, runState) {\n    return new BN(a.eq(b) ? 1 : 0);\n  },\n  ISZERO: function ISZERO(a, runState) {\n    return new BN(a.isZero() ? 1 : 0);\n  },\n  AND: function AND(a, b, runState) {\n    return a.and(b);\n  },\n  OR: function OR(a, b, runState) {\n    return a.or(b);\n  },\n  XOR: function XOR(a, b, runState) {\n    return a.xor(b);\n  },\n  NOT: function NOT(a, runState) {\n    return a.notn(256);\n  },\n  BYTE: function BYTE(pos, word, runState) {\n    if (pos.gten(32)) {\n      return new BN(0);\n    }\n\n    return new BN(word.shrn((31 - pos.toNumber()) * 8).andln(0xff));\n  },\n  // 0x20 range - crypto\n  SHA3: function SHA3(offset, length, runState) {\n    var data = memLoad(runState, offset, length); // copy fee\n\n    subGas(runState, new BN(fees.sha3WordGas.v).imul(length.divCeil(new BN(32))));\n    return new BN(utils.sha3(data));\n  },\n  // 0x30 range - closure state\n  ADDRESS: function ADDRESS(runState) {\n    return new BN(runState.address);\n  },\n  BALANCE: function BALANCE(address, runState, cb) {\n    var stateManager = runState.stateManager; // stack to address\n\n    address = addressToBuffer(address); // shortcut if current account\n\n    if (address.toString('hex') === runState.address.toString('hex')) {\n      cb(null, new BN(runState.contract.balance));\n      return;\n    } // otherwise load account then return balance\n\n\n    stateManager.getAccountBalance(address, function (err, value) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, new BN(value));\n    });\n  },\n  ORIGIN: function ORIGIN(runState) {\n    return new BN(runState.origin);\n  },\n  CALLER: function CALLER(runState) {\n    return new BN(runState.caller);\n  },\n  CALLVALUE: function CALLVALUE(runState) {\n    return new BN(runState.callValue);\n  },\n  CALLDATALOAD: function CALLDATALOAD(pos, runState) {\n    if (pos.gtn(runState.callData.length)) {\n      return new BN(0);\n    } else {\n      pos = pos.toNumber();\n      var loaded = runState.callData.slice(pos, pos + 32);\n      loaded = loaded.length ? loaded : Buffer.from([0]);\n      return new BN(utils.setLengthRight(loaded, 32));\n    }\n  },\n  CALLDATASIZE: function CALLDATASIZE(runState) {\n    if (runState.callData.length === 1 && runState.callData[0] === 0) {\n      return new BN(0);\n    } else {\n      return new BN(runState.callData.length);\n    }\n  },\n  CALLDATACOPY: function CALLDATACOPY(memOffset, dataOffset, dataLength, runState) {\n    memStore(runState, memOffset, runState.callData, dataOffset, dataLength); // sub the COPY fee\n\n    subGas(runState, new BN(fees.copyGas.v).imul(dataLength.divCeil(new BN(32))));\n  },\n  CODESIZE: function CODESIZE(runState) {\n    return new BN(runState.code.length);\n  },\n  CODECOPY: function CODECOPY(memOffset, codeOffset, length, runState) {\n    memStore(runState, memOffset, runState.code, codeOffset, length); // sub the COPY fee\n\n    subGas(runState, new BN(fees.copyGas.v).imul(length.divCeil(new BN(32))));\n  },\n  EXTCODESIZE: function EXTCODESIZE(address, runState, cb) {\n    var stateManager = runState.stateManager;\n    address = addressToBuffer(address);\n    stateManager.getContractCode(address, function (err, code) {\n      if (err) return cb(err);\n      cb(null, new BN(code.length));\n    });\n  },\n  EXTCODECOPY: function EXTCODECOPY(address, memOffset, codeOffset, length, runState, cb) {\n    var stateManager = runState.stateManager;\n    address = addressToBuffer(address); // FIXME: for some reason this must come before subGas\n\n    subMemUsage(runState, memOffset, length); // copy fee\n\n    subGas(runState, new BN(fees.copyGas.v).imul(length.divCeil(new BN(32))));\n    stateManager.getContractCode(address, function (err, code) {\n      if (err) return cb(err);\n      memStore(runState, memOffset, code, codeOffset, length, false);\n      cb(null);\n    });\n  },\n  RETURNDATASIZE: function RETURNDATASIZE(runState) {\n    return new BN(runState.lastReturned.length);\n  },\n  RETURNDATACOPY: function RETURNDATACOPY(memOffset, returnDataOffset, length, runState) {\n    if (returnDataOffset.add(length).gtn(runState.lastReturned.length)) {\n      trap(ERROR.OUT_OF_GAS);\n    }\n\n    memStore(runState, memOffset, utils.toBuffer(runState.lastReturned), returnDataOffset, length, false); // sub the COPY fee\n\n    subGas(runState, new BN(fees.copyGas.v).mul(length.divCeil(new BN(32))));\n  },\n  GASPRICE: function GASPRICE(runState) {\n    return new BN(runState.gasPrice);\n  },\n  // '0x40' range - block operations\n  BLOCKHASH: function BLOCKHASH(number, runState, cb) {\n    var stateManager = runState.stateManager;\n    var diff = new BN(runState.block.header.number).sub(number); // block lookups must be within the past 256 blocks\n\n    if (diff.gtn(256) || diff.lten(0)) {\n      cb(null, new BN(0));\n      return;\n    }\n\n    stateManager.getBlockHash(number.toArrayLike(Buffer, 'be', 32), function (err, blockHash) {\n      if (err) return cb(err);\n      cb(null, new BN(blockHash));\n    });\n  },\n  COINBASE: function COINBASE(runState) {\n    return new BN(runState.block.header.coinbase);\n  },\n  TIMESTAMP: function TIMESTAMP(runState) {\n    return new BN(runState.block.header.timestamp);\n  },\n  NUMBER: function NUMBER(runState) {\n    return new BN(runState.block.header.number);\n  },\n  DIFFICULTY: function DIFFICULTY(runState) {\n    return new BN(runState.block.header.difficulty);\n  },\n  GASLIMIT: function GASLIMIT(runState) {\n    return new BN(runState.block.header.gasLimit);\n  },\n  // 0x50 range - 'storage' and execution\n  POP: function POP() {},\n  MLOAD: function MLOAD(pos, runState) {\n    return new BN(memLoad(runState, pos, new BN(32)));\n  },\n  MSTORE: function MSTORE(offset, word, runState) {\n    word = word.toArrayLike(Buffer, 'be', 32);\n    memStore(runState, offset, word, new BN(0), new BN(32));\n  },\n  MSTORE8: function MSTORE8(offset, byte, runState) {\n    // NOTE: we're using a 'trick' here to get the least significant byte\n    byte = Buffer.from([byte.andln(0xff)]);\n    memStore(runState, offset, byte, new BN(0), new BN(1));\n  },\n  SLOAD: function SLOAD(key, runState, cb) {\n    var stateManager = runState.stateManager;\n    key = key.toArrayLike(Buffer, 'be', 32);\n    stateManager.getContractStorage(runState.address, key, function (err, value) {\n      if (err) return cb(err);\n      value = value.length ? new BN(value) : new BN(0);\n      cb(null, value);\n    });\n  },\n  SSTORE: function SSTORE(key, val, runState, cb) {\n    if (runState.static) {\n      trap(ERROR.STATIC_STATE_CHANGE);\n    }\n\n    var stateManager = runState.stateManager;\n    var address = runState.address;\n    key = key.toArrayLike(Buffer, 'be', 32); // NOTE: this should be the shortest representation\n\n    var value;\n\n    if (val.isZero()) {\n      value = Buffer.from([]);\n    } else {\n      value = val.toArrayLike(Buffer, 'be');\n    }\n\n    stateManager.getContractStorage(runState.address, key, function (err, found) {\n      if (err) return cb(err);\n\n      try {\n        if (value.length === 0 && !found.length) {\n          subGas(runState, new BN(fees.sstoreResetGas.v));\n        } else if (value.length === 0 && found.length) {\n          subGas(runState, new BN(fees.sstoreResetGas.v));\n          runState.gasRefund.iaddn(fees.sstoreRefundGas.v);\n        } else if (value.length !== 0 && !found.length) {\n          subGas(runState, new BN(fees.sstoreSetGas.v));\n        } else if (value.length !== 0 && found.length) {\n          subGas(runState, new BN(fees.sstoreResetGas.v));\n        }\n      } catch (e) {\n        cb(e.error);\n        return;\n      }\n\n      stateManager.putContractStorage(address, key, value, function (err) {\n        if (err) return cb(err);\n        runState.contract = stateManager.cache.get(address);\n        cb(null);\n      });\n    });\n  },\n  JUMP: function JUMP(dest, runState) {\n    if (dest.gtn(runState.code.length)) {\n      trap(ERROR.INVALID_JUMP + ' at ' + describeLocation(runState));\n    }\n\n    dest = dest.toNumber();\n\n    if (!jumpIsValid(runState, dest)) {\n      trap(ERROR.INVALID_JUMP + ' at ' + describeLocation(runState));\n    }\n\n    runState.programCounter = dest;\n  },\n  JUMPI: function JUMPI(dest, cond, runState) {\n    if (!cond.isZero()) {\n      if (dest.gtn(runState.code.length)) {\n        trap(ERROR.INVALID_JUMP + ' at ' + describeLocation(runState));\n      }\n\n      dest = dest.toNumber();\n\n      if (!jumpIsValid(runState, dest)) {\n        trap(ERROR.INVALID_JUMP + ' at ' + describeLocation(runState));\n      }\n\n      runState.programCounter = dest;\n    }\n  },\n  PC: function PC(runState) {\n    return new BN(runState.programCounter - 1);\n  },\n  MSIZE: function MSIZE(runState) {\n    return runState.memoryWordCount.muln(32);\n  },\n  GAS: function GAS(runState) {\n    return new BN(runState.gasLeft);\n  },\n  JUMPDEST: function JUMPDEST(runState) {},\n  PUSH: function PUSH(runState) {\n    var numToPush = runState.opCode - 0x5f;\n    var loaded = new BN(runState.code.slice(runState.programCounter, runState.programCounter + numToPush).toString('hex'), 16);\n    runState.programCounter += numToPush;\n    return loaded;\n  },\n  DUP: function DUP(runState) {\n    // NOTE: this function manipulates the stack directly!\n    var stackPos = runState.opCode - 0x7f;\n\n    if (stackPos > runState.stack.length) {\n      trap(ERROR.STACK_UNDERFLOW);\n    } // create a new copy\n\n\n    return new BN(runState.stack[runState.stack.length - stackPos]);\n  },\n  SWAP: function SWAP(runState) {\n    // NOTE: this function manipulates the stack directly!\n    var stackPos = runState.opCode - 0x8f; // check the stack to make sure we have enough items on teh stack\n\n    var swapIndex = runState.stack.length - stackPos - 1;\n\n    if (swapIndex < 0) {\n      trap(ERROR.STACK_UNDERFLOW);\n    } // preform the swap\n\n\n    var topIndex = runState.stack.length - 1;\n    var tmp = runState.stack[topIndex];\n    runState.stack[topIndex] = runState.stack[swapIndex];\n    runState.stack[swapIndex] = tmp;\n  },\n  LOG: function LOG(memOffset, memLength) {\n    var args = Array.prototype.slice.call(arguments, 0);\n    var runState = args.pop();\n\n    if (runState.static) {\n      trap(ERROR.STATIC_STATE_CHANGE);\n    }\n\n    var topics = args.slice(2);\n    topics = topics.map(function (a) {\n      return a.toArrayLike(Buffer, 'be', 32);\n    });\n    var numOfTopics = runState.opCode - 0xa0;\n    var mem = memLoad(runState, memOffset, memLength);\n    subGas(runState, new BN(fees.logTopicGas.v).imuln(numOfTopics).iadd(memLength.muln(fees.logDataGas.v))); // add address\n\n    var log = [runState.address];\n    log.push(topics); // add data\n\n    log.push(mem);\n    runState.logs.push(log);\n  },\n  // '0xf0' range - closures\n  CREATE: function CREATE(value, offset, length, runState, done) {\n    if (runState.static) {\n      trap(ERROR.STATIC_STATE_CHANGE);\n    }\n\n    var data = memLoad(runState, offset, length); // set up config\n\n    var options = {\n      value: value,\n      data: data\n    };\n    var localOpts = {\n      inOffset: offset,\n      inLength: length,\n      outOffset: new BN(0),\n      outLength: new BN(0)\n    };\n    checkCallMemCost(runState, options, localOpts);\n    checkOutOfGas(runState, options);\n    makeCall(runState, options, localOpts, done);\n  },\n  CALL: function CALL(gasLimit, toAddress, value, inOffset, inLength, outOffset, outLength, runState, done) {\n    var stateManager = runState.stateManager;\n    toAddress = addressToBuffer(toAddress);\n\n    if (runState.static && !value.isZero()) {\n      trap(ERROR.STATIC_STATE_CHANGE);\n    }\n\n    var data = memLoad(runState, inOffset, inLength);\n    var options = {\n      gasLimit: gasLimit,\n      value: value,\n      to: toAddress,\n      data: data,\n      static: runState.static\n    };\n    var localOpts = {\n      inOffset: inOffset,\n      inLength: inLength,\n      outOffset: outOffset,\n      outLength: outLength\n    };\n\n    if (!value.isZero()) {\n      subGas(runState, new BN(fees.callValueTransferGas.v));\n    }\n\n    stateManager.exists(toAddress, function (err, exists) {\n      if (err) {\n        done(err);\n        return;\n      }\n\n      stateManager.accountIsEmpty(toAddress, function (err, empty) {\n        if (err) {\n          done(err);\n          return;\n        }\n\n        if (!exists || empty) {\n          if (!value.isZero()) {\n            try {\n              subGas(runState, new BN(fees.callNewAccountGas.v));\n            } catch (e) {\n              done(e.error);\n              return;\n            }\n          }\n        }\n\n        try {\n          checkCallMemCost(runState, options, localOpts);\n          checkOutOfGas(runState, options);\n        } catch (e) {\n          done(e.error);\n          return;\n        }\n\n        if (!value.isZero()) {\n          runState.gasLeft.iaddn(fees.callStipend.v);\n          options.gasLimit.iaddn(fees.callStipend.v);\n        }\n\n        makeCall(runState, options, localOpts, done);\n      });\n    });\n  },\n  CALLCODE: function CALLCODE(gas, toAddress, value, inOffset, inLength, outOffset, outLength, runState, done) {\n    var stateManager = runState.stateManager;\n    toAddress = addressToBuffer(toAddress);\n    var data = memLoad(runState, inOffset, inLength);\n    var options = {\n      gasLimit: gas,\n      value: value,\n      data: data,\n      to: runState.address,\n      static: runState.static\n    };\n    var localOpts = {\n      inOffset: inOffset,\n      inLength: inLength,\n      outOffset: outOffset,\n      outLength: outLength\n    };\n\n    if (!value.isZero()) {\n      subGas(runState, new BN(fees.callValueTransferGas.v));\n    }\n\n    checkCallMemCost(runState, options, localOpts);\n    checkOutOfGas(runState, options);\n\n    if (!value.isZero()) {\n      runState.gasLeft.iaddn(fees.callStipend.v);\n      options.gasLimit.iaddn(fees.callStipend.v);\n    } // load the code\n\n\n    stateManager.getAccount(toAddress, function (err, account) {\n      if (err) return done(err);\n\n      if (runState._precompiled[toAddress.toString('hex')]) {\n        options.compiled = true;\n        options.code = runState._precompiled[toAddress.toString('hex')];\n        makeCall(runState, options, localOpts, done);\n      } else {\n        stateManager.getContractCode(toAddress, function (err, code, compiled) {\n          if (err) return done(err);\n          options.compiled = compiled || false;\n          options.code = code;\n          makeCall(runState, options, localOpts, done);\n        });\n      }\n    });\n  },\n  DELEGATECALL: function DELEGATECALL(gas, toAddress, inOffset, inLength, outOffset, outLength, runState, done) {\n    var stateManager = runState.stateManager;\n    var value = runState.callValue;\n    toAddress = addressToBuffer(toAddress);\n    var data = memLoad(runState, inOffset, inLength);\n    var options = {\n      gasLimit: gas,\n      value: value,\n      data: data,\n      to: runState.address,\n      caller: runState.caller,\n      delegatecall: true,\n      static: runState.static\n    };\n    var localOpts = {\n      inOffset: inOffset,\n      inLength: inLength,\n      outOffset: outOffset,\n      outLength: outLength\n    };\n    checkCallMemCost(runState, options, localOpts);\n    checkOutOfGas(runState, options); // load the code\n\n    stateManager.getAccount(toAddress, function (err, account) {\n      if (err) return done(err);\n\n      if (runState._precompiled[toAddress.toString('hex')]) {\n        options.compiled = true;\n        options.code = runState._precompiled[toAddress.toString('hex')];\n        makeCall(runState, options, localOpts, done);\n      } else {\n        stateManager.getContractCode(toAddress, function (err, code, compiled) {\n          if (err) return done(err);\n          options.compiled = compiled || false;\n          options.code = code;\n          makeCall(runState, options, localOpts, done);\n        });\n      }\n    });\n  },\n  STATICCALL: function STATICCALL(gasLimit, toAddress, inOffset, inLength, outOffset, outLength, runState, done) {\n    var stateManager = runState.stateManager;\n    var value = new BN(0);\n    toAddress = addressToBuffer(toAddress);\n    var data = memLoad(runState, inOffset, inLength);\n    var options = {\n      gasLimit: gasLimit,\n      value: value,\n      to: toAddress,\n      data: data,\n      static: true\n    };\n    var localOpts = {\n      inOffset: inOffset,\n      inLength: inLength,\n      outOffset: outOffset,\n      outLength: outLength\n    };\n    stateManager.exists(toAddress, function (err, exists) {\n      if (err) {\n        done(err);\n        return;\n      }\n\n      stateManager.accountIsEmpty(toAddress, function (err, empty) {\n        if (err) {\n          done(err);\n          return;\n        }\n\n        try {\n          checkCallMemCost(runState, options, localOpts);\n          checkOutOfGas(runState, options);\n        } catch (e) {\n          done(e.error);\n          return;\n        }\n\n        makeCall(runState, options, localOpts, done);\n      });\n    });\n  },\n  RETURN: function RETURN(offset, length, runState) {\n    runState.returnValue = memLoad(runState, offset, length);\n  },\n  REVERT: function REVERT(offset, length, runState) {\n    runState.stopped = true;\n    runState.returnValue = memLoad(runState, offset, length);\n    trap(ERROR.REVERT);\n  },\n  // '0x70', range - other\n  SELFDESTRUCT: function SELFDESTRUCT(selfdestructToAddress, runState, cb) {\n    if (runState.static) {\n      trap(ERROR.STATIC_STATE_CHANGE);\n    }\n\n    var stateManager = runState.stateManager;\n    var contract = runState.contract;\n    var contractAddress = runState.address;\n    selfdestructToAddress = addressToBuffer(selfdestructToAddress);\n    stateManager.getAccount(selfdestructToAddress, function (err, toAccount) {\n      // update balances\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      stateManager.accountIsEmpty(selfdestructToAddress, function (error, empty) {\n        if (error) {\n          cb(error);\n          return;\n        }\n\n        if (new BN(contract.balance).gtn(0)) {\n          if (!toAccount.exists || empty) {\n            try {\n              subGas(runState, new BN(fees.callNewAccountGas.v));\n            } catch (e) {\n              cb(e.error);\n              return;\n            }\n          }\n        } // only add to refund if this is the first selfdestruct for the address\n\n\n        if (!runState.selfdestruct[contractAddress.toString('hex')]) {\n          runState.gasRefund = runState.gasRefund.addn(fees.suicideRefundGas.v);\n        }\n\n        runState.selfdestruct[contractAddress.toString('hex')] = selfdestructToAddress;\n        runState.stopped = true;\n        var newBalance = new BN(contract.balance).add(new BN(toAccount.balance));\n        async.series([stateManager.putAccountBalance.bind(stateManager, selfdestructToAddress, newBalance), stateManager.putAccountBalance.bind(stateManager, contractAddress, new BN(0))], function (err) {\n          // The reason for this is to avoid sending an array of results\n          cb(err);\n        });\n      });\n    });\n  }\n};\n\nfunction describeLocation(runState) {\n  var hash = utils.sha3(runState.code).toString('hex');\n  var address = runState.address.toString('hex');\n  var pc = runState.programCounter - 1;\n  return hash + '/' + address + ':' + pc;\n}\n\nfunction subGas(runState, amount) {\n  runState.gasLeft.isub(amount);\n\n  if (runState.gasLeft.ltn(0)) {\n    runState.gasLeft = new BN(0);\n    trap(ERROR.OUT_OF_GAS);\n  }\n}\n\nfunction trap(err) {\n  throw new VmError(err);\n}\n/**\n * Subtracts the amount needed for memory usage from `runState.gasLeft`\n * @method subMemUsage\n * @param {BN} offset\n * @param {BN} length\n * @return {String}\n */\n\n\nfunction subMemUsage(runState, offset, length) {\n  // YP (225): access with zero length will not extend the memory\n  if (length.isZero()) return;\n  var newMemoryWordCount = offset.add(length).divCeil(new BN(32));\n  if (newMemoryWordCount.lte(runState.memoryWordCount)) return;\n  var words = newMemoryWordCount;\n  var fee = new BN(fees.memoryGas.v);\n  var quadCoeff = new BN(fees.quadCoeffDiv.v); // words * 3 + words ^2 / 512\n\n  var cost = words.mul(fee).add(words.mul(words).div(quadCoeff));\n\n  if (cost.gt(runState.highestMemCost)) {\n    subGas(runState, cost.sub(runState.highestMemCost));\n    runState.highestMemCost = cost;\n  }\n\n  runState.memoryWordCount = newMemoryWordCount;\n}\n/**\n * Loads bytes from memory and returns them as a buffer. If an error occurs\n * a string is instead returned. The function also subtracts the amount of\n * gas need for memory expansion.\n * @method memLoad\n * @param {BN} offset where to start reading from\n * @param {BN} length how far to read\n * @return {Buffer|String}\n */\n\n\nfunction memLoad(runState, offset, length) {\n  // check to see if we have enougth gas for the mem read\n  subMemUsage(runState, offset, length); // shortcut\n\n  if (length.isZero()) {\n    return Buffer.alloc(0);\n  } // NOTE: in theory this could overflow, but unlikely due to OOG above\n\n\n  offset = offset.toNumber();\n  length = length.toNumber();\n  var loaded = runState.memory.slice(offset, offset + length); // fill the remaining lenth with zeros\n\n  for (var i = loaded.length; i < length; i++) {\n    loaded[i] = 0;\n  }\n\n  return Buffer.from(loaded);\n}\n/**\n * Stores bytes to memory. If an error occurs a string is instead returned.\n * The function also subtracts the amount of gas need for memory expansion.\n * @method memStore\n * @param {BN} offset where to start reading from\n * @param {Buffer} val\n * @param {BN} valOffset\n * @param {BN} length how far to read\n * @param {Boolean} skipSubMem\n * @return {Buffer|String}\n */\n\n\nfunction memStore(runState, offset, val, valOffset, length, skipSubMem) {\n  if (skipSubMem !== false) {\n    subMemUsage(runState, offset, length);\n  } // shortcut\n\n\n  if (length.isZero()) {\n    return;\n  } // NOTE: in theory this could overflow, but unlikely due to OOG above\n\n\n  offset = offset.toNumber();\n  length = length.toNumber();\n  var safeLen = 0;\n\n  if (valOffset.addn(length).gtn(val.length)) {\n    if (valOffset.gten(val.length)) {\n      safeLen = 0;\n    } else {\n      valOffset = valOffset.toNumber();\n      safeLen = val.length - valOffset;\n    }\n  } else {\n    valOffset = valOffset.toNumber();\n    safeLen = val.length;\n  }\n\n  var i = 0;\n\n  if (safeLen > 0) {\n    safeLen = safeLen > length ? length : safeLen;\n\n    for (; i < safeLen; i++) {\n      runState.memory[offset + i] = val[valOffset + i];\n    }\n  }\n  /*\n    pad the remaining length with zeros IF AND ONLY IF a value was stored\n    (even if value offset > value length, strange spec...)\n  */\n\n\n  if (val.length > 0 && i < length) {\n    for (; i < length; i++) {\n      runState.memory[offset + i] = 0;\n    }\n  }\n} // checks if a jump is valid given a destination\n\n\nfunction jumpIsValid(runState, dest) {\n  return runState.validJumps.indexOf(dest) !== -1;\n} // checks to see if we have enough gas left for the memory reads and writes\n// required by the CALLs\n\n\nfunction checkCallMemCost(runState, callOptions, localOpts) {\n  // calculates the gas need for saving the output in memory\n  subMemUsage(runState, localOpts.outOffset, localOpts.outLength);\n\n  if (!callOptions.gasLimit) {\n    callOptions.gasLimit = new BN(runState.gasLeft);\n  }\n}\n\nfunction checkOutOfGas(runState, callOptions) {\n  var gasAllowed = runState.gasLeft.sub(runState.gasLeft.divn(64));\n\n  if (callOptions.gasLimit.gt(gasAllowed)) {\n    callOptions.gasLimit = gasAllowed;\n  }\n} // sets up and calls runCall\n\n\nfunction makeCall(runState, callOptions, localOpts, cb) {\n  callOptions.caller = callOptions.caller || runState.address;\n  callOptions.origin = runState.origin;\n  callOptions.gasPrice = runState.gasPrice;\n  callOptions.block = runState.block;\n  callOptions.populateCache = false;\n  callOptions.static = callOptions.static || false;\n  callOptions.selfdestruct = runState.selfdestruct; // increment the runState.depth\n\n  callOptions.depth = runState.depth + 1; // empty the return data buffer\n\n  runState.lastReturned = Buffer.alloc(0); // check if account has enough ether\n  // Note: in the case of delegatecall, the value is persisted and doesn't need to be deducted again\n\n  if (runState.depth >= fees.stackLimit.v || callOptions.delegatecall !== true && new BN(runState.contract.balance).lt(callOptions.value)) {\n    cb(null, new BN(0));\n  } else {\n    // if creating a new contract then increament the nonce\n    if (!callOptions.to) {\n      runState.contract.nonce = new BN(runState.contract.nonce).addn(1);\n    }\n\n    runState.stateManager.cache.put(runState.address, runState.contract);\n\n    runState._vm.runCall(callOptions, parseCallResults);\n  }\n\n  function parseCallResults(err, results) {\n    if (err) return cb(err); // concat the runState.logs\n\n    if (results.vm.logs) {\n      runState.logs = runState.logs.concat(results.vm.logs);\n    } // add gasRefund\n\n\n    if (results.vm.gasRefund) {\n      runState.gasRefund = runState.gasRefund.add(results.vm.gasRefund);\n    } // this should always be safe\n\n\n    runState.gasLeft.isub(results.gasUsed); // save results to memory\n\n    if (results.vm.return && (!results.vm.exceptionError || results.vm.exceptionError.error === ERROR.REVERT)) {\n      memStore(runState, localOpts.outOffset, results.vm.return, new BN(0), localOpts.outLength, false);\n\n      if (results.vm.exceptionError && results.vm.exceptionError.error === ERROR.REVERT && runState.opName === 'CREATE') {\n        runState.lastReturned = results.vm.return;\n      }\n\n      switch (runState.opName) {\n        case 'CALL':\n        case 'CALLCODE':\n        case 'DELEGATECALL':\n        case 'STATICCALL':\n          runState.lastReturned = results.vm.return;\n          break;\n      }\n    }\n\n    if (!results.vm.exceptionError) {\n      // update stateRoot on current contract\n      runState.stateManager.getAccount(runState.address, function (err, account) {\n        if (err) return cb(err);\n        runState.contract = account; // push the created address to the stack\n\n        if (results.createdAddress) {\n          cb(null, new BN(results.createdAddress));\n        } else {\n          cb(null, new BN(results.vm.exception));\n        }\n      });\n    } else {\n      // creation failed so don't increament the nonce\n      if (results.vm.createdAddress) {\n        runState.contract.nonce = new BN(runState.contract.nonce).subn(1);\n      }\n\n      cb(null, new BN(results.vm.exception));\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}