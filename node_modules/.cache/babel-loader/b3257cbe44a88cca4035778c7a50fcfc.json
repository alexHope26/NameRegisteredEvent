{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst validate_1 = require(\"../util/validate\");\n/* tslint:disable */\n\n\nexports.validationDef = {\n  IN3NodeWeight: {\n    description: 'a local weight of a n3-node. (This is used internally to weight the requests)',\n    type: 'object',\n    properties: {\n      weight: {\n        description: 'factor the weight this noe (default 1.0)',\n        type: 'number',\n        example: 0.5\n      },\n      responseCount: {\n        description: 'number of uses.',\n        type: 'integer',\n        example: 147\n      },\n      avgResponseTime: {\n        description: 'average time of a response in ms',\n        type: 'number',\n        example: 240\n      },\n      pricePerRequest: {\n        description: 'last price',\n        type: 'integer'\n      },\n      lastRequest: {\n        description: 'timestamp of the last request in ms',\n        type: 'integer',\n        example: 1529074632623\n      },\n      blacklistedUntil: {\n        description: 'blacklisted because of failed requests until the timestamp',\n        type: 'integer',\n        example: 1529074639623\n      }\n    }\n  },\n  IN3NodeConfig: {\n    description: 'a configuration of a in3-server.',\n    type: 'object',\n    required: ['address', 'url', 'deposit', 'chainIds'],\n    properties: {\n      index: {\n        description: 'the index within the contract',\n        type: 'integer',\n        example: 13\n      },\n      address: {\n        description: 'the address of the node, which is the public address it iis signing with.',\n        type: 'string',\n        format: 'address',\n        example: '0x6C1a01C2aB554930A937B0a2E8105fB47946c679'\n      },\n      timeout: {\n        description: 'the time (in seconds) until an owner is able to receive his deposit back after he unregisters himself',\n        type: 'integer',\n        example: 3600\n      },\n      url: {\n        description: 'the endpoint to post to',\n        type: 'string',\n        example: 'https://in3.slock.it'\n      },\n      chainIds: {\n        description: 'the list of supported chains',\n        example: ['0x1'],\n        type: 'array',\n        items: {\n          type: 'string',\n          format: 'hex'\n        }\n      },\n      deposit: {\n        description: 'the deposit of the node in wei',\n        type: 'integer',\n        example: 12350000\n      },\n      capacity: {\n        description: 'the capacity of the node.',\n        type: 'integer',\n        example: 100\n      },\n      props: {\n        description: 'the properties of the node.',\n        type: 'integer',\n        example: 3\n      }\n    }\n  },\n  IN3RPCRequestConfig: {\n    description: 'additional config for a IN3 RPC-Request',\n    required: ['chainId'],\n    properties: {\n      chainId: {\n        description: 'the requested chainId',\n        type: 'string',\n        example: '0x1',\n        format: 'hex'\n      },\n      includeCode: {\n        description: 'if true, the request should include the codes of all accounts. otherwise only the the codeHash is returned. In this case the client may ask by calling eth_getCode() afterwards',\n        type: 'boolean',\n        example: true\n      },\n      verifiedHashes: {\n        description: 'if the client sends a array of blockhashes the server will not deliver any signatures or blockheaders for these blocks, but only return a string with a number.',\n        type: 'array',\n        items: {\n          type: 'string',\n          format: 'bytes32'\n        }\n      },\n      latestBlock: {\n        description: 'if specified, the blocknumber *latest* will be replaced by blockNumber- specified value',\n        type: 'integer',\n        example: 6\n      },\n      useRef: {\n        description: 'if true binary-data (starting with a 0x) will be refered if occuring again.',\n        type: 'boolean'\n      },\n      useBinary: {\n        description: 'if true binary-data will be used.',\n        type: 'boolean'\n      },\n      useFullProof: {\n        description: 'if true all data in the response will be proven, which leads to a higher payload.',\n        type: 'boolean'\n      },\n      finality: {\n        description: 'if given the server will deliver the blockheaders of the following blocks until at least the number in percent of the validators is reached.',\n        type: 'number'\n      },\n      verification: {\n        description: 'defines the kind of proof the client is asking for',\n        type: 'string',\n        enum: ['never', 'proof', 'proofWithSignature'],\n        example: 'proof'\n      },\n      clientSignature: {\n        description: 'the signature of the client'\n      },\n      signatures: {\n        description: 'a list of addresses requested to sign the blockhash',\n        type: 'array',\n        example: ['0x6C1a01C2aB554930A937B0a2E8105fB47946c679'],\n        items: {\n          type: 'string',\n          format: 'address'\n        }\n      }\n    }\n  },\n  Signature: {\n    description: 'Verified ECDSA Signature. Signatures are a pair (r, s). Where r is computed as the X coordinate of a point R, modulo the curve order n.',\n    type: 'object',\n    required: ['r', 's', 'v', 'msgHash', 'block', 'blockHash'],\n    properties: {\n      address: {\n        type: 'string',\n        description: 'the address of the signing node',\n        format: 'address',\n        example: '0x6C1a01C2aB554930A937B0a2E8105fB47946c679'\n      },\n      block: {\n        type: 'number',\n        description: 'the blocknumber',\n        example: 3123874\n      },\n      blockHash: {\n        type: 'string',\n        description: 'the hash of the block',\n        example: '0x6C1a01C2aB554930A937B0a212346037E8105fB47946c679',\n        format: 'bytes32'\n      },\n      msgHash: {\n        type: 'string',\n        description: 'hash of the message',\n        format: 'bytes32',\n        example: '0x9C1a01C2aB554930A937B0a212346037E8105fB47946AB5D'\n      },\n      r: {\n        type: 'string',\n        description: 'Positive non-zero Integer signature.r',\n        format: 'hex',\n        example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1f'\n      },\n      s: {\n        type: 'string',\n        description: 'Positive non-zero Integer signature.s',\n        format: 'hex',\n        example: '0x6d17b34aeaf95fee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda'\n      },\n      v: {\n        type: 'integer',\n        description: 'Calculated curve point, or identity element O.',\n        format: 'hex',\n        example: 28\n      }\n    }\n  },\n  IN3ResponseConfig: {\n    type: 'object',\n    description: 'additional data returned from a IN3 Server',\n    properties: {\n      proof: {\n        description: 'the Proof-data as part of the in3-section',\n        type: 'object',\n        required: ['type'],\n        properties: {\n          type: {\n            description: 'the type of the proof',\n            type: 'string',\n            enum: ['transactionProof', 'receiptProof', 'blockProof', 'accountProof', 'callProof', 'logProof'],\n            example: 'accountProof'\n          },\n          block: {\n            type: 'string',\n            description: 'the serialized blockheader as hex, required in most proofs',\n            example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b'\n          },\n          finalityBlocks: {\n            type: 'array',\n            description: 'the serialized blockheader as hex, required in case of finality asked',\n            example: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b']\n          },\n          transactions: {\n            type: 'array',\n            description: 'the list of transactions of the block',\n            example: []\n          },\n          uncles: {\n            type: 'array',\n            description: 'the list of uncle-headers of the block',\n            example: []\n          },\n          merkleProof: {\n            type: 'array',\n            description: 'the serialized merle-noodes beginning with the root-node',\n            exmaple: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b', '0x01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1', '0xcf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbd'],\n            items: {\n              type: 'string',\n              pattern: '^0x[0-9a-fA-F]+$'\n            }\n          },\n          merkleProofPrev: {\n            type: 'array',\n            description: 'the serialized merkle-noodes beginning with the root-node of the previous entry (only for full proof of receipts)',\n            exmaple: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b', '0x01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1', '0xcf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbd'],\n            items: {\n              type: 'string',\n              pattern: '^0x[0-9a-fA-F]+$'\n            }\n          },\n          txProof: {\n            type: 'array',\n            description: 'the serialized merkle-nodes beginning with the root-node in order to prrof the transactionIndex',\n            items: {\n              type: 'string',\n              pattern: '^0x[0-9a-fA-F]+$'\n            }\n          },\n          logProof: {\n            description: 'a Object holding proofs for event logs. The key is the blockNumber as hex',\n            type: 'object',\n            additionalProperties: {\n              type: 'object',\n              required: ['block', 'receipts'],\n              properties: {\n                number: {\n                  description: 'the blockNumber',\n                  type: 'number'\n                },\n                block: {\n                  description: 'the serialized blockheader',\n                  type: 'string',\n                  example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b'\n                },\n                allReceipts: {\n                  description: 'temp. list of all receipts, which is not included in the final proof',\n                  type: 'array'\n                },\n                receipts: {\n                  description: 'the map of existing receipts with the txHash as key',\n                  type: 'object',\n                  additionalProperties: {\n                    type: 'object',\n                    required: ['txIndex', 'proof'],\n                    properties: {\n                      txHash: {\n                        type: 'string',\n                        description: 'the transactionHash'\n                      },\n                      txIndex: {\n                        type: 'integer',\n                        description: 'the transactionIndex within the block'\n                      },\n                      txProof: {\n                        type: 'array',\n                        description: 'the merkleProof',\n                        items: {\n                          type: 'string',\n                          pattern: '^0x[0-9a-fA-F]+$'\n                        }\n                      },\n                      proof: {\n                        type: 'array',\n                        description: 'the merkleProof',\n                        items: {\n                          type: 'string',\n                          pattern: '^0x[0-9a-fA-F]+$'\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n          accounts: {\n            type: 'object',\n            description: 'a map of addresses and their AccountProof',\n            additionalProperties: {\n              type: 'object',\n              description: 'the Proof-for a single Account',\n              required: ['accountProof', 'address', 'balance', 'codeHash', 'nonce', 'storageHash', 'storageProof'],\n              properties: {\n                accountProof: {\n                  type: 'array',\n                  description: 'the serialized merle-noodes beginning with the root-node',\n                  items: {\n                    type: 'string',\n                    pattern: '^0x[0-9a-fA-F]+$'\n                  }\n                },\n                address: {\n                  type: 'string',\n                  description: 'the address of this account',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                balance: {\n                  type: 'string',\n                  description: 'the balance of this account as hex',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                codeHash: {\n                  type: 'string',\n                  description: 'the codeHash of this account as hex',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                code: {\n                  type: 'string',\n                  description: 'the code of this account as hex ( if required)',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                nonce: {\n                  type: 'string',\n                  description: 'the nonce of this account as hex',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                storageHash: {\n                  type: 'string',\n                  description: 'the storageHash of this account as hex',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                storageProof: {\n                  type: 'array',\n                  description: 'proof for requested storage-data',\n                  items: {\n                    type: 'object',\n                    required: ['key', 'proof', 'value'],\n                    properties: {\n                      key: {\n                        type: 'string',\n                        description: 'the storage key',\n                        pattern: '^0x[0-9a-fA-F]+$'\n                      },\n                      proof: {\n                        type: 'array',\n                        description: 'the serialized merkle-noodes beginning with the root-node ( storageHash )',\n                        items: {\n                          type: 'string',\n                          pattern: '^0x[0-9a-fA-F]+$'\n                        }\n                      },\n                      value: {\n                        type: 'string',\n                        description: 'the stored value',\n                        pattern: '^0x[0-9a-fA-F]+$'\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n          txIndex: {\n            type: 'integer',\n            description: 'the transactionIndex within the block',\n            example: 4\n          },\n          signatures: {\n            type: 'array',\n            description: 'requested signatures',\n            items: {\n              description: 'Verified ECDSA Signature. Signatures are a pair (r, s). Where r is computed as the X coordinate of a point R, modulo the curve order n.',\n              type: 'object',\n              required: ['r', 's', 'v', 'msgHash', 'block', 'blockHash'],\n              properties: {\n                address: {\n                  type: 'string',\n                  description: 'the address of the signing node',\n                  format: 'address',\n                  example: '0x6C1a01C2aB554930A937B0a2E8105fB47946c679'\n                },\n                block: {\n                  type: 'number',\n                  description: 'the blocknumber',\n                  example: 3123874\n                },\n                blockHash: {\n                  type: 'string',\n                  description: 'the hash of the block',\n                  example: '0x6C1a01C2aB554930A937B0a212346037E8105fB47946c679',\n                  format: 'bytes32'\n                },\n                msgHash: {\n                  type: 'string',\n                  description: 'hash of the message',\n                  format: 'bytes32',\n                  example: '0x9C1a01C2aB554930A937B0a212346037E8105fB47946AB5D'\n                },\n                r: {\n                  type: 'string',\n                  description: 'Positive non-zero Integer signature.r',\n                  format: 'hex',\n                  example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1f'\n                },\n                s: {\n                  type: 'string',\n                  description: 'Positive non-zero Integer signature.s',\n                  format: 'hex',\n                  example: '0x6d17b34aeaf95fee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda'\n                },\n                v: {\n                  type: 'integer',\n                  description: 'Calculated curve point, or identity element O.',\n                  format: 'hex',\n                  example: 28\n                }\n              }\n            }\n          }\n        }\n      },\n      lastNodeList: {\n        description: 'the blocknumber for the last block updating the nodelist. If the client has a smaller blocknumber he should update the nodeList.',\n        type: 'number',\n        example: 326478\n      },\n      lastValidatorChange: {\n        description: 'the blocknumber of gthe last change of the validatorList',\n        type: 'number'\n      },\n      currentBlock: {\n        description: 'the current blocknumber.',\n        type: 'number',\n        example: 320126478\n      }\n    }\n  },\n  ChainSpec: {\n    type: 'object',\n    description: 'describes the chainspecific consensus params',\n    properties: {\n      block: {\n        description: 'the blocknumnber when this configuration should apply',\n        type: 'number'\n      },\n      engine: {\n        description: 'the engine type (like Ethhash, authorityRound, ... )',\n        type: 'string',\n        enum: ['ethHash', 'authorityRound', 'clique']\n      },\n      list: {\n        description: 'The list of validators at the particular block',\n        type: 'array',\n        items: {\n          type: 'string',\n          format: 'address'\n        }\n      },\n      contract: {\n        description: 'The validator contract at the block',\n        type: 'string'\n      },\n      requiresFinality: {\n        description: 'indicates whether the transition requires a finality check',\n        type: 'boolean',\n        example: true\n      },\n      bypassFinality: {\n        description: 'Bypass finality check for transition to contract based Aura Engines',\n        type: 'number',\n        example: 'bypassFinality = 10960502 -> will skip the finality check and add the list at block 10960502'\n      }\n    }\n  },\n  IN3Config: {\n    description: 'the iguration of the IN3-Client. This can be paritally overriden for every request.',\n    type: 'object',\n    required: ['minDeposit', 'requestCount', 'chainId'],\n    properties: {\n      cacheTimeout: {\n        type: 'number',\n        description: 'number of seconds requests can be cached.'\n      },\n      nodeLimit: {\n        description: 'the limit of nodes to store in the client.',\n        type: 'number',\n        example: 150\n      },\n      keepIn3: {\n        description: 'if true, the in3-section of thr response will be kept. Otherwise it will be removed after validating the data. This is useful for debugging or if the proof should be used afterwards.',\n        type: 'boolean',\n        example: false\n      },\n      format: {\n        description: 'the format for sending the data to the client. Default is json, but using cbor means using only 30-40% of the payload since it is using binary encoding',\n        type: 'string',\n        enum: ['json', 'jsonRef', 'cbor'],\n        example: 'json'\n      },\n      key: {\n        description: 'the client key to sign requests',\n        example: '0x387a8233c96e1fc0ad5e284353276177af2186e7afa85296f106336e376669f7'\n      },\n      autoConfig: {\n        description: 'if true the config will be adjusted depending on the request',\n        type: 'boolean',\n        example: false\n      },\n      retryWithoutProof: {\n        description: 'if true the the request may be handled without proof in case of an error. (use with care!)',\n        type: 'boolean',\n        example: false\n      },\n      maxAttempts: {\n        description: 'max number of attempts in case a response is rejected',\n        type: 'number',\n        example: 10\n      },\n      includeCode: {\n        description: 'if true, the request should include the codes of all accounts. otherwise only the the codeHash is returned. In this case the client may ask by calling eth_getCode() afterwards',\n        type: 'boolean',\n        example: true\n      },\n      maxCodeCache: {\n        description: 'number of max bytes used to cache the code in memory',\n        type: 'integer',\n        example: 100000\n      },\n      maxBlockCache: {\n        description: 'number of number of blocks cached  in memory',\n        type: 'integer',\n        example: 100\n      },\n      verifiedHashes: {\n        description: 'if the client sends a array of blockhashes the server will not deliver any signatures or blockheaders for these blocks, but only return a string with a number. This is automaticly updated by the cache, but can be overriden per request.',\n        type: 'array',\n        items: {\n          type: 'string',\n          format: 'bytes32'\n        }\n      },\n      proof: {\n        description: 'if true the nodes should send a proof of the response',\n        type: 'string',\n        enum: ['none', 'standard', 'full'],\n        example: true\n      },\n      signatureCount: {\n        description: 'number of signatures requested',\n        type: 'number',\n        example: 2\n      },\n      minDeposit: {\n        type: 'number',\n        description: 'min stake of the server. Only nodes owning at least this amount will be chosen.',\n        example: 0\n      },\n      replaceLatestBlock: {\n        description: 'if specified, the blocknumber *latest* will be replaced by blockNumber- specified value',\n        type: 'integer',\n        example: 6\n      },\n      requestCount: {\n        type: 'number',\n        min: 1,\n        default: 1,\n        description: 'the number of request send when getting a first answer',\n        example: 3\n      },\n      finality: {\n        type: 'number',\n        min: 0,\n        max: 100,\n        default: 0,\n        description: 'the number in percent needed in order reach finality (% of signature of the validators)',\n        example: 50\n      },\n      timeout: {\n        type: 'number',\n        min: 1,\n        default: 2000,\n        description: 'specifies the number of milliseconds before the request times out. increasing may be helpful if the device uses a slow connection.',\n        example: 3000\n      },\n      chainId: {\n        type: 'string',\n        pattern: '^0x[0-9a-fA-F]+$',\n        description: 'servers to filter for the given chain. The chain-id based on EIP-155.',\n        example: '0x1'\n      },\n      chainRegistry: {\n        type: 'string',\n        pattern: '^0x[0-9a-fA-F]+$',\n        description: 'main chain-registry contract',\n        example: '0xe36179e2286ef405e929C90ad3E70E649B22a945'\n      },\n      mainChain: {\n        type: 'string',\n        pattern: '^0x[0-9a-fA-F]+$',\n        description: 'main chain-id, where the chain registry is running.',\n        example: '0x1'\n      },\n      autoUpdateList: {\n        type: 'boolean',\n        description: 'if true the nodelist will be automaticly updated if the lastBlock is newer',\n        example: true\n      },\n      cacheStorage: {\n        description: 'a cache handler offering 2 functions ( setItem(string,string), getItem(string) )'\n      },\n      loggerUrl: {\n        type: 'string',\n        description: 'a url of RES-Endpoint, the client will log all errors to. The client will post to this endpoint JSON like { id?, level, message, meta? }'\n      },\n      rpc: {\n        type: 'string',\n        description: 'url of one or more rpc-endpoints to use. (list can be comma seperated)'\n      },\n      servers: {\n        type: 'object',\n        description: 'the nodelist per chain',\n        additionalProperties: {\n          type: 'object',\n          properties: {\n            verifier: {\n              type: 'string',\n              description: 'name of the module responsible for handling the verification'\n            },\n            name: {\n              type: 'string',\n              description: 'a alias for the chain'\n            },\n            chainSpec: {\n              type: 'array',\n              items: {\n                type: 'object',\n                description: 'describes the chainspecific consensus params',\n                properties: {\n                  block: {\n                    description: 'the blocknumnber when this configuration should apply',\n                    type: 'number'\n                  },\n                  engine: {\n                    description: 'the engine type (like Ethhash, authorityRound, ... )',\n                    type: 'string',\n                    enum: ['ethHash', 'authorityRound', 'clique']\n                  },\n                  list: {\n                    description: 'The list of validators at the particular block',\n                    type: 'array',\n                    items: {\n                      type: 'string',\n                      format: 'address'\n                    }\n                  },\n                  contract: {\n                    description: 'The validator contract at the block',\n                    type: 'string'\n                  },\n                  requiresFinality: {\n                    description: 'indicates whether the transition requires a finality check',\n                    type: 'boolean',\n                    example: true\n                  },\n                  bypassFinality: {\n                    description: 'Bypass finality check for transition to contract based Aura Engines',\n                    type: 'number',\n                    example: 'bypassFinality = 10960502 -> will skip the finality check and add the list at block 10960502'\n                  }\n                }\n              },\n              description: 'chain definitions'\n            },\n            initAddresses: {\n              description: 'a list of addresses which should always be part of the nodelist when getting an update',\n              type: 'array',\n              example: ['0xe36179e2286ef405e929C90ad3E70E649B22a945', '0x6d17b34aeaf95fee98c0437b4ac839d8a2ece1b1'],\n              items: {\n                type: 'string'\n              }\n            },\n            lastBlock: {\n              type: 'integer',\n              description: 'the blockNumber of the last event in the registry',\n              example: 23498798\n            },\n            contract: {\n              type: 'string',\n              description: 'the address of the registry contract',\n              example: '0xe36179e2286ef405e929C90ad3E70E649B22a945'\n            },\n            needsUpdate: {\n              type: 'boolean',\n              description: 'if true the nodelist should be updated.'\n            },\n            contractChain: {\n              type: 'string',\n              description: 'the chainid for the contract',\n              example: '0x8'\n            },\n            nodeList: {\n              description: 'the list of nodes',\n              type: 'array',\n              items: {\n                description: 'a configuration of a in3-server.',\n                type: 'object',\n                required: ['address', 'url', 'deposit', 'chainIds'],\n                properties: {\n                  index: {\n                    description: 'the index within the contract',\n                    type: 'integer',\n                    example: 13\n                  },\n                  address: {\n                    description: 'the address of the node, which is the public address it iis signing with.',\n                    type: 'string',\n                    format: 'address',\n                    example: '0x6C1a01C2aB554930A937B0a2E8105fB47946c679'\n                  },\n                  timeout: {\n                    description: 'the time (in seconds) until an owner is able to receive his deposit back after he unregisters himself',\n                    type: 'integer',\n                    example: 3600\n                  },\n                  url: {\n                    description: 'the endpoint to post to',\n                    type: 'string',\n                    example: 'https://in3.slock.it'\n                  },\n                  chainIds: {\n                    description: 'the list of supported chains',\n                    example: ['0x1'],\n                    type: 'array',\n                    items: {\n                      type: 'string',\n                      format: 'hex'\n                    }\n                  },\n                  deposit: {\n                    description: 'the deposit of the node in wei',\n                    type: 'integer',\n                    example: 12350000\n                  },\n                  capacity: {\n                    description: 'the capacity of the node.',\n                    type: 'integer',\n                    example: 100\n                  },\n                  props: {\n                    description: 'the properties of the node.',\n                    type: 'integer',\n                    example: 3\n                  }\n                }\n              }\n            },\n            nodeAuthorities: {\n              description: 'the list of authority nodes for handling conflicts',\n              type: 'array',\n              example: ['0xe36179e2286ef405e929C90ad3E70E649B22a945', '0x6d17b34aeaf95fee98c0437b4ac839d8a2ece1b1'],\n              items: {\n                type: 'string'\n              }\n            },\n            weights: {\n              description: 'the weights of nodes depending on former performance which is used internally',\n              type: 'object',\n              additionalProperties: {\n                description: 'a local weight of a n3-node. (This is used internally to weight the requests)',\n                type: 'object',\n                properties: {\n                  weight: {\n                    description: 'factor the weight this noe (default 1.0)',\n                    type: 'number',\n                    example: 0.5\n                  },\n                  responseCount: {\n                    description: 'number of uses.',\n                    type: 'integer',\n                    example: 147\n                  },\n                  avgResponseTime: {\n                    description: 'average time of a response in ms',\n                    type: 'number',\n                    example: 240\n                  },\n                  pricePerRequest: {\n                    description: 'last price',\n                    type: 'integer'\n                  },\n                  lastRequest: {\n                    description: 'timestamp of the last request in ms',\n                    type: 'integer',\n                    example: 1529074632623\n                  },\n                  blacklistedUntil: {\n                    description: 'blacklisted because of failed requests until the timestamp',\n                    type: 'integer',\n                    example: 1529074639623\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  RPCRequest: {\n    type: 'object',\n    description: 'a JSONRPC-Request with N3-Extension',\n    required: ['jsonrpc', 'method'],\n    properties: {\n      jsonrpc: {\n        description: 'the version',\n        type: 'string',\n        enum: ['2.0']\n      },\n      method: {\n        description: 'the method to call',\n        type: 'string',\n        example: 'eth_getBalance'\n      },\n      id: {\n        description: 'the identifier of the request',\n        type: ['number', 'string'],\n        example: 2\n      },\n      params: {\n        description: 'the params',\n        type: 'array',\n        example: ['0xe36179e2286ef405e929C90ad3E70E649B22a945', 'latest']\n      },\n      in3: {\n        description: 'additional config for a IN3 RPC-Request',\n        required: ['chainId'],\n        properties: {\n          chainId: {\n            description: 'the requested chainId',\n            type: 'string',\n            example: '0x1',\n            format: 'hex'\n          },\n          includeCode: {\n            description: 'if true, the request should include the codes of all accounts. otherwise only the the codeHash is returned. In this case the client may ask by calling eth_getCode() afterwards',\n            type: 'boolean',\n            example: true\n          },\n          verifiedHashes: {\n            description: 'if the client sends a array of blockhashes the server will not deliver any signatures or blockheaders for these blocks, but only return a string with a number.',\n            type: 'array',\n            items: {\n              type: 'string',\n              format: 'bytes32'\n            }\n          },\n          latestBlock: {\n            description: 'if specified, the blocknumber *latest* will be replaced by blockNumber- specified value',\n            type: 'integer',\n            example: 6\n          },\n          useRef: {\n            description: 'if true binary-data (starting with a 0x) will be refered if occuring again.',\n            type: 'boolean'\n          },\n          useBinary: {\n            description: 'if true binary-data will be used.',\n            type: 'boolean'\n          },\n          useFullProof: {\n            description: 'if true all data in the response will be proven, which leads to a higher payload.',\n            type: 'boolean'\n          },\n          finality: {\n            description: 'if given the server will deliver the blockheaders of the following blocks until at least the number in percent of the validators is reached.',\n            type: 'number'\n          },\n          verification: {\n            description: 'defines the kind of proof the client is asking for',\n            type: 'string',\n            enum: ['never', 'proof', 'proofWithSignature'],\n            example: 'proof'\n          },\n          clientSignature: {\n            description: 'the signature of the client'\n          },\n          signatures: {\n            description: 'a list of addresses requested to sign the blockhash',\n            type: 'array',\n            example: ['0x6C1a01C2aB554930A937B0a2E8105fB47946c679'],\n            items: {\n              type: 'string',\n              format: 'address'\n            }\n          }\n        }\n      }\n    }\n  },\n  RPCResponse: {\n    type: 'object',\n    description: 'a JSONRPC-Responset with N3-Extension',\n    required: ['jsonrpc', 'id'],\n    properties: {\n      jsonrpc: {\n        description: 'the version',\n        type: 'string',\n        enum: ['2.0']\n      },\n      id: {\n        description: 'the id matching the request',\n        type: ['string', 'number'],\n        example: 2\n      },\n      error: {\n        description: 'in case of an error this needs to be set',\n        type: 'string'\n      },\n      result: {\n        description: 'the params',\n        example: '0xa35bc'\n      },\n      in3: {\n        description: 'additional data returned from a IN3 Server',\n        type: 'object',\n        properties: {\n          proof: {\n            description: 'the Proof-data as part of the in3-section',\n            type: 'object',\n            required: ['type'],\n            properties: {\n              type: {\n                description: 'the type of the proof',\n                type: 'string',\n                enum: ['transactionProof', 'receiptProof', 'blockProof', 'accountProof', 'callProof', 'logProof'],\n                example: 'accountProof'\n              },\n              block: {\n                type: 'string',\n                description: 'the serialized blockheader as hex, required in most proofs',\n                example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b'\n              },\n              finalityBlocks: {\n                type: 'array',\n                description: 'the serialized blockheader as hex, required in case of finality asked',\n                example: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b']\n              },\n              transactions: {\n                type: 'array',\n                description: 'the list of transactions of the block',\n                example: []\n              },\n              uncles: {\n                type: 'array',\n                description: 'the list of uncle-headers of the block',\n                example: []\n              },\n              merkleProof: {\n                type: 'array',\n                description: 'the serialized merle-noodes beginning with the root-node',\n                exmaple: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b', '0x01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1', '0xcf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbd'],\n                items: {\n                  type: 'string',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                }\n              },\n              merkleProofPrev: {\n                type: 'array',\n                description: 'the serialized merkle-noodes beginning with the root-node of the previous entry (only for full proof of receipts)',\n                exmaple: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b', '0x01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1', '0xcf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbd'],\n                items: {\n                  type: 'string',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                }\n              },\n              txProof: {\n                type: 'array',\n                description: 'the serialized merkle-nodes beginning with the root-node in order to prrof the transactionIndex',\n                items: {\n                  type: 'string',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                }\n              },\n              logProof: {\n                description: 'a Object holding proofs for event logs. The key is the blockNumber as hex',\n                type: 'object',\n                additionalProperties: {\n                  type: 'object',\n                  required: ['block', 'receipts'],\n                  properties: {\n                    number: {\n                      description: 'the blockNumber',\n                      type: 'number'\n                    },\n                    block: {\n                      description: 'the serialized blockheader',\n                      type: 'string',\n                      example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b'\n                    },\n                    allReceipts: {\n                      description: 'temp. list of all receipts, which is not included in the final proof',\n                      type: 'array'\n                    },\n                    receipts: {\n                      description: 'the map of existing receipts with the txHash as key',\n                      type: 'object',\n                      additionalProperties: {\n                        type: 'object',\n                        required: ['txIndex', 'proof'],\n                        properties: {\n                          txHash: {\n                            type: 'string',\n                            description: 'the transactionHash'\n                          },\n                          txIndex: {\n                            type: 'integer',\n                            description: 'the transactionIndex within the block'\n                          },\n                          txProof: {\n                            type: 'array',\n                            description: 'the merkleProof',\n                            items: {\n                              type: 'string',\n                              pattern: '^0x[0-9a-fA-F]+$'\n                            }\n                          },\n                          proof: {\n                            type: 'array',\n                            description: 'the merkleProof',\n                            items: {\n                              type: 'string',\n                              pattern: '^0x[0-9a-fA-F]+$'\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              },\n              accounts: {\n                type: 'object',\n                description: 'a map of addresses and their AccountProof',\n                additionalProperties: {\n                  type: 'object',\n                  description: 'the Proof-for a single Account',\n                  required: ['accountProof', 'address', 'balance', 'codeHash', 'nonce', 'storageHash', 'storageProof'],\n                  properties: {\n                    accountProof: {\n                      type: 'array',\n                      description: 'the serialized merle-noodes beginning with the root-node',\n                      items: {\n                        type: 'string',\n                        pattern: '^0x[0-9a-fA-F]+$'\n                      }\n                    },\n                    address: {\n                      type: 'string',\n                      description: 'the address of this account',\n                      pattern: '^0x[0-9a-fA-F]+$'\n                    },\n                    balance: {\n                      type: 'string',\n                      description: 'the balance of this account as hex',\n                      pattern: '^0x[0-9a-fA-F]+$'\n                    },\n                    codeHash: {\n                      type: 'string',\n                      description: 'the codeHash of this account as hex',\n                      pattern: '^0x[0-9a-fA-F]+$'\n                    },\n                    code: {\n                      type: 'string',\n                      description: 'the code of this account as hex ( if required)',\n                      pattern: '^0x[0-9a-fA-F]+$'\n                    },\n                    nonce: {\n                      type: 'string',\n                      description: 'the nonce of this account as hex',\n                      pattern: '^0x[0-9a-fA-F]+$'\n                    },\n                    storageHash: {\n                      type: 'string',\n                      description: 'the storageHash of this account as hex',\n                      pattern: '^0x[0-9a-fA-F]+$'\n                    },\n                    storageProof: {\n                      type: 'array',\n                      description: 'proof for requested storage-data',\n                      items: {\n                        type: 'object',\n                        required: ['key', 'proof', 'value'],\n                        properties: {\n                          key: {\n                            type: 'string',\n                            description: 'the storage key',\n                            pattern: '^0x[0-9a-fA-F]+$'\n                          },\n                          proof: {\n                            type: 'array',\n                            description: 'the serialized merkle-noodes beginning with the root-node ( storageHash )',\n                            items: {\n                              type: 'string',\n                              pattern: '^0x[0-9a-fA-F]+$'\n                            }\n                          },\n                          value: {\n                            type: 'string',\n                            description: 'the stored value',\n                            pattern: '^0x[0-9a-fA-F]+$'\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              },\n              txIndex: {\n                type: 'integer',\n                description: 'the transactionIndex within the block',\n                example: 4\n              },\n              signatures: {\n                type: 'array',\n                description: 'requested signatures',\n                items: {\n                  description: 'Verified ECDSA Signature. Signatures are a pair (r, s). Where r is computed as the X coordinate of a point R, modulo the curve order n.',\n                  type: 'object',\n                  required: ['r', 's', 'v', 'msgHash', 'block', 'blockHash'],\n                  properties: {\n                    address: {\n                      type: 'string',\n                      description: 'the address of the signing node',\n                      format: 'address',\n                      example: '0x6C1a01C2aB554930A937B0a2E8105fB47946c679'\n                    },\n                    block: {\n                      type: 'number',\n                      description: 'the blocknumber',\n                      example: 3123874\n                    },\n                    blockHash: {\n                      type: 'string',\n                      description: 'the hash of the block',\n                      example: '0x6C1a01C2aB554930A937B0a212346037E8105fB47946c679',\n                      format: 'bytes32'\n                    },\n                    msgHash: {\n                      type: 'string',\n                      description: 'hash of the message',\n                      format: 'bytes32',\n                      example: '0x9C1a01C2aB554930A937B0a212346037E8105fB47946AB5D'\n                    },\n                    r: {\n                      type: 'string',\n                      description: 'Positive non-zero Integer signature.r',\n                      format: 'hex',\n                      example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1f'\n                    },\n                    s: {\n                      type: 'string',\n                      description: 'Positive non-zero Integer signature.s',\n                      format: 'hex',\n                      example: '0x6d17b34aeaf95fee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda'\n                    },\n                    v: {\n                      type: 'integer',\n                      description: 'Calculated curve point, or identity element O.',\n                      format: 'hex',\n                      example: 28\n                    }\n                  }\n                }\n              }\n            }\n          },\n          lastNodeList: {\n            description: 'the blocknumber for the last block updating the nodelist. If the client has a smaller blocknumber he should update the nodeList.',\n            type: 'number',\n            example: 326478\n          },\n          lastValidatorChange: {\n            description: 'the blocknumber of gthe last change of the validatorList',\n            type: 'number'\n          },\n          currentBlock: {\n            description: 'the current blocknumber.',\n            type: 'number',\n            example: 320126478\n          }\n        }\n      },\n      in3Node: {\n        description: 'a configuration of a in3-server.',\n        type: 'object',\n        required: ['address', 'url', 'deposit', 'chainIds'],\n        properties: {\n          index: {\n            description: 'the index within the contract',\n            type: 'integer',\n            example: 13\n          },\n          address: {\n            description: 'the address of the node, which is the public address it iis signing with.',\n            type: 'string',\n            format: 'address',\n            example: '0x6C1a01C2aB554930A937B0a2E8105fB47946c679'\n          },\n          timeout: {\n            description: 'the time (in seconds) until an owner is able to receive his deposit back after he unregisters himself',\n            type: 'integer',\n            example: 3600\n          },\n          url: {\n            description: 'the endpoint to post to',\n            type: 'string',\n            example: 'https://in3.slock.it'\n          },\n          chainIds: {\n            description: 'the list of supported chains',\n            example: ['0x1'],\n            type: 'array',\n            items: {\n              type: 'string',\n              format: 'hex'\n            }\n          },\n          deposit: {\n            description: 'the deposit of the node in wei',\n            type: 'integer',\n            example: 12350000\n          },\n          capacity: {\n            description: 'the capacity of the node.',\n            type: 'integer',\n            example: 100\n          },\n          props: {\n            description: 'the properties of the node.',\n            type: 'integer',\n            example: 3\n          }\n        }\n      }\n    }\n  },\n  AuraValidatoryProof: {\n    type: 'object',\n    description: 'a Object holding proofs for validator logs. The key is the blockNumber as hex',\n    required: ['logIndex', 'block', 'txIndex', 'proof'],\n    properties: {\n      logIndex: {\n        description: 'the transaction log index',\n        type: 'number'\n      },\n      block: {\n        description: 'the serialized blockheader',\n        type: 'string',\n        example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b'\n      },\n      txIndex: {\n        type: 'integer',\n        description: 'the transactionIndex within the block'\n      },\n      proof: {\n        type: 'array',\n        description: 'the merkleProof',\n        items: {\n          type: 'string',\n          pattern: '^0x[0-9a-fA-F]+$'\n        }\n      },\n      finalityBlocks: {\n        type: 'array',\n        description: 'the serialized blockheader as hex, required in case of finality asked',\n        example: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b']\n      }\n    }\n  },\n  LogProof: {\n    type: 'object',\n    description: 'a Object holding proofs for event logs. The key is the blockNumber as hex',\n    additionalProperties: {\n      type: 'object',\n      required: ['block', 'receipts'],\n      properties: {\n        number: {\n          description: 'the blockNumber',\n          type: 'number'\n        },\n        block: {\n          description: 'the serialized blockheader',\n          type: 'string',\n          example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b'\n        },\n        allReceipts: {\n          description: 'temp. list of all receipts, which is not included in the final proof',\n          type: 'array'\n        },\n        receipts: {\n          description: 'the map of existing receipts with the txHash as key',\n          type: 'object',\n          additionalProperties: {\n            type: 'object',\n            required: ['txIndex', 'proof'],\n            properties: {\n              txHash: {\n                type: 'string',\n                description: 'the transactionHash'\n              },\n              txIndex: {\n                type: 'integer',\n                description: 'the transactionIndex within the block'\n              },\n              txProof: {\n                type: 'array',\n                description: 'the merkleProof',\n                items: {\n                  type: 'string',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                }\n              },\n              proof: {\n                type: 'array',\n                description: 'the merkleProof',\n                items: {\n                  type: 'string',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  Proof: {\n    type: 'object',\n    description: 'the Proof-data as part of the in3-section',\n    required: ['type'],\n    properties: {\n      type: {\n        description: 'the type of the proof',\n        type: 'string',\n        enum: ['transactionProof', 'receiptProof', 'blockProof', 'accountProof', 'callProof', 'logProof'],\n        example: 'accountProof'\n      },\n      block: {\n        type: 'string',\n        description: 'the serialized blockheader as hex, required in most proofs',\n        example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b'\n      },\n      finalityBlocks: {\n        type: 'array',\n        description: 'the serialized blockheader as hex, required in case of finality asked',\n        example: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b']\n      },\n      transactions: {\n        type: 'array',\n        description: 'the list of transactions of the block',\n        example: []\n      },\n      uncles: {\n        type: 'array',\n        description: 'the list of uncle-headers of the block',\n        example: []\n      },\n      merkleProof: {\n        type: 'array',\n        description: 'the serialized merle-noodes beginning with the root-node',\n        exmaple: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b', '0x01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1', '0xcf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbd'],\n        items: {\n          type: 'string',\n          pattern: '^0x[0-9a-fA-F]+$'\n        }\n      },\n      merkleProofPrev: {\n        type: 'array',\n        description: 'the serialized merkle-noodes beginning with the root-node of the previous entry (only for full proof of receipts)',\n        exmaple: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b', '0x01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1', '0xcf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbd'],\n        items: {\n          type: 'string',\n          pattern: '^0x[0-9a-fA-F]+$'\n        }\n      },\n      txProof: {\n        type: 'array',\n        description: 'the serialized merkle-nodes beginning with the root-node in order to prrof the transactionIndex',\n        items: {\n          type: 'string',\n          pattern: '^0x[0-9a-fA-F]+$'\n        }\n      },\n      logProof: {\n        description: 'a Object holding proofs for event logs. The key is the blockNumber as hex',\n        type: 'object',\n        additionalProperties: {\n          type: 'object',\n          required: ['block', 'receipts'],\n          properties: {\n            number: {\n              description: 'the blockNumber',\n              type: 'number'\n            },\n            block: {\n              description: 'the serialized blockheader',\n              type: 'string',\n              example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b'\n            },\n            allReceipts: {\n              description: 'temp. list of all receipts, which is not included in the final proof',\n              type: 'array'\n            },\n            receipts: {\n              description: 'the map of existing receipts with the txHash as key',\n              type: 'object',\n              additionalProperties: {\n                type: 'object',\n                required: ['txIndex', 'proof'],\n                properties: {\n                  txHash: {\n                    type: 'string',\n                    description: 'the transactionHash'\n                  },\n                  txIndex: {\n                    type: 'integer',\n                    description: 'the transactionIndex within the block'\n                  },\n                  txProof: {\n                    type: 'array',\n                    description: 'the merkleProof',\n                    items: {\n                      type: 'string',\n                      pattern: '^0x[0-9a-fA-F]+$'\n                    }\n                  },\n                  proof: {\n                    type: 'array',\n                    description: 'the merkleProof',\n                    items: {\n                      type: 'string',\n                      pattern: '^0x[0-9a-fA-F]+$'\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      accounts: {\n        type: 'object',\n        description: 'a map of addresses and their AccountProof',\n        additionalProperties: {\n          type: 'object',\n          description: 'the Proof-for a single Account',\n          required: ['accountProof', 'address', 'balance', 'codeHash', 'nonce', 'storageHash', 'storageProof'],\n          properties: {\n            accountProof: {\n              type: 'array',\n              description: 'the serialized merle-noodes beginning with the root-node',\n              items: {\n                type: 'string',\n                pattern: '^0x[0-9a-fA-F]+$'\n              }\n            },\n            address: {\n              type: 'string',\n              description: 'the address of this account',\n              pattern: '^0x[0-9a-fA-F]+$'\n            },\n            balance: {\n              type: 'string',\n              description: 'the balance of this account as hex',\n              pattern: '^0x[0-9a-fA-F]+$'\n            },\n            codeHash: {\n              type: 'string',\n              description: 'the codeHash of this account as hex',\n              pattern: '^0x[0-9a-fA-F]+$'\n            },\n            code: {\n              type: 'string',\n              description: 'the code of this account as hex ( if required)',\n              pattern: '^0x[0-9a-fA-F]+$'\n            },\n            nonce: {\n              type: 'string',\n              description: 'the nonce of this account as hex',\n              pattern: '^0x[0-9a-fA-F]+$'\n            },\n            storageHash: {\n              type: 'string',\n              description: 'the storageHash of this account as hex',\n              pattern: '^0x[0-9a-fA-F]+$'\n            },\n            storageProof: {\n              type: 'array',\n              description: 'proof for requested storage-data',\n              items: {\n                type: 'object',\n                required: ['key', 'proof', 'value'],\n                properties: {\n                  key: {\n                    type: 'string',\n                    description: 'the storage key',\n                    pattern: '^0x[0-9a-fA-F]+$'\n                  },\n                  proof: {\n                    type: 'array',\n                    description: 'the serialized merkle-noodes beginning with the root-node ( storageHash )',\n                    items: {\n                      type: 'string',\n                      pattern: '^0x[0-9a-fA-F]+$'\n                    }\n                  },\n                  value: {\n                    type: 'string',\n                    description: 'the stored value',\n                    pattern: '^0x[0-9a-fA-F]+$'\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      txIndex: {\n        type: 'integer',\n        description: 'the transactionIndex within the block',\n        example: 4\n      },\n      signatures: {\n        type: 'array',\n        description: 'requested signatures',\n        items: {\n          description: 'Verified ECDSA Signature. Signatures are a pair (r, s). Where r is computed as the X coordinate of a point R, modulo the curve order n.',\n          type: 'object',\n          required: ['r', 's', 'v', 'msgHash', 'block', 'blockHash'],\n          properties: {\n            address: {\n              type: 'string',\n              description: 'the address of the signing node',\n              format: 'address',\n              example: '0x6C1a01C2aB554930A937B0a2E8105fB47946c679'\n            },\n            block: {\n              type: 'number',\n              description: 'the blocknumber',\n              example: 3123874\n            },\n            blockHash: {\n              type: 'string',\n              description: 'the hash of the block',\n              example: '0x6C1a01C2aB554930A937B0a212346037E8105fB47946c679',\n              format: 'bytes32'\n            },\n            msgHash: {\n              type: 'string',\n              description: 'hash of the message',\n              format: 'bytes32',\n              example: '0x9C1a01C2aB554930A937B0a212346037E8105fB47946AB5D'\n            },\n            r: {\n              type: 'string',\n              description: 'Positive non-zero Integer signature.r',\n              format: 'hex',\n              example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1f'\n            },\n            s: {\n              type: 'string',\n              description: 'Positive non-zero Integer signature.s',\n              format: 'hex',\n              example: '0x6d17b34aeaf95fee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda'\n            },\n            v: {\n              type: 'integer',\n              description: 'Calculated curve point, or identity element O.',\n              format: 'hex',\n              example: 28\n            }\n          }\n        }\n      }\n    }\n  },\n  AccountProof: {\n    type: 'object',\n    description: 'the Proof-for a single Account',\n    required: ['accountProof', 'address', 'balance', 'codeHash', 'nonce', 'storageHash', 'storageProof'],\n    properties: {\n      accountProof: {\n        type: 'array',\n        description: 'the serialized merle-noodes beginning with the root-node',\n        items: {\n          type: 'string',\n          pattern: '^0x[0-9a-fA-F]+$'\n        }\n      },\n      address: {\n        type: 'string',\n        description: 'the address of this account',\n        pattern: '^0x[0-9a-fA-F]+$'\n      },\n      balance: {\n        type: 'string',\n        description: 'the balance of this account as hex',\n        pattern: '^0x[0-9a-fA-F]+$'\n      },\n      codeHash: {\n        type: 'string',\n        description: 'the codeHash of this account as hex',\n        pattern: '^0x[0-9a-fA-F]+$'\n      },\n      code: {\n        type: 'string',\n        description: 'the code of this account as hex ( if required)',\n        pattern: '^0x[0-9a-fA-F]+$'\n      },\n      nonce: {\n        type: 'string',\n        description: 'the nonce of this account as hex',\n        pattern: '^0x[0-9a-fA-F]+$'\n      },\n      storageHash: {\n        type: 'string',\n        description: 'the storageHash of this account as hex',\n        pattern: '^0x[0-9a-fA-F]+$'\n      },\n      storageProof: {\n        type: 'array',\n        description: 'proof for requested storage-data',\n        items: {\n          type: 'object',\n          required: ['key', 'proof', 'value'],\n          properties: {\n            key: {\n              type: 'string',\n              description: 'the storage key',\n              pattern: '^0x[0-9a-fA-F]+$'\n            },\n            proof: {\n              type: 'array',\n              description: 'the serialized merkle-noodes beginning with the root-node ( storageHash )',\n              items: {\n                type: 'string',\n                pattern: '^0x[0-9a-fA-F]+$'\n              }\n            },\n            value: {\n              type: 'string',\n              description: 'the stored value',\n              pattern: '^0x[0-9a-fA-F]+$'\n            }\n          }\n        }\n      }\n    }\n  },\n  ServerList: {\n    type: 'object',\n    description: 'a List of nodes',\n    required: ['nodes'],\n    properties: {\n      lastBlockNumber: {\n        type: 'integer',\n        description: 'last Block number'\n      },\n      nodes: {\n        type: 'array',\n        description: 'the list of nodes',\n        items: {\n          description: 'a configuration of a in3-server.',\n          type: 'object',\n          required: ['address', 'url', 'deposit', 'chainIds'],\n          properties: {\n            index: {\n              description: 'the index within the contract',\n              type: 'integer',\n              example: 13\n            },\n            address: {\n              description: 'the address of the node, which is the public address it iis signing with.',\n              type: 'string',\n              format: 'address',\n              example: '0x6C1a01C2aB554930A937B0a2E8105fB47946c679'\n            },\n            timeout: {\n              description: 'the time (in seconds) until an owner is able to receive his deposit back after he unregisters himself',\n              type: 'integer',\n              example: 3600\n            },\n            url: {\n              description: 'the endpoint to post to',\n              type: 'string',\n              example: 'https://in3.slock.it'\n            },\n            chainIds: {\n              description: 'the list of supported chains',\n              example: ['0x1'],\n              type: 'array',\n              items: {\n                type: 'string',\n                format: 'hex'\n              }\n            },\n            deposit: {\n              description: 'the deposit of the node in wei',\n              type: 'integer',\n              example: 12350000\n            },\n            capacity: {\n              description: 'the capacity of the node.',\n              type: 'integer',\n              example: 100\n            },\n            props: {\n              description: 'the properties of the node.',\n              type: 'integer',\n              example: 3\n            }\n          }\n        }\n      },\n      contract: {\n        type: 'string',\n        description: 'IN3 Registry',\n        pattern: '^0x[0-9a-fA-F]+$'\n      },\n      totalServers: {\n        type: 'integer',\n        description: 'number of servers'\n      },\n      proof: {\n        type: 'object',\n        description: 'the Proof-data as part of the in3-section',\n        required: ['type'],\n        properties: {\n          type: {\n            description: 'the type of the proof',\n            type: 'string',\n            enum: ['transactionProof', 'receiptProof', 'blockProof', 'accountProof', 'callProof', 'logProof'],\n            example: 'accountProof'\n          },\n          block: {\n            type: 'string',\n            description: 'the serialized blockheader as hex, required in most proofs',\n            example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b'\n          },\n          finalityBlocks: {\n            type: 'array',\n            description: 'the serialized blockheader as hex, required in case of finality asked',\n            example: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b']\n          },\n          transactions: {\n            type: 'array',\n            description: 'the list of transactions of the block',\n            example: []\n          },\n          uncles: {\n            type: 'array',\n            description: 'the list of uncle-headers of the block',\n            example: []\n          },\n          merkleProof: {\n            type: 'array',\n            description: 'the serialized merle-noodes beginning with the root-node',\n            exmaple: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b', '0x01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1', '0xcf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbd'],\n            items: {\n              type: 'string',\n              pattern: '^0x[0-9a-fA-F]+$'\n            }\n          },\n          merkleProofPrev: {\n            type: 'array',\n            description: 'the serialized merkle-noodes beginning with the root-node of the previous entry (only for full proof of receipts)',\n            exmaple: ['0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b', '0x01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1', '0xcf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbd'],\n            items: {\n              type: 'string',\n              pattern: '^0x[0-9a-fA-F]+$'\n            }\n          },\n          txProof: {\n            type: 'array',\n            description: 'the serialized merkle-nodes beginning with the root-node in order to prrof the transactionIndex',\n            items: {\n              type: 'string',\n              pattern: '^0x[0-9a-fA-F]+$'\n            }\n          },\n          logProof: {\n            description: 'a Object holding proofs for event logs. The key is the blockNumber as hex',\n            type: 'object',\n            additionalProperties: {\n              type: 'object',\n              required: ['block', 'receipts'],\n              properties: {\n                number: {\n                  description: 'the blockNumber',\n                  type: 'number'\n                },\n                block: {\n                  description: 'the serialized blockheader',\n                  type: 'string',\n                  example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda6463a8f1ebb14f3aff6b19cb91acf2b8ec1ffee98c0437b4ac839d8a2ece1b18166da704b'\n                },\n                allReceipts: {\n                  description: 'temp. list of all receipts, which is not included in the final proof',\n                  type: 'array'\n                },\n                receipts: {\n                  description: 'the map of existing receipts with the txHash as key',\n                  type: 'object',\n                  additionalProperties: {\n                    type: 'object',\n                    required: ['txIndex', 'proof'],\n                    properties: {\n                      txHash: {\n                        type: 'string',\n                        description: 'the transactionHash'\n                      },\n                      txIndex: {\n                        type: 'integer',\n                        description: 'the transactionIndex within the block'\n                      },\n                      txProof: {\n                        type: 'array',\n                        description: 'the merkleProof',\n                        items: {\n                          type: 'string',\n                          pattern: '^0x[0-9a-fA-F]+$'\n                        }\n                      },\n                      proof: {\n                        type: 'array',\n                        description: 'the merkleProof',\n                        items: {\n                          type: 'string',\n                          pattern: '^0x[0-9a-fA-F]+$'\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n          accounts: {\n            type: 'object',\n            description: 'a map of addresses and their AccountProof',\n            additionalProperties: {\n              type: 'object',\n              description: 'the Proof-for a single Account',\n              required: ['accountProof', 'address', 'balance', 'codeHash', 'nonce', 'storageHash', 'storageProof'],\n              properties: {\n                accountProof: {\n                  type: 'array',\n                  description: 'the serialized merle-noodes beginning with the root-node',\n                  items: {\n                    type: 'string',\n                    pattern: '^0x[0-9a-fA-F]+$'\n                  }\n                },\n                address: {\n                  type: 'string',\n                  description: 'the address of this account',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                balance: {\n                  type: 'string',\n                  description: 'the balance of this account as hex',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                codeHash: {\n                  type: 'string',\n                  description: 'the codeHash of this account as hex',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                code: {\n                  type: 'string',\n                  description: 'the code of this account as hex ( if required)',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                nonce: {\n                  type: 'string',\n                  description: 'the nonce of this account as hex',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                storageHash: {\n                  type: 'string',\n                  description: 'the storageHash of this account as hex',\n                  pattern: '^0x[0-9a-fA-F]+$'\n                },\n                storageProof: {\n                  type: 'array',\n                  description: 'proof for requested storage-data',\n                  items: {\n                    type: 'object',\n                    required: ['key', 'proof', 'value'],\n                    properties: {\n                      key: {\n                        type: 'string',\n                        description: 'the storage key',\n                        pattern: '^0x[0-9a-fA-F]+$'\n                      },\n                      proof: {\n                        type: 'array',\n                        description: 'the serialized merkle-noodes beginning with the root-node ( storageHash )',\n                        items: {\n                          type: 'string',\n                          pattern: '^0x[0-9a-fA-F]+$'\n                        }\n                      },\n                      value: {\n                        type: 'string',\n                        description: 'the stored value',\n                        pattern: '^0x[0-9a-fA-F]+$'\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n          txIndex: {\n            type: 'integer',\n            description: 'the transactionIndex within the block',\n            example: 4\n          },\n          signatures: {\n            type: 'array',\n            description: 'requested signatures',\n            items: {\n              description: 'Verified ECDSA Signature. Signatures are a pair (r, s). Where r is computed as the X coordinate of a point R, modulo the curve order n.',\n              type: 'object',\n              required: ['r', 's', 'v', 'msgHash', 'block', 'blockHash'],\n              properties: {\n                address: {\n                  type: 'string',\n                  description: 'the address of the signing node',\n                  format: 'address',\n                  example: '0x6C1a01C2aB554930A937B0a2E8105fB47946c679'\n                },\n                block: {\n                  type: 'number',\n                  description: 'the blocknumber',\n                  example: 3123874\n                },\n                blockHash: {\n                  type: 'string',\n                  description: 'the hash of the block',\n                  example: '0x6C1a01C2aB554930A937B0a212346037E8105fB47946c679',\n                  format: 'bytes32'\n                },\n                msgHash: {\n                  type: 'string',\n                  description: 'hash of the message',\n                  format: 'bytes32',\n                  example: '0x9C1a01C2aB554930A937B0a212346037E8105fB47946AB5D'\n                },\n                r: {\n                  type: 'string',\n                  description: 'Positive non-zero Integer signature.r',\n                  format: 'hex',\n                  example: '0x72804cfa0179d648ccbe6a65b01a6463a8f1ebb14f3aff6b19cb91acf2b8ec1f'\n                },\n                s: {\n                  type: 'string',\n                  description: 'Positive non-zero Integer signature.s',\n                  format: 'hex',\n                  example: '0x6d17b34aeaf95fee98c0437b4ac839d8a2ece1b18166da704b86d8f42c92bbda'\n                },\n                v: {\n                  type: 'integer',\n                  description: 'Calculated curve point, or identity element O.',\n                  format: 'hex',\n                  example: 28\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  IN3RPCConfig: {\n    type: 'object',\n    description: 'the configuration for the rpc-handler',\n    properties: {\n      id: {\n        type: 'string',\n        description: 'a identifier used in logfiles as also for reading the config from the database'\n      },\n      defaultChain: {\n        type: 'string',\n        description: 'the default chainId in case the request does not contain one.'\n      },\n      port: {\n        type: 'integer',\n        default: 8500,\n        description: 'the listeneing port for the server'\n      },\n      db: {\n        type: 'object',\n        properties: {\n          user: {\n            type: 'string',\n            description: 'username for the db'\n          },\n          password: {\n            type: 'string',\n            description: 'password for db-access'\n          },\n          host: {\n            type: 'string',\n            description: 'db-host (default = localhost)'\n          },\n          port: {\n            type: 'integer',\n            description: 'the database port'\n          },\n          database: {\n            type: 'string',\n            description: 'name of the database'\n          }\n        }\n      },\n      profile: {\n        type: 'object',\n        properties: {\n          icon: {\n            type: 'string',\n            description: 'url to a icon or logo of company offering this node'\n          },\n          url: {\n            type: 'string',\n            description: 'url of the website of the company'\n          },\n          name: {\n            type: 'string',\n            description: 'name of the node or company'\n          },\n          comment: {\n            type: 'string',\n            description: 'comments for the node'\n          },\n          noStats: {\n            type: 'boolean',\n            description: 'if active the stats will not be shown (default:false)'\n          }\n        }\n      },\n      logging: {\n        type: 'object',\n        description: 'logger config',\n        required: [],\n        properties: {\n          file: {\n            type: 'string',\n            description: 'the path to the logile'\n          },\n          level: {\n            type: 'string',\n            description: 'Loglevel'\n          },\n          colors: {\n            type: 'boolean',\n            description: 'if true colors will be used'\n          },\n          name: {\n            type: 'string',\n            description: 'the name of the provider'\n          },\n          type: {\n            type: 'string',\n            description: 'the module of the provider'\n          },\n          port: {\n            type: 'integer',\n            description: 'the port for custom logging'\n          },\n          host: {\n            type: 'string',\n            description: 'the host for custom logging'\n          }\n        }\n      },\n      chains: {\n        type: 'object',\n        description: 'a definition of the Handler per chain',\n        additionalProperties: {\n          type: 'object',\n          description: 'the configuration for the rpc-handler',\n          required: ['rpcUrl', 'privateKey', 'registry'],\n          properties: {\n            handler: {\n              type: 'string',\n              description: 'the impl used to handle the calls',\n              enum: ['eth', 'ipfs', 'btc']\n            },\n            ipfsUrl: {\n              type: 'string',\n              description: 'the url of the ipfs-client'\n            },\n            timeout: {\n              type: 'integer',\n              description: 'number of milliseconds to wait before a request gets a timeout'\n            },\n            rpcUrl: {\n              type: 'string',\n              description: 'the url of the client'\n            },\n            clientKeys: {\n              type: 'string',\n              description: 'a comma sepearted list of client keys to use for simulating clients for the watchdog'\n            },\n            watchdogInterval: {\n              type: 'number',\n              description: 'average time between sending requests to the same node. 0 turns it off (default)'\n            },\n            freeScore: {\n              type: 'number',\n              description: 'the score for requests without a valid signature'\n            },\n            minBlockHeight: {\n              type: 'integer',\n              description: 'the minimal blockheight in order to sign'\n            },\n            maxThreads: {\n              type: 'integer',\n              description: 'the maximal number of threads ofr running parallel processes'\n            },\n            persistentFile: {\n              type: 'string',\n              description: 'the filename of the file keeping track of the last handled blocknumber'\n            },\n            startBlock: {\n              type: 'number',\n              description: 'blocknumber to start watching the registry'\n            },\n            watchInterval: {\n              type: 'integer',\n              description: 'the number of seconds of the interval for checking for new events'\n            },\n            privateKey: {\n              type: 'string',\n              description: 'the private key used to sign blockhashes. this can be either a 0x-prefixed string with the raw private key or the path to a key-file.'\n            },\n            privateKeyPassphrase: {\n              type: 'string',\n              description: 'the password used to decrpyt the private key'\n            },\n            registry: {\n              type: 'string',\n              description: 'the address of the server registry used in order to update the nodeList'\n            },\n            registryRPC: {\n              type: 'string',\n              description: 'the url of the client in case the registry is not on the same chain.'\n            },\n            autoRegistry: {\n              type: 'object',\n              required: ['url', 'deposit'],\n              properties: {\n                url: {\n                  type: 'string',\n                  description: 'the public url to reach this node'\n                },\n                deposit: {\n                  type: 'number',\n                  description: 'the deposit you want ot store'\n                },\n                capacity: {\n                  type: 'number',\n                  description: 'max number of parallel requests'\n                },\n                depositUnit: {\n                  type: 'string',\n                  description: 'unit of the deposit value',\n                  enum: ['ether', 'finney', 'szabo', 'wei']\n                },\n                capabilities: {\n                  type: 'object',\n                  properties: {\n                    proof: {\n                      type: 'boolean',\n                      description: 'if true, this node is able to deliver proofs',\n                      flag: 1\n                    },\n                    multiChain: {\n                      type: 'boolean',\n                      description: 'if true, this node is able to deliver multiple chains',\n                      flag: 2\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  IN3RPCHandlerConfig: {\n    type: 'object',\n    description: 'the configuration for the rpc-handler',\n    required: ['rpcUrl', 'privateKey', 'registry'],\n    properties: {\n      handler: {\n        type: 'string',\n        description: 'the impl used to handle the calls',\n        enum: ['eth', 'ipfs', 'btc']\n      },\n      ipfsUrl: {\n        type: 'string',\n        description: 'the url of the ipfs-client'\n      },\n      timeout: {\n        type: 'integer',\n        description: 'number of milliseconds to wait before a request gets a timeout'\n      },\n      rpcUrl: {\n        type: 'string',\n        description: 'the url of the client'\n      },\n      clientKeys: {\n        type: 'string',\n        description: 'a comma sepearted list of client keys to use for simulating clients for the watchdog'\n      },\n      watchdogInterval: {\n        type: 'number',\n        description: 'average time between sending requests to the same node. 0 turns it off (default)'\n      },\n      freeScore: {\n        type: 'number',\n        description: 'the score for requests without a valid signature'\n      },\n      minBlockHeight: {\n        type: 'integer',\n        description: 'the minimal blockheight in order to sign'\n      },\n      maxThreads: {\n        type: 'integer',\n        description: 'the maximal number of threads ofr running parallel processes'\n      },\n      persistentFile: {\n        type: 'string',\n        description: 'the filename of the file keeping track of the last handled blocknumber'\n      },\n      startBlock: {\n        type: 'number',\n        description: 'blocknumber to start watching the registry'\n      },\n      watchInterval: {\n        type: 'integer',\n        description: 'the number of seconds of the interval for checking for new events'\n      },\n      privateKey: {\n        type: 'string',\n        description: 'the private key used to sign blockhashes. this can be either a 0x-prefixed string with the raw private key or the path to a key-file.'\n      },\n      privateKeyPassphrase: {\n        type: 'string',\n        description: 'the password used to decrpyt the private key'\n      },\n      registry: {\n        type: 'string',\n        description: 'the address of the server registry used in order to update the nodeList'\n      },\n      registryRPC: {\n        type: 'string',\n        description: 'the url of the client in case the registry is not on the same chain.'\n      },\n      autoRegistry: {\n        type: 'object',\n        required: ['url', 'deposit'],\n        properties: {\n          url: {\n            type: 'string',\n            description: 'the public url to reach this node'\n          },\n          deposit: {\n            type: 'number',\n            description: 'the deposit you want ot store'\n          },\n          capacity: {\n            type: 'number',\n            description: 'max number of parallel requests'\n          },\n          depositUnit: {\n            type: 'string',\n            description: 'unit of the deposit value',\n            enum: ['ether', 'finney', 'szabo', 'wei']\n          },\n          capabilities: {\n            type: 'object',\n            properties: {\n              proof: {\n                type: 'boolean',\n                description: 'if true, this node is able to deliver proofs',\n                flag: 1\n              },\n              multiChain: {\n                type: 'boolean',\n                description: 'if true, this node is able to deliver multiple chains',\n                flag: 2\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n/** validates the IN3NodeWeight and returns true | false. if it failes, use validateIN3NodeWeight.errors to get a list of errors. */\n\nexports.validateIN3NodeWeight = validate_1.ajv.compile(exports.validationDef.IN3NodeWeight);\nexports.IN3NodeWeightDefinition = exports.validationDef.IN3NodeWeight;\n/** validates the IN3NodeWeight and throws in case of an a invalid object.*/\n\nfunction validateIN3NodeWeightAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateIN3NodeWeight, data);\n}\n\nexports.validateIN3NodeWeightAndThrow = validateIN3NodeWeightAndThrow;\n/** validates the IN3NodeConfig and returns true | false. if it failes, use validateIN3NodeConfig.errors to get a list of errors. */\n\nexports.validateIN3NodeConfig = validate_1.ajv.compile(exports.validationDef.IN3NodeConfig);\nexports.IN3NodeConfigDefinition = exports.validationDef.IN3NodeConfig;\n/** validates the IN3NodeConfig and throws in case of an a invalid object.*/\n\nfunction validateIN3NodeConfigAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateIN3NodeConfig, data);\n}\n\nexports.validateIN3NodeConfigAndThrow = validateIN3NodeConfigAndThrow;\n/** validates the IN3RPCRequestConfig and returns true | false. if it failes, use validateIN3RPCRequestConfig.errors to get a list of errors. */\n\nexports.validateIN3RPCRequestConfig = validate_1.ajv.compile(exports.validationDef.IN3RPCRequestConfig);\nexports.IN3RPCRequestConfigDefinition = exports.validationDef.IN3RPCRequestConfig;\n/** validates the IN3RPCRequestConfig and throws in case of an a invalid object.*/\n\nfunction validateIN3RPCRequestConfigAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateIN3RPCRequestConfig, data);\n}\n\nexports.validateIN3RPCRequestConfigAndThrow = validateIN3RPCRequestConfigAndThrow;\n/** validates the Signature and returns true | false. if it failes, use validateSignature.errors to get a list of errors. */\n\nexports.validateSignature = validate_1.ajv.compile(exports.validationDef.Signature);\nexports.SignatureDefinition = exports.validationDef.Signature;\n/** validates the Signature and throws in case of an a invalid object.*/\n\nfunction validateSignatureAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateSignature, data);\n}\n\nexports.validateSignatureAndThrow = validateSignatureAndThrow;\n/** validates the IN3ResponseConfig and returns true | false. if it failes, use validateIN3ResponseConfig.errors to get a list of errors. */\n\nexports.validateIN3ResponseConfig = validate_1.ajv.compile(exports.validationDef.IN3ResponseConfig);\nexports.IN3ResponseConfigDefinition = exports.validationDef.IN3ResponseConfig;\n/** validates the IN3ResponseConfig and throws in case of an a invalid object.*/\n\nfunction validateIN3ResponseConfigAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateIN3ResponseConfig, data);\n}\n\nexports.validateIN3ResponseConfigAndThrow = validateIN3ResponseConfigAndThrow;\n/** validates the ChainSpec and returns true | false. if it failes, use validateChainSpec.errors to get a list of errors. */\n\nexports.validateChainSpec = validate_1.ajv.compile(exports.validationDef.ChainSpec);\nexports.ChainSpecDefinition = exports.validationDef.ChainSpec;\n/** validates the ChainSpec and throws in case of an a invalid object.*/\n\nfunction validateChainSpecAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateChainSpec, data);\n}\n\nexports.validateChainSpecAndThrow = validateChainSpecAndThrow;\n/** validates the IN3Config and returns true | false. if it failes, use validateIN3Config.errors to get a list of errors. */\n\nexports.validateIN3Config = validate_1.ajv.compile(exports.validationDef.IN3Config);\nexports.IN3ConfigDefinition = exports.validationDef.IN3Config;\n/** validates the IN3Config and throws in case of an a invalid object.*/\n\nfunction validateIN3ConfigAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateIN3Config, data);\n}\n\nexports.validateIN3ConfigAndThrow = validateIN3ConfigAndThrow;\n/** validates the RPCRequest and returns true | false. if it failes, use validateRPCRequest.errors to get a list of errors. */\n\nexports.validateRPCRequest = validate_1.ajv.compile(exports.validationDef.RPCRequest);\nexports.RPCRequestDefinition = exports.validationDef.RPCRequest;\n/** validates the RPCRequest and throws in case of an a invalid object.*/\n\nfunction validateRPCRequestAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateRPCRequest, data);\n}\n\nexports.validateRPCRequestAndThrow = validateRPCRequestAndThrow;\n/** validates the RPCResponse and returns true | false. if it failes, use validateRPCResponse.errors to get a list of errors. */\n\nexports.validateRPCResponse = validate_1.ajv.compile(exports.validationDef.RPCResponse);\nexports.RPCResponseDefinition = exports.validationDef.RPCResponse;\n/** validates the RPCResponse and throws in case of an a invalid object.*/\n\nfunction validateRPCResponseAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateRPCResponse, data);\n}\n\nexports.validateRPCResponseAndThrow = validateRPCResponseAndThrow;\n/** validates the AuraValidatoryProof and returns true | false. if it failes, use validateAuraValidatoryProof.errors to get a list of errors. */\n\nexports.validateAuraValidatoryProof = validate_1.ajv.compile(exports.validationDef.AuraValidatoryProof);\nexports.AuraValidatoryProofDefinition = exports.validationDef.AuraValidatoryProof;\n/** validates the AuraValidatoryProof and throws in case of an a invalid object.*/\n\nfunction validateAuraValidatoryProofAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateAuraValidatoryProof, data);\n}\n\nexports.validateAuraValidatoryProofAndThrow = validateAuraValidatoryProofAndThrow;\n/** validates the LogProof and returns true | false. if it failes, use validateLogProof.errors to get a list of errors. */\n\nexports.validateLogProof = validate_1.ajv.compile(exports.validationDef.LogProof);\nexports.LogProofDefinition = exports.validationDef.LogProof;\n/** validates the LogProof and throws in case of an a invalid object.*/\n\nfunction validateLogProofAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateLogProof, data);\n}\n\nexports.validateLogProofAndThrow = validateLogProofAndThrow;\n/** validates the Proof and returns true | false. if it failes, use validateProof.errors to get a list of errors. */\n\nexports.validateProof = validate_1.ajv.compile(exports.validationDef.Proof);\nexports.ProofDefinition = exports.validationDef.Proof;\n/** validates the Proof and throws in case of an a invalid object.*/\n\nfunction validateProofAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateProof, data);\n}\n\nexports.validateProofAndThrow = validateProofAndThrow;\n/** validates the AccountProof and returns true | false. if it failes, use validateAccountProof.errors to get a list of errors. */\n\nexports.validateAccountProof = validate_1.ajv.compile(exports.validationDef.AccountProof);\nexports.AccountProofDefinition = exports.validationDef.AccountProof;\n/** validates the AccountProof and throws in case of an a invalid object.*/\n\nfunction validateAccountProofAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateAccountProof, data);\n}\n\nexports.validateAccountProofAndThrow = validateAccountProofAndThrow;\n/** validates the ServerList and returns true | false. if it failes, use validateServerList.errors to get a list of errors. */\n\nexports.validateServerList = validate_1.ajv.compile(exports.validationDef.ServerList);\nexports.ServerListDefinition = exports.validationDef.ServerList;\n/** validates the ServerList and throws in case of an a invalid object.*/\n\nfunction validateServerListAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateServerList, data);\n}\n\nexports.validateServerListAndThrow = validateServerListAndThrow;\n/** validates the IN3RPCConfig and returns true | false. if it failes, use validateIN3RPCConfig.errors to get a list of errors. */\n\nexports.validateIN3RPCConfig = validate_1.ajv.compile(exports.validationDef.IN3RPCConfig);\nexports.IN3RPCConfigDefinition = exports.validationDef.IN3RPCConfig;\n/** validates the IN3RPCConfig and throws in case of an a invalid object.*/\n\nfunction validateIN3RPCConfigAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateIN3RPCConfig, data);\n}\n\nexports.validateIN3RPCConfigAndThrow = validateIN3RPCConfigAndThrow;\n/** validates the IN3RPCHandlerConfig and returns true | false. if it failes, use validateIN3RPCHandlerConfig.errors to get a list of errors. */\n\nexports.validateIN3RPCHandlerConfig = validate_1.ajv.compile(exports.validationDef.IN3RPCHandlerConfig);\nexports.IN3RPCHandlerConfigDefinition = exports.validationDef.IN3RPCHandlerConfig;\n/** validates the IN3RPCHandlerConfig and throws in case of an a invalid object.*/\n\nfunction validateIN3RPCHandlerConfigAndThrow(data) {\n  validate_1.validateAndThrow(exports.validateIN3RPCHandlerConfig, data);\n}\n\nexports.validateIN3RPCHandlerConfigAndThrow = validateIN3RPCHandlerConfigAndThrow;","map":null,"metadata":{},"sourceType":"script"}