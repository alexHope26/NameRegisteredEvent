{"ast":null,"code":"'use strict';\n/*\n\nThis is the core of the Ethereum Virtual Machine (EVM or just VM).\n\nNOTES:\n\nstack items are lazly dupilicated.\nSo you must never directly change a buffer from the stack,\ninstead you should `copy` it first\n\nnot all stack items are 32 bytes, so if the operation realies on the stack\nitem length then you must use utils.pad(<item>, 32) first.\n*/\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar async = require('async');\n\nvar utils = require('ethereumjs-util');\n\nvar Block = require('ethereumjs-block');\n\nvar lookupOpInfo = require('./opcodes.js');\n\nvar opFns = require('./opFns.js');\n\nvar exceptions = require('./exceptions.js');\n\nvar setImmediate = require('timers').setImmediate;\n\nvar BN = utils.BN;\nvar ERROR = exceptions.ERROR;\nvar VmError = exceptions.VmError;\n/**\n * Runs EVM code\n * @param opts\n * @param opts.account {Account} the account that the exucuting code belongs to\n * @param opts.address {Buffer}  the address of the account that is exucuting this code\n * @param opts.block {Block} the block that the transaction is part of\n * @param opts.caller {Buffer} the address that ran this code\n * @param opts.code {Buffer} the code to be run\n * @param opts.data {Buffer}  the input data\n * @param opts.gasLimit {Buffer}\n * @param opts.origin {Buffer} the address where the call originated from\n * @param opts.value {Buffer} the amount the being transfered\n * @param cb {Function}\n */\n\nmodule.exports = function (opts, cb) {\n  var self = this;\n  var stateManager = self.stateManager;\n  var block = opts.block || new Block(); // VM internal state\n\n  var runState = {\n    stateManager: stateManager,\n    returnValue: false,\n    stopped: false,\n    vmError: false,\n    programCounter: 0,\n    opCode: undefined,\n    opName: undefined,\n    gasLeft: new BN(opts.gasLimit),\n    gasLimit: new BN(opts.gasLimit),\n    gasPrice: opts.gasPrice,\n    memory: [],\n    memoryWordCount: new BN(0),\n    stack: [],\n    lastReturned: [],\n    logs: [],\n    validJumps: [],\n    gasRefund: new BN(0),\n    highestMemCost: new BN(0),\n    depth: opts.depth || 0,\n    // opts.suicides is kept for backward compatiblity with pre-EIP6 syntax\n    selfdestruct: opts.selfdestruct || opts.suicides || {},\n    block: block,\n    callValue: opts.value || new BN(0),\n    address: opts.address || utils.zeros(32),\n    caller: opts.caller || utils.zeros(32),\n    origin: opts.origin || opts.caller || utils.zeros(32),\n    callData: opts.data || Buffer.from([0]),\n    code: opts.code,\n    populateCache: opts.populateCache === undefined ? true : opts.populateCache,\n    static: opts.static || false // temporary - to be factored out\n\n  };\n  runState._precompiled = self._precompiled;\n  runState._vm = self; // prepare to run vm\n\n  preprocessValidJumps(runState); // load contract then start vm run\n\n  loadContract(runVm); // iterate through the given ops until something breaks or we hit STOP\n\n  function runVm() {\n    async.whilst(vmIsActive, iterateVm, parseVmResults);\n  } // ensure contract is loaded; only used if runCode is called directly\n\n\n  function loadContract(cb) {\n    stateManager.getAccount(runState.address, function (err, account) {\n      if (err) return cb(err);\n      runState.contract = account;\n      cb();\n    });\n  }\n\n  function vmIsActive() {\n    var notAtEnd = runState.programCounter < runState.code.length;\n    return !runState.stopped && notAtEnd && !runState.vmError && !runState.returnValue;\n  }\n\n  function iterateVm(done) {\n    var opCode = runState.code[runState.programCounter];\n    var opInfo = lookupOpInfo(opCode);\n    var opName = opInfo.name;\n    var opFn = opFns[opName];\n    runState.opName = opName;\n    runState.opCode = opCode;\n    async.series([runStepHook, runOp], function (err) {\n      setImmediate(done.bind(null, err));\n    });\n\n    function runStepHook(cb) {\n      var eventObj = {\n        pc: runState.programCounter,\n        gasLeft: runState.gasLeft,\n        opcode: lookupOpInfo(opCode, true),\n        stack: runState.stack,\n        depth: runState.depth,\n        address: runState.address,\n        account: runState.contract,\n        cache: runState.stateManager.cache,\n        memory: runState.memory\n      };\n      self.emit('step', eventObj, cb);\n    }\n\n    function runOp(cb) {\n      // check for invalid opcode\n      if (opName === 'INVALID') {\n        return cb(new VmError(ERROR.INVALID_OPCODE));\n      } // check for stack underflows\n\n\n      if (runState.stack.length < opInfo.in) {\n        return cb(new VmError(ERROR.STACK_UNDERFLOW));\n      }\n\n      if (runState.stack.length - opInfo.in + opInfo.out > 1024) {\n        return cb(new VmError(ERROR.STACK_OVERFLOW));\n      } // calculate gas\n\n\n      var fee = new BN(opInfo.fee); // TODO: move to a shared funtion; subGas in opFuns\n\n      runState.gasLeft = runState.gasLeft.sub(fee);\n\n      if (runState.gasLeft.ltn(0)) {\n        runState.gasLeft = new BN(0);\n        cb(new VmError(ERROR.OUT_OF_GAS));\n        return;\n      } // advance program counter\n\n\n      runState.programCounter++;\n      var argsNum = opInfo.in;\n      var retNum = opInfo.out; // pop the stack\n\n      var args = argsNum ? runState.stack.splice(-argsNum) : [];\n      args.reverse();\n      args.push(runState); // create a callback for async opFunc\n\n      if (opInfo.async) {\n        args.push(function (err, result) {\n          if (err) return cb(err); // save result to the stack\n\n          if (result !== undefined) {\n            if (retNum !== 1) {\n              // opcode post-stack mismatch\n              return cb(new VmError(ERROR.INTERNAL_ERROR));\n            }\n\n            runState.stack.push(result);\n          } else {\n            if (retNum !== 0) {\n              // opcode post-stack mismatch\n              return cb(new VmError(ERROR.INTERNAL_ERROR));\n            }\n          }\n\n          cb();\n        });\n      }\n\n      try {\n        // run the opcode\n        var result = opFn.apply(null, args);\n      } catch (e) {\n        cb(e);\n        return;\n      } // save result to the stack\n\n\n      if (result !== undefined) {\n        if (retNum !== 1) {\n          // opcode post-stack mismatch\n          return cb(VmError(ERROR.INTERNAL_ERROR));\n        }\n\n        runState.stack.push(result);\n      } else {\n        if (!opInfo.async && retNum !== 0) {\n          // opcode post-stack mismatch\n          return cb(VmError(ERROR.INTERNAL_ERROR));\n        }\n      } // call the callback if opFn was sync\n\n\n      if (!opInfo.async) {\n        cb();\n      }\n    }\n  }\n\n  function parseVmResults(err) {\n    // remove any logs on error\n    if (err) {\n      runState.logs = [];\n      stateManager.revertContracts();\n      runState.vmError = true;\n    }\n\n    var results = {\n      runState: runState,\n      selfdestruct: runState.selfdestruct,\n      gasRefund: runState.gasRefund,\n      exception: err ? 0 : 1,\n      exceptionError: err,\n      logs: runState.logs,\n      gas: runState.gasLeft,\n      'return': runState.returnValue ? runState.returnValue : Buffer.alloc(0)\n    };\n\n    if (results.exceptionError) {\n      delete results.gasRefund;\n      delete results.selfdestruct;\n    }\n\n    if (err && err.error !== ERROR.REVERT) {\n      results.gasUsed = runState.gasLimit;\n    } else {\n      results.gasUsed = runState.gasLimit.sub(runState.gasLeft);\n    }\n\n    if (runState.populateCache) {\n      self.stateManager.cache.flush(function () {\n        self.stateManager.cache.clear();\n        cb(err, results);\n      });\n    } else {\n      cb(err, results);\n    }\n  }\n}; // find all the valid jumps and puts them in the `validJumps` array\n\n\nfunction preprocessValidJumps(runState) {\n  for (var i = 0; i < runState.code.length; i++) {\n    var curOpCode = lookupOpInfo(runState.code[i]).name; // no destinations into the middle of PUSH\n\n    if (curOpCode === 'PUSH') {\n      i += runState.code[i] - 0x5f;\n    }\n\n    if (curOpCode === 'JUMPDEST') {\n      runState.validJumps.push(i);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}