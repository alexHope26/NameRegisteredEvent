{"ast":null,"code":"\"use strict\";\n/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\nvar _slicedToArray = require(\"/Users/edgarrodriguezzavala/Workspace/programing-test-named-registered/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util_1 = require(\"../../util/util\");\n\nclass Filters {\n  constructor() {\n    this.filters = {};\n  }\n\n  addFilter(client, type, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (type === 'pending') throw new Error('Pending Transactions are not supported');\n      const id = '0x' + (Object.keys(this.filters).reduce((a, b) => Math.max(a, parseInt(b)), 0) + 1).toString(16);\n      this.filters[id] = {\n        type,\n        options,\n        lastBlock: parseInt((yield client.call('eth_blockNumber', [])))\n      };\n      return id;\n    });\n  }\n\n  handleIntern(request, client) {\n    switch (request.method) {\n      case 'eth_newFilter':\n        return this.addFilter(client, 'event', request.params[0]).then(result => ({\n          id: request.id,\n          jsonrpc: request.jsonrpc,\n          result\n        }));\n\n      case 'eth_newBlockFilter':\n        return this.addFilter(client, 'block', {}).then(result => ({\n          id: request.id,\n          jsonrpc: request.jsonrpc,\n          result\n        }));\n\n      case 'eth_newPendingTransactionFilter':\n        return this.addFilter(client, 'pending', {}).then(result => ({\n          id: request.id,\n          jsonrpc: request.jsonrpc,\n          result\n        }));\n\n      case 'eth_uninstallFilter':\n        return Promise.resolve({\n          id: request.id,\n          jsonrpc: request.jsonrpc,\n          result: !!this.removeFilter(request.params[0])\n        });\n\n      case 'eth_getFilterChanges':\n        return this.getFilterChanges(client, request.params[0]).then(result => ({\n          id: request.id,\n          jsonrpc: request.jsonrpc,\n          result\n        }));\n\n      default:\n        return null;\n    }\n  }\n\n  getFilterChanges(client, id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const filter = this.filters[id];\n      if (!filter) throw new Error('Filter with id ' + id + ' not found!');\n\n      if (filter.type === 'event') {\n        const _ref = yield client.send([{\n          jsonrpc: '2.0',\n          id: 1,\n          method: 'eth_blockNumber',\n          params: []\n        }, {\n          jsonrpc: '2.0',\n          id: 2,\n          method: 'eth_getLogs',\n          params: [Object.assign({}, filter.options, {\n            fromBlock: '0x' + filter.lastBlock.toString(16)\n          })]\n        }]).then(all => all[1].result ? all : [all[0], {\n          result: []\n        }]).then(util_1.checkForError).then(all => [parseInt(all[0].result), all[1].result]),\n              _ref2 = _slicedToArray(_ref, 2),\n              blockNumber = _ref2[0],\n              logs = _ref2[1];\n\n        filter.lastBlock = blockNumber + 1;\n        return logs;\n      } else if (filter.type === 'block') {\n        const bN = parseInt((yield client.call('eth_blockNumber', [])));\n\n        if (bN > filter.lastBlock) {\n          const requests = [];\n\n          for (let i = filter.lastBlock + 1; i <= bN; i++) requests.push({\n            jsonrpc: '2.0',\n            id: requests.length + 1,\n            method: 'eth_getBlockByNumber',\n            params: ['0x' + i.toString(16), false]\n          });\n\n          filter.lastBlock = bN;\n          return client.send(requests).then(r => r.map(_ => _.result.hash));\n        }\n\n        return [];\n      }\n    });\n  }\n\n  removeFilter(id) {\n    const res = !!this.filters[id];\n    delete this.filters[id];\n    return res;\n  }\n\n}\n\nexports.default = Filters;","map":null,"metadata":{},"sourceType":"script"}