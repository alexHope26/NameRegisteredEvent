{"ast":null,"code":"\"use trict\";\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bytes_1 = require(\"@ethersproject/bytes\");\n\nvar bignumber_1 = require(\"@ethersproject/bignumber\");\n\nvar properties_1 = require(\"@ethersproject/properties\");\n\nvar logger_1 = require(\"@ethersproject/logger\");\n\nvar _version_1 = require(\"../_version\");\n\nvar logger = new logger_1.Logger(_version_1.version);\n\nvar Coder =\n/** @class */\nfunction () {\n  function Coder(name, type, localName, dynamic) {\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  Coder.prototype._throwError = function (message, value) {\n    logger.throwArgumentError(message, this.localName, value);\n  };\n\n  return Coder;\n}();\n\nexports.Coder = Coder;\n\nvar Writer =\n/** @class */\nfunction () {\n  function Writer(wordSize) {\n    properties_1.defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = bytes_1.arrayify([]);\n    this._padding = new Uint8Array(wordSize);\n  }\n\n  Object.defineProperty(Writer.prototype, \"data\", {\n    get: function () {\n      return bytes_1.hexlify(this._data);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Writer.prototype, \"length\", {\n    get: function () {\n      return this._data.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Writer.prototype._writeData = function (data) {\n    this._data = bytes_1.concat([this._data, data]);\n    return data.length;\n  }; // Arrayish items; padded on the right to wordSize\n\n\n  Writer.prototype.writeBytes = function (value) {\n    var bytes = bytes_1.arrayify(value);\n\n    if (bytes.length % this.wordSize) {\n      bytes = bytes_1.concat([bytes, this._padding.slice(bytes.length % this.wordSize)]);\n    }\n\n    return this._writeData(bytes);\n  };\n\n  Writer.prototype._getValue = function (value) {\n    var bytes = bytes_1.arrayify(bignumber_1.BigNumber.from(value));\n\n    if (bytes.length > this.wordSize) {\n      logger.throwError(\"value out-of-bounds\", logger_1.Logger.errors.BUFFER_OVERRUN, {\n        length: this.wordSize,\n        offset: bytes.length\n      });\n    }\n\n    if (bytes.length % this.wordSize) {\n      bytes = bytes_1.concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n    }\n\n    return bytes;\n  }; // BigNumberish items; padded on the left to wordSize\n\n\n  Writer.prototype.writeValue = function (value) {\n    return this._writeData(this._getValue(value));\n  };\n\n  Writer.prototype.writeUpdatableValue = function () {\n    var _this = this;\n\n    var offset = this.length;\n    this.writeValue(0);\n    return function (value) {\n      _this._data.set(_this._getValue(value), offset);\n    };\n  };\n\n  return Writer;\n}();\n\nexports.Writer = Writer;\n\nvar Reader =\n/** @class */\nfunction () {\n  function Reader(data, wordSize, coerceFunc) {\n    properties_1.defineReadOnly(this, \"_data\", bytes_1.arrayify(data));\n    properties_1.defineReadOnly(this, \"wordSize\", wordSize || 32);\n    properties_1.defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    this._offset = 0;\n  }\n\n  Object.defineProperty(Reader.prototype, \"data\", {\n    get: function () {\n      return bytes_1.hexlify(this._data);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reader.prototype, \"consumed\", {\n    get: function () {\n      return this._offset;\n    },\n    enumerable: true,\n    configurable: true\n  }); // The default Coerce function\n\n  Reader.coerce = function (name, value) {\n    var match = name.match(\"^u?int([0-9]+)$\");\n\n    if (match && parseInt(match[1]) <= 48) {\n      value = value.toNumber();\n    }\n\n    return value;\n  };\n\n  Reader.prototype.coerce = function (name, value) {\n    if (this._coerceFunc) {\n      return this._coerceFunc(name, value);\n    }\n\n    return Reader.coerce(name, value);\n  };\n\n  Reader.prototype._peekBytes = function (offset, length) {\n    var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n\n    if (this._offset + alignedLength > this._data.length) {\n      logger.throwError(\"data out-of-bounds\", logger_1.Logger.errors.BUFFER_OVERRUN, {\n        length: this._data.length,\n        offset: this._offset + alignedLength\n      });\n    }\n\n    return this._data.slice(this._offset, this._offset + alignedLength);\n  };\n\n  Reader.prototype.subReader = function (offset) {\n    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc);\n  };\n\n  Reader.prototype.readBytes = function (length) {\n    var bytes = this._peekBytes(0, length);\n\n    this._offset += bytes.length; // @TODO: Make sure the length..end bytes are all 0?\n\n    return bytes.slice(0, length);\n  };\n\n  Reader.prototype.readValue = function () {\n    return bignumber_1.BigNumber.from(this.readBytes(this.wordSize));\n  };\n\n  return Reader;\n}();\n\nexports.Reader = Reader;","map":null,"metadata":{},"sourceType":"script"}