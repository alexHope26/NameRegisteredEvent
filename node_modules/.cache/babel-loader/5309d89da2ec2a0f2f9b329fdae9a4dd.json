{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst serialize_1 = require(\"./serialize\");\n\nconst util_1 = require(\"../../util/util\");\n\nconst DeltaHistory_1 = require(\"../../util/DeltaHistory\");\n\nconst merkleProof_1 = require(\"../../util/merkleProof\");\n\nconst secp256k1_1 = require(\"secp256k1\");\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst abi_1 = require(\"@ethersproject/abi\");\n/**\n * verify a Blockheader and returns the percentage of finality\n * @param blocks\n * @param getChainSpec\n */\n\n\nfunction checkBlockSignatures(blockHeaders, getChainSpec) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // parse blockHeaders\n    const blocks = blockHeaders.map(_ => _ instanceof serialize_1.Block ? _ : new serialize_1.Block(_)); // order blocks to make sure their hashes are connected\n\n    for (let i = 1; i < blocks.length; i++) {\n      if (!blocks[i - 1].hash().equals(blocks[i].parentHash)) throw new Error('The finality-Block does match the parentHash');\n    } // authority_round\n\n\n    const chainSpec = yield getChainSpec(blocks[0]);\n    const signatures = []; // we only check signatures for authorityRound\n\n    if (!chainSpec || !chainSpec.spec || chainSpec.spec.engine !== 'authorityRound' && chainSpec.spec.engine !== 'clique') return 0; // process all blockheaders and collect their signatures\n\n    yield Promise.all(blocks.map(data => __awaiter(this, void 0, void 0, function* () {\n      // read the current Validators\n      const chain = data === blocks[0] ? chainSpec : yield getChainSpec(data);\n      let signer = null;\n\n      if (chainSpec.spec.engine === 'clique') {\n        signer = getCliqueSigner(new serialize_1.Block(data.serializeHeader()));\n        if (!chain.authorities.find(_ => signer.equals(_))) throw new Error('the author is not part of the clique authorities');\n      } else {\n        // author needs to be a authority\n        if (!chain.authorities.find(_ => data.coinbase.equals(_))) throw new Error('the author is not part of the aura authorities'); // check signature\n\n        signer = getSigner(data);\n        if (!signer || !data.coinbase.equals(signer)) throw new Error('Wrong signature for the blockheader');\n      }\n\n      const s = signer.toString('hex');\n      if (signatures.indexOf(s) < 0) signatures.push(s);\n    }))); // return the finality as percent\n\n    return Math.round(signatures.length * 100 / chainSpec.authorities.length);\n  });\n}\n\nexports.checkBlockSignatures = checkBlockSignatures;\n\nfunction getSigner(data) {\n  const signature = data.sealedFields[1];\n  const message = data.sealedFields.length === 3 ? serialize_1.hash(Buffer.concat([data.bareHash(), serialize_1.rlp.encode(data.sealedFields[2])])) : data.bareHash();\n  return ethereumjs_util_1.publicToAddress(secp256k1_1.recover(message, signature.slice(0, 64), signature[64]), true);\n}\n\nexports.getSigner = getSigner;\n\nfunction getCliqueSigner(data) {\n  const sig = data.extra.slice(data.extra.length - 65, data.extra.length);\n  data.raw[12] = data.extra.slice(0, data.extra.length - 65);\n  return ethereumjs_util_1.publicToAddress(secp256k1_1.recover(data.hash(), sig.slice(0, 64), sig[64]), true);\n}\n\nfunction addCliqueValidators(history, ctx, states) {\n  const epoch = ctx.chainSpec.epoch || 30000;\n\n  for (const s of states) {\n    const current = [...history.getData(s.block)];\n    if (JSON.stringify(current) === JSON.stringify(s.validators)) continue;\n    const add = s.validators.length > current.length;\n    const ep = Math.floor(s.block / epoch);\n    let proofCount = 0;\n    let newValidator = null;\n    let verified = false;\n\n    for (const p of s.proof) {\n      const block = new serialize_1.Block(p);\n      const signer = '0x' + getCliqueSigner(block).toString('hex');\n      if (current.indexOf(signer) < 0) continue; // this is no proof!\n\n      if (block.sealedFields[1].toString('hex') !== (add ? 'ffffffffffffffff' : '0000000000000000')) continue; // wrong proof\n\n      if (Math.floor(util_1.toNumber(block.number) / epoch) != ep) continue; // wrong epoch\n\n      if (block.coinbase.toString('hex') == '0000000000000000000000000000000000000000') continue; // wrong validator\n\n      if (!newValidator) newValidator = block.coinbase;else if (!newValidator.equals(block.coinbase)) continue; // wrong validator\n\n      proofCount++;\n\n      if (proofCount == Math.floor(current.length / 2) + 1) {\n        const nv = '0x' + newValidator.toString('hex');\n        verified = add ? current.indexOf(nv) < 0 && s.validators.indexOf(nv) >= 0 : current.indexOf(nv) >= 0 && s.validators.indexOf(nv) < 0;\n        break;\n      }\n    }\n\n    if (verified) history.addState(s.block, s.validators);\n  }\n}\n\nfunction addAuraValidators(history, ctx, states, contract) {\n  return __awaiter(this, void 0, void 0, function* () {\n    for (const s of states) {\n      //skip the current block if already added in the delta\n      const current = history.getData(s.block).map(h => serialize_1.address(h.startsWith('0x') ? h : '0x' + h));\n      if (Buffer.concat(current).equals(Buffer.concat(s.validators.map(serialize_1.address)))) continue;\n      if (!s.proof) throw new Error('The validator list has no proof');\n      const proof = s.proof;\n      const block = serialize_1.blockFromHex(proof.block); //get the required finality from the default config of the client\n\n      const reqFinality = ctx.client && ctx.client.defConfig && ctx.client.defConfig.finality;\n      checkForFinality(util_1.toNumber(s.block), proof, current, reqFinality); // now check the receipt\n\n      const receipt = serialize_1.rlp.decode((yield merkleProof_1.default(block.receiptTrie, // expected merkle root\n      serialize_1.rlp.encode(proof.txIndex), // path, which is the transsactionIndex\n      proof.proof.map(serialize_1.bytes), // array of Buffer with the merkle-proof-data\n      undefined // we don't want to check, but use the found value in the next step\n      )));\n      const logData = receipt[receipt.length - 1][proof.logIndex];\n      if (!logData) throw new Error('Validator changeLog not found in Transaction'); //check for contract address from chain spec\n\n      if (!logData[0].equals(serialize_1.address(contract))) throw new Error('Wrong address in log '); //check for the standard topic \"0x55252fa6eee4741b4e24a74a70e9c11fd2c2281df8d6ea13126ff845f7825c89\"\n\n      if (!logData[1][0].equals(serialize_1.bytes32('0x55252fa6eee4741b4e24a74a70e9c11fd2c2281df8d6ea13126ff845f7825c89'))) throw new Error('Wrong Topics in log '); //check the list\n\n      const abiCoder = new abi_1.AbiCoder();\n      if (!logData[2].equals(serialize_1.bytes(abiCoder.encode(['address[]'], [s.validators.map(v => v.startsWith('0x') ? v : '0x' + v)])))) throw new Error('Wrong data in log ');\n      history.addState(util_1.toNumber(s.block), s.validators);\n    }\n  });\n}\n\nfunction checkForValidators(ctx, validators) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (ctx.chainSpec && ctx.chainSpec.length) {\n      const list = yield ctx.client.sendRPC('in3_validatorlist', [validators.data.length, null], ctx.chainId, {\n        proof: 'none'\n      });\n      if (list && list.result && list.result.states) for (const state of list.result.states) {\n        const spec = ctx.getChainSpec(state.block);\n        if (spec && spec.engine === 'authorityRound') yield addAuraValidators(validators, ctx, [state], spec.contract);else if (spec && spec.engine === 'clique') yield addCliqueValidators(validators, ctx, [state]);\n      } else throw new Error('Could not get the new validatorlist! ' + (list && JSON.stringify(list.error)));\n      ctx.putInCache('validators', JSON.stringify(validators.toDeltaStrings()));\n    }\n  });\n}\n\nfunction checkForFinality(stateBlockNumber, proof, current, _finality) {\n  // decode the blockheader\n  const block = serialize_1.blockFromHex(proof.block);\n  const finalitySigners = [];\n  let parentHash = block.parentHash;\n  let lastFinalityBlock = null;\n\n  for (const b of [block, ...(proof.finalityBlocks || []).map(serialize_1.blockFromHex)]) {\n    if (!parentHash.equals(b.parentHash)) throw new Error('Invalid ParentHash');\n    const signer = getSigner(b);\n    const proposer = current[b.sealedFields[0].readUInt32BE(0) % current.length];\n    if (!Buffer.concat(current).includes(signer)) throw new Error('Block was signed by the wrong validator');\n    if (!finalitySigners.find(_ => _.equals(signer))) finalitySigners.push(signer);\n    parentHash = b.hash();\n    lastFinalityBlock = util_1.toNumber(b.number);\n  }\n\n  if (finalitySigners.length / current.length < _finality) throw new Error(\"Cannot reach finality. Required: \" + _finality + \" Reached: \" + finalitySigners.length / current.length); //verify finality block number\n\n  if (stateBlockNumber !== lastFinalityBlock + 1) throw new Error(\"Block Number in state doesn't match with finality blocks\");\n}\n\nfunction getChainSpec(b, ctx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let validators = null;\n    const cache = ctx.getFromCache('validators');\n\n    if (cache) {\n      try {\n        validators = new DeltaHistory_1.default(JSON.parse(cache), true);\n      } catch (x) {}\n    } // no validators in the cache yet, so we have to find them.\n\n\n    if (!validators && ctx.chainSpec && ctx.chainSpec.length) {\n      validators = new DeltaHistory_1.default([], false);\n      let list = null;\n\n      for (const spec of ctx.chainSpec) {\n        if (spec.list && !spec.requiresFinality) validators.addState(spec.block, spec.list);\n\n        if (spec.contract || spec.engine == 'clique') {\n          if (!list) list = ctx.client ? yield ctx.client.sendRPC('in3_validatorlist', [validators.data.length, null], ctx.chainId, {\n            proof: 'none'\n          }) : {\n            result: {\n              states: []\n            }\n          };\n          /* check if the transition also has a list if it does then we have to for\n          finality to add that list to the history. */\n\n          if (spec.list && spec.requiresFinality) {\n            if (spec.bypassFinality) {\n              validators.addState(spec.bypassFinality, spec.list);\n              continue;\n            }\n\n            const transitionState = list.result && list.result.states && list.result.states.filter(s => {\n              if (s.block <= spec.block) {\n                return false;\n              }\n\n              if (!s.proof) return false;\n              const proof = s.proof;\n              const block = serialize_1.blockFromHex(proof.block);\n\n              if (util_1.toNumber(block.number) !== spec.block) {\n                return false;\n              }\n\n              return true;\n            });\n            if (!transitionState || !transitionState.length) continue;\n            const current = validators.getData(transitionState[0].block).map(h => serialize_1.address(h.startsWith('0x') ? h : '0x' + h));\n            if (Buffer.concat(current).equals(Buffer.concat(transitionState[0].validators.map(serialize_1.address)))) continue;\n            if (!transitionState[0].proof) throw new Error('The validator list has no proof');\n            const proof = transitionState[0].proof;\n            checkForFinality(util_1.toNumber(transitionState[0].block), proof, current, 0.51);\n            validators.addState(util_1.toNumber(transitionState[0].block), transitionState[0].validators);\n            continue;\n          }\n\n          const nextBlock = (ctx.chainSpec[ctx.chainSpec.indexOf(spec) + 1] || {\n            block: Number.MAX_VALUE\n          }).block;\n          const filteredList = list.result && list.result.states && list.result.states.filter(s => s.block < nextBlock && s.block >= spec.block);\n          if (spec.engine === 'authorityRound') yield addAuraValidators(validators, ctx, filteredList, spec.contract);else if (spec.engine === 'clique') yield addCliqueValidators(validators, ctx, filteredList);\n        }\n      }\n\n      ctx.putInCache('validators', JSON.stringify(validators.toDeltaStrings()));\n    } else if (!ctx.chainSpec || !ctx.chainSpec.length) return {\n      authorities: [],\n      proposer: null,\n      spec: null\n    };\n\n    const blockNumber = util_1.toNumber(b.number);\n    const spec = ctx.chainSpec && ctx.chainSpec.find(_ => _.block <= blockNumber);\n    if (!spec) return {\n      authorities: [],\n      proposer: null,\n      spec: null\n    }; //if there is an update in the validator list then get it\n\n    if (ctx.lastValidatorChange > validators.getLastIndex()) yield checkForValidators(ctx, validators); // get the current validator-list for the block\n\n    const res = {\n      authorities: validators.getData(util_1.toNumber(b.number)).map(h => serialize_1.address(h.startsWith('0x') ? h : '0x' + h)),\n      spec\n    }; // find out who is able to sign with this nonce\n\n    res.proposer = res.authorities[(spec.engine == 'clique' ? util_1.toNumber(b.number) : b.sealedFields[0].readUInt32BE(0)) % res.authorities.length];\n    if (spec.engine == 'clique' && util_1.toNumber(b.difficulty) === 1) res.proposer = null;\n    return res;\n  });\n}\n\nexports.getChainSpec = getChainSpec;","map":null,"metadata":{},"sourceType":"script"}