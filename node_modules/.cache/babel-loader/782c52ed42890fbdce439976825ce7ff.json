{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/edgarrodriguezzavala/Workspace/programing-test-named-registered/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ChainContext_1 = require(\"../../client/ChainContext\");\n\nconst filter_1 = require(\"./filter\");\n\nconst serialize_1 = require(\"./serialize\");\n\nconst util_1 = require(\"../../util/util\");\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst Buffer = require('buffer').Buffer;\n\nclass EthChainContext extends ChainContext_1.default {\n  constructor(client, chainId, chainSpec) {\n    super(client, chainId, chainSpec);\n    this.filters = new filter_1.default();\n  }\n\n  handleIntern(request) {\n    return this.filters.handleIntern(request, this.client);\n  }\n\n  getCodeFor(addresses, block = 'latest') {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = addresses.map(a => this.codeCache.get(a));\n      const missing = result.map((_, i) => _ ? null : {\n        method: 'eth_getCode',\n        params: [util_1.toHex(addresses[i], 20), block[0] === 'l' ? block : util_1.toMinHex(block)],\n        id: i + 1,\n        jsonrpc: '2.0'\n      }).filter(_ => _);\n\n      if (missing.length) {\n        for (const r of yield this.client.send(missing, undefined, {\n          proof: 'none',\n          signatureCount: 0,\n          chainId: this.chainId\n        })) {\n          const i = r.id - 1;\n          if (r.error) throw new Error(' could not get the code for address ' + addresses[i] + ' : ' + r.error);\n          this.codeCache.put(addresses[i], serialize_1.bytes(result[i] = r.result));\n        }\n\n        if (this.client.defConfig.cacheStorage && this.chainId) this.client.defConfig.cacheStorage.setItem('in3.code.' + this.chainId, this.codeCache.toStorage());\n      }\n\n      return result;\n    });\n  }\n\n  getLastBlockHashes() {\n    return this.blockCache.map(_ => util_1.toHex(_.hash));\n  }\n\n  getBlockHeader(blockNumber) {\n    const b = this.blockCache.length && this.blockCache.find(_ => _.number === blockNumber);\n    return b ? b.header : null;\n  }\n\n  getBlockHeaderByHash(blockHash) {\n    const b = this.blockCache.length && this.blockCache.find(_ => _.hash.equals(blockHash));\n    return b ? b.header : null;\n  }\n\n  addBlockHeader(blockNumber, header) {\n    if (!this.client.defConfig.maxBlockCache || header.equals(this.getBlockHeader(blockNumber) || Buffer.allocUnsafe(0))) return header;\n\n    while (this.blockCache.length >= this.client.defConfig.maxBlockCache && this.blockCache.length) this.blockCache.splice(this.blockCache.reduce((p, c, i, a) => c.number < a[i].number ? i : p, 0), 1);\n\n    this.blockCache.push({\n      number: blockNumber,\n      header,\n      hash: ethereumjs_util_1.keccak(header)\n    });\n    this.client.defConfig.verifiedHashes = this.getLastBlockHashes();\n    return header;\n  }\n\n  initCache() {\n    super.initCache();\n    this.codeCache = new CacheNode(this.client.defConfig.maxCodeCache || 100000);\n    this.blockCache = [];\n    const chainId = this.chainId;\n\n    if (this.client.defConfig.cacheStorage && chainId) {\n      // read codeCache\n      const codeCache = this.client.defConfig.cacheStorage.getItem('in3.code.' + chainId);\n\n      try {\n        if (codeCache) this.codeCache.fromStorage(codeCache);\n      } catch (ex) {\n        this.client.defConfig.cacheStorage.setItem('in3.code.' + chainId, '');\n      }\n    }\n  }\n\n}\n\nexports.default = EthChainContext;\n\nclass CacheNode {\n  constructor(limit) {\n    this.limit = limit;\n    this.dataLength = 0;\n    this.data = new Map();\n  }\n\n  get(key) {\n    const entry = this.data.get(key.toString('hex'));\n    return entry ? entry.data : null;\n  }\n\n  put(key, val) {\n    const old = this.get(key);\n\n    if (old) {\n      this.dataLength -= this.getByteLength(old);\n      this.data.delete(key.toString('hex'));\n    }\n\n    const size = this.getByteLength(val);\n\n    while (this.limit && !old && this.dataLength + size >= this.limit) {\n      let oldestKey = null;\n      let oldestVal = {\n        added: Date.now(),\n        data: null\n      };\n\n      for (const _ref of this.data.entries()) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        const k = _ref2[0];\n        const v = _ref2[1];\n\n        if (v.added < oldestVal.added) {\n          oldestVal = v;\n          oldestKey = k;\n        }\n      }\n\n      if (!oldestKey) break;\n      this.data.delete(oldestKey);\n      this.dataLength -= this.getByteLength(oldestVal.data);\n    }\n\n    this.data.set(key.toString('hex'), {\n      added: Date.now(),\n      data: val\n    });\n    this.dataLength += this.getByteLength(val);\n  }\n\n  getByteLength(entry) {\n    if (Buffer.isBuffer(entry)) return entry.length;\n    if (typeof entry === 'string') return entry.length * 2;\n    return 4;\n  }\n\n  toStorage() {\n    const entries = [];\n    this.data.forEach((val, key) => {\n      entries.push(Buffer.from(key, 'hex'));\n      entries.push(val.data);\n    });\n    return serialize_1.rlp.encode(entries).toString('base64');\n  }\n\n  fromStorage(data) {\n    const entries = serialize_1.rlp.decode(Buffer.from(data, 'base64'));\n\n    for (let i = 0; i < entries.length; i += 2) this.put(entries[i], entries[i + 1]);\n  }\n\n}\n\nexports.CacheNode = CacheNode;","map":null,"metadata":{},"sourceType":"script"}