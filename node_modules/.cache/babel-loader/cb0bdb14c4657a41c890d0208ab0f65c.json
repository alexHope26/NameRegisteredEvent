{"ast":null,"code":"'use strict';\n\nvar utils = require('ethereumjs-util');\n\nvar BN = utils.BN;\n\nvar error = require('../exceptions.js').ERROR;\n\nvar fees = require('ethereum-common');\n\nvar assert = require('assert');\n\nvar Gquaddivisor = fees.modexpGquaddivisor.v;\n\nfunction multComplexity(x) {\n  var fac1 = new BN(0);\n  var fac2 = new BN(0);\n\n  if (x.lten(64)) {\n    return x.sqr();\n  } else if (x.lten(1024)) {\n    // return Math.floor(Math.pow(x, 2) / 4) + 96 * x - 3072\n    fac1 = x.sqr().divn(4);\n    fac2 = x.muln(96);\n    return fac1.add(fac2).subn(3072);\n  } else {\n    // return Math.floor(Math.pow(x, 2) / 16) + 480 * x - 199680\n    fac1 = x.sqr().divn(16);\n    fac2 = x.muln(480);\n    return fac1.add(fac2).subn(199680);\n  }\n}\n\nfunction getAdjustedExponentLength(data) {\n  var baseLen = new BN(data.slice(0, 32)).toNumber();\n  var expLen = new BN(data.slice(32, 64));\n  var expBytesStart = 96 + baseLen; // 96 for base length, then exponent length, and modulus length, then baseLen for the base data, then exponent bytes start\n\n  var firstExpBytes = Buffer.from(data.slice(expBytesStart, expBytesStart + 32)); // first word of the exponent data\n\n  firstExpBytes = utils.setLengthRight(firstExpBytes, 32); // reading past the data reads virtual zeros\n\n  firstExpBytes = new BN(firstExpBytes);\n  var max32expLen = 0;\n\n  if (expLen.ltn(32)) {\n    max32expLen = 32 - expLen.toNumber();\n  }\n\n  firstExpBytes = firstExpBytes.shrn(8 * Math.max(max32expLen, 0));\n  var bitLen = -1;\n\n  while (firstExpBytes.gtn(0)) {\n    bitLen = bitLen + 1;\n    firstExpBytes = firstExpBytes.ushrn(1);\n  }\n\n  var expLenMinus32OrZero = expLen.subn(32);\n\n  if (expLenMinus32OrZero.ltn(0)) {\n    expLenMinus32OrZero = new BN(0);\n  }\n\n  var eightTimesExpLenMinus32OrZero = expLenMinus32OrZero.muln(8);\n  var adjustedExpLen = eightTimesExpLenMinus32OrZero;\n\n  if (bitLen > 0) {\n    adjustedExpLen.iaddn(bitLen);\n  }\n\n  return adjustedExpLen;\n} // Taken from https://stackoverflow.com/a/1503019\n\n\nfunction expmod(B, E, M) {\n  if (E.isZero()) return new BN(1).mod(M);\n  var BM = B.mod(M);\n  var R = expmod(BM, E.divn(2), M);\n  R = R.mul(R).mod(M);\n  if (E.mod(new BN(2)).isZero()) return R;\n  return R.mul(BM).mod(M);\n}\n\nfunction getOOGResults(opts, results) {\n  results.gasUsed = opts.gasLimit;\n  results.exception = 0; // 0 means VM fail (in this case because of OOG)\n\n  results.exceptionError = error.OUT_OF_GAS;\n  return results;\n}\n\nmodule.exports = function (opts) {\n  assert(opts.data);\n  var results = {};\n  var data = opts.data;\n  var adjustedELen = getAdjustedExponentLength(data);\n\n  if (adjustedELen.ltn(1)) {\n    adjustedELen = new BN(1);\n  }\n\n  var bLen = new BN(data.slice(0, 32));\n  var eLen = new BN(data.slice(32, 64));\n  var mLen = new BN(data.slice(64, 96));\n  var maxLen = bLen;\n\n  if (maxLen.lt(mLen)) {\n    maxLen = mLen;\n  }\n\n  var gasUsed = adjustedELen.mul(multComplexity(maxLen)).divn(Gquaddivisor);\n\n  if (opts.gasLimit.lt(gasUsed)) {\n    return getOOGResults(opts, results);\n  }\n\n  results.gasUsed = gasUsed;\n\n  if (bLen.isZero()) {\n    results.return = new BN(0).toArrayLike(Buffer, 'be', 1);\n    results.exception = 1;\n    return results;\n  }\n\n  if (mLen.isZero()) {\n    results.return = Buffer.from([0]);\n    results.exception = 1;\n    return results;\n  }\n\n  var maxInt = new BN(Number.MAX_SAFE_INTEGER);\n  var maxSize = new BN(2147483647); // ethereumjs-util setLengthRight limitation\n\n  if (bLen.gt(maxSize) || eLen.gt(maxSize) || mLen.gt(maxSize)) {\n    return getOOGResults(opts, results);\n  }\n\n  var bStart = new BN(96);\n  var bEnd = bStart.add(bLen);\n  var eStart = bEnd;\n  var eEnd = eStart.add(eLen);\n  var mStart = eEnd;\n  var mEnd = mStart.add(mLen);\n\n  if (mEnd.gt(maxInt)) {\n    return getOOGResults(opts, results);\n  }\n\n  bLen = bLen.toNumber();\n  eLen = eLen.toNumber();\n  mLen = mLen.toNumber();\n  var B = new BN(utils.setLengthRight(data.slice(bStart.toNumber(), bEnd.toNumber()), bLen));\n  var E = new BN(utils.setLengthRight(data.slice(eStart.toNumber(), eEnd.toNumber()), eLen));\n  var M = new BN(utils.setLengthRight(data.slice(mStart.toNumber(), mEnd.toNumber()), mLen)); // console.log('MODEXP input')\n  // console.log('B:', bLen, B)\n  // console.log('E:', eLen, E)\n  // console.log('M:', mLen, M)\n\n  var R;\n\n  if (M.isZero()) {\n    R = new BN(0);\n  } else {\n    R = expmod(B, E, M);\n  }\n\n  var result = R.toArrayLike(Buffer, 'be', mLen);\n  results.return = result;\n  results.exception = 1; // console.log('MODEXP output', result)\n\n  return results;\n};","map":null,"metadata":{},"sourceType":"script"}