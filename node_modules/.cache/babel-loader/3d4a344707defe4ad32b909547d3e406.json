{"ast":null,"code":"\"use strict\";\n/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst protons = require(\"protons\");\n\nconst multihashing = require(\"multihashing-async\");\n\nconst bs58 = require(\"bs58\");\n\nconst proto = protons(\"\\nmessage Data {\\n  enum DataType {\\n    Raw = 0;\\n    Directory = 1;\\n    File = 2;\\n    Metadata = 3;\\n    Symlink = 4;\\n    HAMTShard = 5;\\n  }\\n\\n  required DataType Type = 1;\\n  optional bytes Data = 2;\\n  optional uint64 filesize = 3;\\n  repeated uint64 blocksizes = 4;\\n\\n  optional uint64 hashType = 5;\\n  optional uint64 fanout = 6;\\n}\\n\\nmessage PBLink {\\n  optional bytes Hash = 1;\\n  optional string Name = 2;\\n  optional uint64 Tsize = 3;\\n}\\n\\n// An IPFS MerkleDAG Node\\nmessage PBNode {\\n  repeated PBLink Links = 2;\\n  optional bytes Data = 1;\\n}\\n\");\n/**\n * creates a IPFS-Hash from content\n * @param content\n */\n\nfunction createIPFSHash(content, hashAlg = 'sha2-256') {\n  return new Promise((resolve, reject) => {\n    // serialize content\n    const serialized = proto.PBNode.encode({\n      Data: proto.Data.encode({\n        Type: proto.Data.DataType.File,\n        Data: content,\n        filesize: content.length\n      }),\n      Links: null\n    });\n    multihashing(serialized, hashAlg, (err, multihash) => {\n      if (err) return reject(err);\n      resolve(bs58.encode(multihash));\n    });\n  });\n}\n\nexports.createIPFSHash = createIPFSHash;\n\nfunction verifyIPFSHash(content, encoding, requestedHash) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let reponseHash;\n\n    try {\n      reponseHash = yield createIPFSHash(Buffer.isBuffer(content) ? content : Buffer.from(content, encoding));\n    } catch (er) {\n      // TODO onlx in the react-native package he is not able to calculate the hash and throws, for now we ignore it, but we should find a solution to make it work there as well.\n      return true;\n    }\n\n    if (reponseHash !== requestedHash) throw new Error('The content verification failed, because the IPFS-Hash is wrong');\n    return true;\n  });\n}\n\nexports.verifyIPFSHash = verifyIPFSHash;","map":null,"metadata":{},"sourceType":"script"}