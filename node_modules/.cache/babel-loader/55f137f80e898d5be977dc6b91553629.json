{"ast":null,"code":"const utils = require('ethereumjs-util');\n\nconst params = require('ethereum-common/params.json');\n\nconst BN = utils.BN;\n/**\n * An object that repersents the block header\n * @constructor\n * @param {Array} data raw data, deserialized\n * @prop {Buffer} parentHash the blocks' parent's hash\n * @prop {Buffer} uncleHash sha3(rlp_encode(uncle_list))\n * @prop {Buffer} coinbase the miner address\n * @prop {Buffer} stateRoot The root of a Merkle Patricia tree\n * @prop {Buffer} transactionTrie the root of a Trie containing the transactions\n * @prop {Buffer} receiptTrie the root of a Trie containing the transaction Reciept\n * @prop {Buffer} bloom\n * @prop {Buffer} difficulty\n * @prop {Buffer} number the block's height\n * @prop {Buffer} gasLimit\n * @prop {Buffer} gasUsed\n * @prop {Buffer} timestamp\n * @prop {Buffer} extraData\n * @prop {Array.<Buffer>} raw an array of buffers containing the raw blocks.\n */\n\nvar BlockHeader = module.exports = function (data) {\n  var fields = [{\n    name: 'parentHash',\n    length: 32,\n    default: utils.zeros(32)\n  }, {\n    name: 'uncleHash',\n    default: utils.SHA3_RLP_ARRAY\n  }, {\n    name: 'coinbase',\n    length: 20,\n    default: utils.zeros(20)\n  }, {\n    name: 'stateRoot',\n    length: 32,\n    default: utils.zeros(32)\n  }, {\n    name: 'transactionsTrie',\n    length: 32,\n    default: utils.SHA3_RLP\n  }, {\n    name: 'receiptTrie',\n    length: 32,\n    default: utils.SHA3_RLP\n  }, {\n    name: 'bloom',\n    default: utils.zeros(256)\n  }, {\n    name: 'difficulty',\n    default: new Buffer([])\n  }, {\n    name: 'number',\n    default: utils.intToBuffer(params.homeSteadForkNumber.v)\n  }, {\n    name: 'gasLimit',\n    default: new Buffer('ffffffffffffff', 'hex')\n  }, {\n    name: 'gasUsed',\n    empty: true,\n    default: new Buffer([])\n  }, {\n    name: 'timestamp',\n    default: new Buffer([])\n  }, {\n    name: 'extraData',\n    allowZero: true,\n    empty: true,\n    default: new Buffer([])\n  }, {\n    name: 'mixHash',\n    default: utils.zeros(32) // length: 32\n\n  }, {\n    name: 'nonce',\n    default: new Buffer([]) // sha3(42)\n\n  }];\n  utils.defineProperties(this, fields, data);\n};\n/**\n * Returns the canoncical difficulty of the block\n * @method canonicalDifficulty\n * @param {Block} parentBlock the parent `Block` of the this header\n * @return {BN}\n */\n\n\nBlockHeader.prototype.canonicalDifficulty = function (parentBlock) {\n  const blockTs = new BN(this.timestamp);\n  const parentTs = new BN(parentBlock.header.timestamp);\n  const parentDif = new BN(parentBlock.header.difficulty);\n  const minimumDifficulty = new BN(params.minimumDifficulty.v);\n  var offset = parentDif.div(new BN(params.difficultyBoundDivisor.v));\n  var dif; // Byzantium\n  // max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99)\n\n  var uncleAddend = parentBlock.header.uncleHash.equals(utils.SHA3_RLP_ARRAY) ? 1 : 2;\n  var a = blockTs.sub(parentTs).idivn(9).ineg().iaddn(uncleAddend);\n  var cutoff = new BN(-99); // MAX(cutoff, a)\n\n  if (cutoff.cmp(a) === 1) {\n    a = cutoff;\n  }\n\n  dif = parentDif.add(offset.mul(a)); // Byzantium difficulty bomb delay\n\n  var num = new BN(this.number).isubn(3000000);\n\n  if (num.ltn(0)) {\n    num = new BN(0);\n  }\n\n  var exp = num.idivn(100000).isubn(2);\n\n  if (!exp.isNeg()) {\n    dif.iadd(new BN(2).pow(exp));\n  }\n\n  if (dif.cmp(minimumDifficulty) === -1) {\n    dif = minimumDifficulty;\n  }\n\n  return dif;\n};\n/**\n * checks that the block's `difficuly` matches the canonical difficulty\n * @method validateDifficulty\n * @param {Block} parentBlock this block's parent\n * @return {Boolean}\n */\n\n\nBlockHeader.prototype.validateDifficulty = function (parentBlock) {\n  const dif = this.canonicalDifficulty(parentBlock);\n  return dif.cmp(new BN(this.difficulty)) === 0;\n};\n/**\n * Validates the gasLimit\n * @method validateGasLimit\n * @param {Block} parentBlock this block's parent\n * @returns {Boolean}\n */\n\n\nBlockHeader.prototype.validateGasLimit = function (parentBlock) {\n  const pGasLimit = new BN(parentBlock.header.gasLimit);\n  const gasLimit = new BN(this.gasLimit);\n  const a = pGasLimit.div(new BN(params.gasLimitBoundDivisor.v));\n  const maxGasLimit = pGasLimit.add(a);\n  const minGasLimit = pGasLimit.sub(a);\n  return gasLimit.lt(maxGasLimit) && gasLimit.gt(minGasLimit) && gasLimit.gte(params.minGasLimit.v);\n};\n/**\n * Validates the entire block header\n * @method validate\n * @param {Blockchain} blockChain the blockchain that this block is validating against\n * @param {Bignum} [height] if this is an uncle header, this is the height of the block that is including it\n * @param {Function} cb the callback function. The callback is given an `error` if the block is invalid\n */\n\n\nBlockHeader.prototype.validate = function (blockchain, height, cb) {\n  var self = this;\n\n  if (arguments.length === 2) {\n    cb = height;\n    height = false;\n  }\n\n  if (this.isGenesis()) {\n    return cb();\n  } // find the blocks parent\n\n\n  blockchain.getBlock(self.parentHash, function (err, parentBlock) {\n    if (err) {\n      return cb('could not find parent block');\n    }\n\n    self.parentBlock = parentBlock;\n    var number = new BN(self.number);\n\n    if (number.cmp(new BN(parentBlock.header.number).iaddn(1)) !== 0) {\n      return cb('invalid number');\n    }\n\n    if (height) {\n      var dif = height.sub(new BN(parentBlock.header.number));\n\n      if (!(dif.cmpn(8) === -1 && dif.cmpn(1) === 1)) {\n        return cb('uncle block has a parent that is too old or to young');\n      }\n    }\n\n    if (!self.validateDifficulty(parentBlock)) {\n      return cb('invalid Difficulty');\n    }\n\n    if (!self.validateGasLimit(parentBlock)) {\n      return cb('invalid gas limit');\n    }\n\n    if (utils.bufferToInt(parentBlock.header.number) + 1 !== utils.bufferToInt(self.number)) {\n      return cb('invalid heigth');\n    }\n\n    if (utils.bufferToInt(self.timestamp) <= utils.bufferToInt(parentBlock.header.timestamp)) {\n      return cb('invalid timestamp');\n    }\n\n    if (self.extraData.length > params.maximumExtraDataSize.v) {\n      return cb('invalid amount of extra data');\n    }\n\n    cb();\n  });\n};\n/**\n * Returns the sha3 hash of the blockheader\n * @method hash\n * @return {Buffer}\n */\n\n\nBlockHeader.prototype.hash = function () {\n  return utils.rlphash(this.raw);\n};\n/**\n * checks if the blockheader is a genesis header\n * @method isGenesis\n * @return {Boolean}\n */\n\n\nBlockHeader.prototype.isGenesis = function () {\n  return this.number.toString('hex') === '';\n};","map":null,"metadata":{},"sourceType":"script"}