{"ast":null,"code":"\"use strict\";\n/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it    *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // this is eded in order to run in browsers\n\nconst Buffer = require('buffer').Buffer;\n\nconst ethUtil = require(\"ethereumjs-util\");\n\nconst BN = ethUtil.BN;\n\nconst fixLength = hex => hex.length % 2 ? '0' + hex : hex;\n/**\n *\n * simple promisy-function\n */\n\n\nfunction promisify(self, fn, ...args) {\n  return new Promise((resolve, reject) => {\n    fn.apply(self, [...args, (err, res) => {\n      if (err) reject(err);else resolve(res);\n    }]);\n  });\n}\n\nexports.promisify = promisify;\n\nfunction toUtf8(val) {\n  if (!val) return val;\n  if (typeof val === 'string') return val.startsWith('0x') ? Buffer.from(val.substr(2), 'hex').toString('utf8') : val;\n  return val.toString('utf8');\n}\n\nexports.toUtf8 = toUtf8;\n/**\n * check a RPC-Response for errors and rejects the promise if found\n */\n\nfunction checkForError(res) {\n  if (Array.isArray(res)) return res.find(_ => !!_.error) ? Promise.reject(new Error(res.find(_ => !!_.error).error)) : res;\n  return res.error ? Promise.reject(new Error(res.error)) : res;\n}\n\nexports.checkForError = checkForError;\n/**\n * convert to BigNumber\n */\n\nfunction toBN(val) {\n  if (BN.isBN(val)) return val;\n  if (val && val._isBigNumber) val = val.toHexString();\n  if (typeof val === 'number') return new BN(Math.round(val).toString());\n  if (Buffer.isBuffer(val)) return new BN(val);\n  return new BN(toHex(val).substr(2), 16);\n}\n\nexports.toBN = toBN;\n/**\n * converts any value as hex-string\n */\n\nfunction toHex(val, bytes) {\n  if (val === undefined) return undefined;\n  let hex;\n  if (typeof val === 'string') hex = val.startsWith('0x') ? val.substr(2) : parseInt(val[0]) ? new BN(val).toString(16) : Buffer.from(val, 'utf8').toString('hex');else if (typeof val === 'number') hex = val.toString(16);else if (BN.isBN(val)) hex = val.toString(16);else if (val && val._isBigNumber) hex = val.toHexString();else hex = ethUtil.bufferToHex(val).substr(2);\n  if (bytes) hex = padStart(hex, bytes * 2, '0'); // workarounf for ts-error in older js\n\n  if (hex.length % 2) hex = '0' + hex;\n  return '0x' + hex.toLowerCase();\n}\n\nexports.toHex = toHex;\n/**\n * converts to a js-number\n */\n\nfunction toNumber(val) {\n  switch (typeof val) {\n    case 'number':\n      return val;\n\n    case 'string':\n      return parseInt(val);\n\n    default:\n      if (Buffer.isBuffer(val)) return val.length == 0 ? 0 : parseInt(toMinHex(val));else if (BN.isBN(val)) return val.bitLength() > 53 ? toNumber(val.toArrayLike(Buffer)) : val.toNumber();else if (val && val._isBigNumber) try {\n        return val.toNumber();\n      } catch (ex) {\n        return toNumber(val.toHexString());\n      } else if (val === undefined || val === null) return 0;\n      throw new Error('can not convert a ' + typeof val + ' to number');\n  }\n}\n\nexports.toNumber = toNumber;\n/**\n * converts any value as Buffer\n *  if len === 0 it will return an empty Buffer if the value is 0 or '0x00', since this is the way rlpencode works wit 0-values.\n */\n\nfunction toBuffer(val, len = -1) {\n  if (val && val._isBigNumber) val = val.toHexString();\n  if (typeof val == 'string') val = val.startsWith('0x') ? Buffer.from((val.length % 2 ? '0' : '') + val.substr(2), 'hex') : val.length && (parseInt(val) || val == '0') ? new BN(val).toArrayLike(Buffer) : Buffer.from(val, 'utf8');else if (typeof val == 'number') val = val === 0 && len === 0 ? Buffer.allocUnsafe(0) : Buffer.from(fixLength(val.toString(16)), 'hex');else if (BN.isBN(val)) val = val.toArrayLike(Buffer);\n  if (!val) val = Buffer.allocUnsafe(0); // since rlp encodes an empty array for a 0 -value we create one if the required len===0\n\n  if (len == 0 && val.length == 1 && val[0] === 0) return Buffer.allocUnsafe(0); // if we have a defined length, we should padLeft 00 or cut the left content to ensure length\n\n  if (len > 0 && Buffer.isBuffer(val) && val.length !== len) return val.length < len ? Buffer.concat([Buffer.alloc(len - val.length), val]) : val.slice(val.length - len);\n  return val;\n}\n\nexports.toBuffer = toBuffer;\n/**\n * removes all leading 0 in a hex-string\n */\n\nfunction toSimpleHex(val) {\n  let hex = val.replace('0x', '');\n\n  while (hex.startsWith('00') && hex.length > 2) hex = hex.substr(2);\n\n  return '0x' + hex;\n}\n\nexports.toSimpleHex = toSimpleHex;\n/**\n * returns a address from a private key\n */\n\nfunction getAddress(pk) {\n  const key = toBuffer(pk);\n  return ethUtil.toChecksumAddress(ethUtil.privateToAddress(key).toString('hex'));\n}\n\nexports.getAddress = getAddress;\n/** removes all leading 0 in the hexstring */\n\nfunction toMinHex(key) {\n  if (typeof key === 'number') key = toHex(key);\n\n  if (typeof key === 'string') {\n    key = key.trim();\n    if (key.length < 3 || key[0] != '0' || key[1] != 'x') throw new Error(\"Only Hex format is supported. Given value \" + key + \" is not valid Hex \");\n\n    for (let i = 2; i < key.length; i++) {\n      if (key[i] !== '0') return '0x' + key.substr(i);\n    }\n  } else if (Buffer.isBuffer(key)) {\n    const hex = key.toString('hex');\n\n    for (let i = 0; i < hex.length; i++) {\n      if (hex[i] !== '0') return '0x' + hex.substr(i);\n    }\n  }\n\n  return '0x0';\n}\n\nexports.toMinHex = toMinHex;\n/** padStart for legacy */\n\nfunction padStart(val, minLength, fill = ' ') {\n  while (val.length < minLength) val = fill + val;\n\n  return val;\n}\n\nexports.padStart = padStart;\n/** padEnd for legacy */\n\nfunction padEnd(val, minLength, fill = ' ') {\n  while (val.length < minLength) val = val + fill;\n\n  return val;\n}\n\nexports.padEnd = padEnd;","map":null,"metadata":{},"sourceType":"script"}