{"ast":null,"code":"\"use strict\";\n/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst modules_1 = require(\"./modules\");\n\nconst serverList_1 = require(\"./serverList\");\n\nconst transport_1 = require(\"../util/transport\");\n\nconst chainData_1 = require(\"../modules/eth/chainData\"); // this is an exception, because if we don't know anything about the chain, we must use eth\n\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst util_1 = require(\"../util/util\");\n\nconst cbor_1 = require(\"../util/cbor\");\n\nconst events_1 = require(\"events\");\n\nconst configHandler_1 = require(\"./configHandler\");\n\nconst axios_1 = require(\"axios\");\n\nconst provider_1 = require(\"./provider\");\n\nconst api_1 = require(\"../modules/eth/api\");\n\nconst api_2 = require(\"../modules/ipfs/api\");\n\nconst defaultConfig = require('./defaultConfig.json');\n\nconst CACHEABLE = ['ipfs_get', 'web3_clientVersion', 'web3_sha3', 'net_version', 'eth_protocolVersion', 'eth_coinbase', 'eth_gasPrice', 'eth_accounts', 'eth_getBalance', 'eth_getStorageAt', 'eth_getTransactionCount', 'eth_getBlockTransactionCountByHash', 'eth_getBlockTransactionCountByNumber', 'eth_getUncleCountByBlockHash', 'eth_getUncleCountByBlockNumber', 'eth_getCode', 'eth_sign', 'eth_call', 'eth_estimateGas', 'eth_getBlockByHash', 'eth_getBlockByNumber', 'eth_getTransactionByHash', 'eth_getTransactionByBlockHashAndIndex', 'eth_getTransactionByBlockNumberAndIndex', 'eth_getTransactionReceipt', 'eth_getUncleByBlockHashAndIndex', 'eth_getUncleByBlockNumberAndIndex', 'eth_getCompilers', 'eth_compileLLL', 'eth_compileSolidity', 'eth_compileSerpent', 'eth_getLogs', 'eth_getProof'];\n/** special Error for making sure the correct node is blacklisted */\n\nclass BlackListError extends Error {\n  constructor(msg, addresses) {\n    super(msg);\n    this.addresses = addresses;\n  }\n\n}\n\nexports.BlackListError = BlackListError;\n/**\n * Client for N3.\n *\n */\n\nclass Client extends events_1.EventEmitter {\n  /**\n   * creates a new Client.\n   * @param config the configuration\n   * @param transport a optional transport-object. default: AxiosTransport\n   */\n  constructor(config = {}, transport) {\n    super();\n    if (config && config.autoConfig) this.addListener('beforeRequest', configHandler_1.adjustConfig);\n    this.transport = transport || new transport_1.AxiosTransport(config.format || 'json');\n    this.defConfig = Object.assign({}, defaultConfig, config, {\n      servers: Object.assign({}, defaultConfig.servers, config && config.servers || {})\n    });\n\n    if (config && config.rpc) {\n      // if we have a rpc-endpoint, we create a local chain def.\n      this.defConfig.servers['0xffff'] = {\n        name: 'local rpc',\n        verifier: 'eth',\n        needsUpdate: false,\n        contractChain: '0xffff',\n        contract: '0x0000000000000000000000000000000000000000000000000000000000000000',\n        nodeList: config.rpc.split(',').filter(_ => _).map(url => ({\n          deposit: 0,\n          chainIds: ['0xffff'],\n          address: '0x0000000000000000000000000000000000000000',\n          url,\n          props: 0\n        }))\n      };\n      this.defConfig.proof = 'none';\n      this.defConfig.chainId = '0xffff';\n    }\n\n    verifyConfig(this.defConfig);\n    this.eth = new api_1.default(this);\n    this.ipfs = new api_2.default(this);\n    this.chains = {};\n  } //create a web3 Provider\n\n\n  createWeb3Provider() {\n    const provider = new provider_1.HttpProvider('EthProvider', {}, this);\n    return provider;\n  }\n\n  getChainContext(chainId) {\n    if (this.chains[chainId]) return this.chains[chainId];\n    const chainConf = this.defConfig.servers[chainId];\n    if (!chainConf) throw new Error('chainid ' + chainId + ' does not exist in config!');\n    return this.chains[chainId] = modules_1.getModule(chainConf.verifier || 'eth').createChainContext(this, chainId, chainConf.chainSpec);\n  }\n\n  get config() {\n    return this.defConfig;\n  }\n\n  set config(val) {\n    this.defConfig = val;\n    verifyConfig(this.defConfig);\n  }\n  /**\n   * fetches the nodeList from the servers.\n   * @param chainId if given, the list for the given chainId will be updated otherwise the chainId is taken from the config\n   */\n\n\n  updateNodeList(chainId, conf, retryCount = 5) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.emit('nodeUpdateStarted', {\n        chainId,\n        conf,\n        retryCount\n      });\n      const config = Object.assign({}, this.defConfig, verifyConfig(conf));\n      const chain = util_1.toMinHex(chainId || this.defConfig.chainId || '0x1');\n      if (!chain) throw new Error('No ChainId found to update');\n      const servers = this.defConfig.servers[chain] || (this.defConfig.servers[chain] = {}); // step one : if we don't have the contract yet, we need to find the chain Registry\n\n      if (!servers.contract) {\n        // find main bootNodes\n        if (!this.defConfig.servers[this.defConfig.mainChain]) throw new Error('There are no bootnodes configured for chain ' + this.defConfig.mainChain); // fetch the chain-definition\n\n        const chainData = yield chainData_1.getChainData(this, chain, config); // fill the data\n\n        servers.contract = chainData.registryContract;\n        servers.contractChain = chainData.contractChain; // in the beginning we take the bootnodes as nodelist, but they will overridden after the update\n\n        servers.nodeList = chainData.bootNodes.map(_ => ({\n          address: ethereumjs_util_1.toChecksumAddress(_.split(':')[0]),\n          chainIds: [chain],\n          url: _.substr(_.indexOf(':') + 1),\n          deposit: 0\n        }));\n      } // create a random seed which ensures the deterministic nature of even a partly list.\n\n\n      const seed = '0x' + ethereumjs_util_1.keccak256('0x' + Math.round(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).toString('hex');\n      const nlResponse = yield this.sendRPC('in3_nodeList', [this.defConfig.nodeLimit || 0, seed, servers.initAddresses || []], chain, conf);\n      const nl = nlResponse.result;\n\n      if (config.proof && config.proof != 'none' && nl.contract.toLowerCase() !== servers.contract.toLowerCase()) {\n        // the server gave us the wrong contract!\n        // should we retry?\n        if (retryCount) return this.updateNodeList(chain, conf, retryCount - 1);\n        throw new Error('The server responded with the wrong contract-address : ' + nl.contract);\n      }\n\n      if (servers.lastBlock && servers.lastBlock > nl.lastBlockNumber) throw new Error('The new nodelist has an older blockNumber than the last known!');\n      servers.nodeList = nl.nodes;\n      servers.lastBlock = nl.lastBlockNumber;\n      this.emit('nodeUpdateFinished', {\n        chainId,\n        conf,\n        retryCount,\n        nodeList: nl,\n        nlResponse\n      });\n    });\n  }\n  /**\n   * sends a simply RPC-Request\n   * @param method the method\n   * @param params the params\n   * @param chain a optional chainId (default: chainId from config)\n   * @param config optional config-params overridnig the client config\n   */\n\n\n  sendRPC(method, params = [], chain, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.send({\n        jsonrpc: '2.0',\n        method,\n        params,\n        id: idCount++\n      }, null, Object.assign({\n        chainId: chain || this.defConfig.chainId\n      }, config));\n    });\n  }\n  /**\n   * sends a simply RPC-Request\n   * @param method the method\n   * @param params the params\n   * @param chain a optional chainId (default: chainId from config)\n   * @param config optional config-params overridnig the client config\n   */\n\n\n  call(method, params, chain, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.sendRPC(method, params, chain, config).then(_ => _.error ? Promise.reject(_.error) : _.result);\n    });\n  }\n  /**\n   * sends one or a multiple requests.\n   * if the request is a array the response will be a array as well.\n   * If the callback is given it will be called with the response, if not a Promise will be returned.\n   * This function supports callback so it can be used as a Provider for the web3.\n   */\n\n\n  send(request, callback, config) {\n    const p = this.sendIntern(Array.isArray(request) ? request : [request], config ? Object.assign({}, this.defConfig, verifyConfig(config)) : Object.assign({}, this.defConfig));\n    if (callback) p.then(_ => {\n      this.emit('afterRequest', {\n        request,\n        result: Array.isArray(request) ? _ : _[0]\n      });\n      callback(null, Array.isArray(request) ? _ : _[0]);\n    }, err => {\n      this.emit('error', {\n        request,\n        err\n      });\n      callback(err, null);\n    });else return p.then(_ => Array.isArray(request) ? _ : _[0]).then(result => {\n      this.emit('afterRequest', {\n        request,\n        result\n      });\n      return result;\n    });\n  }\n  /**\n   * clears all stats and weights, like blocklisted nodes\n   */\n\n\n  clearStats() {\n    Object.keys(this.defConfig.servers).forEach(s => delete this.defConfig.servers[s].weights);\n  }\n  /** returns the current nodeList for the chainId specified in the config. If needed it will fetch the nodelist from the server first. */\n\n\n  getNodeList(conf) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const c = Object.assign({}, this.defConfig, conf);\n      if (!c.chainId) throw new Error('no chainId');\n      const server = c.servers[c.chainId];\n\n      if (!server || server.needsUpdate) {\n        server && (server.needsUpdate = false);\n        yield this.updateNodeList(c.chainId);\n      }\n\n      const list = c.servers[c.chainId].nodeList;\n      if (!list || list.length === 0) throw new Error('No NodeList found for chain ' + c.chainId);\n      return list;\n    });\n  }\n  /**\n   * executes the requests\n   * @param requests requests\n   * @param conf full configuration\n   * @param prevExcludes list of nodes to exclude\n   */\n\n\n  sendIntern(requests, conf, prevExcludes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // we trigger an event, so event-handlers can adjust the config\n      this.emit('beforeRequest', {\n        requests,\n        conf\n      }); // filter requests are handled internally and externally\n\n      const internResponses = [];\n      const externRequests = [];\n      const ctx = this.getChainContext(conf.chainId);\n      requests.forEach(r => {\n        const res = ctx.handleIntern(r);\n        if (res) internResponses.push(res);else externRequests.push(r);\n      }); // only intern Requests\n\n      if (externRequests.length === 0) return Promise.all(internResponses); // check nodeList and update if needed\n\n      yield this.getNodeList(conf); // find some random nodes\n\n      const nodes = getNodes(conf, conf.requestCount, this.transport); // merge the given excludes with the choosen nodes, so we know, we will ask them again later.\n\n      const excludes = [...(prevExcludes || []), ...nodes.map(_ => _.address)].filter((e, i, a) => a.indexOf(e) === i); // get the verified responses from the nodes\n\n      let responses = null;\n\n      try {\n        responses = yield Promise.all(nodes.map(_ => handleRequest(externRequests, _, conf, this.transport, this.getChainContext(conf.chainId), [...excludes])));\n      } catch (ex) {\n        // we may retry without proof in order to handle this error\n        if (conf.proof && conf.proof != 'none' && conf.retryWithoutProof) responses = yield Promise.all(nodes.map(_ => handleRequest(externRequests, _, Object.assign({}, conf, {\n          proof: 'none'\n        }), this.transport, this.getChainContext(conf.chainId), [...excludes])));else throw ex;\n      } // merge the result\n\n\n      const result = yield Promise.all(externRequests.map((req, i) => mergeResults(req, responses.map(_ => _[i]), conf, this.transport, this.getChainContext(conf.chainId))));\n      checkForAutoUpdates(conf, result, this); // merge the intern and extern results\n\n      if (internResponses.length) {\n        const result2 = yield Promise.all(internResponses);\n        return requests.map(r => result.find(_ => _.id === r.id) || result2.find(_ => _.id === r.id)).map(conf.keepIn3 ? _ => _ : cleanResult);\n      } else return conf.keepIn3 ? result : result.map(cleanResult);\n    });\n  }\n\n}\n\nexports.default = Client;\nlet idCount = 1;\n\nfunction checkForAutoUpdates(conf, responses, client) {\n  // do we have a lastNodelist? (and it's not a nodeList itself)\n  if (conf.autoUpdateList && responses.find(_ => _.result && !(_.result.contract && _.result.totalServers && _.result.nodes) && _.in3 && _.in3.lastNodeList > 0)) {\n    const blockNumber = responses.reduce((p, c) => Math.max(util_1.toNumber(c.in3 && c.in3.lastNodeList), p), 0);\n    const lastUpdate = conf.servers[conf.chainId].lastBlock;\n\n    if (blockNumber > lastUpdate) {\n      conf.servers[conf.chainId].lastBlock = blockNumber;\n      client.updateNodeList(conf.chainId).catch(err => {\n        client.emit('error', err);\n        conf.servers[conf.chainId].lastBlock = lastUpdate;\n        console.error('Error updating the nodeList!');\n      });\n    }\n  }\n}\n/**\n * merges the results of all responses to one valid one.\n */\n\n\nfunction mergeResults(request, responses, conf, transport, cache) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // if only one left, this is the response\n    if (responses.length === 1) return responses[0]; // no valid response left, means we can not use it.\n    // TODO maybe we should handle this differently by aquirung different nodes then.\n\n    if (responses.length === 0) throw new Error('There are no valid responses left'); // for blocknumbers, we simply ake the highest!\n    // TODO check error and maybe even blocknumbers in the future\n\n    if (request.method === 'eth_blockNumber') return Object.assign({}, responses[0], {\n      result: '0x' + Math.max(...responses.map(_ => parseInt(_.result))).toString(16)\n    }); // how many different results do we have?\n\n    const groups = responses.reduce((g, r) => {\n      const k = JSON.stringify(r.result || r.error && 'error');\n      const list = g[k] || (g[k] = []);\n      list.push(r);\n      return g;\n    }, {}); // do we have responses with proofes?\n\n    const verifiedResponse = responses.find(_ => _.in3 && !!_.in3.proof); // TODO, what if we get different verified responses (like somebody signed a different blockhash)\n    // if we have different result and none if them has a proof, we may want to ask the authorities\n\n    if (Object.keys(groups).length > 1 && !verifiedResponse) {\n      // there are more then one answer!\n      // how are we going to handle the conflict?\n      if (conf.servers[conf.chainId].nodeAuthorities && conf.servers[conf.chainId].nodeAuthorities.length) {\n        // if we have authroities set, we will choose from them\n        const aconf = Object.assign({}, conf, {\n          nodeList: conf.servers[conf.chainId].nodeAuthorities.map(a => conf.servers[conf.chainId].nodeList.find(_ => _.address === a)).filter(_ => _)\n        });\n        const anodes = getNodes(aconf, 1, transport);\n        if (anodes.length) // we simply ask the authrority node\n          return yield handleRequest([request], anodes[0], aconf, transport, cache).then(_ => _[0]);\n      } // hmmm. what else can we do now?\n      // TODO maybe we can support a simple consenus and go with the majority.\n\n\n      throw new Error('The nodes responded with ' + Object.keys(groups).length + ' different answers and there is no authroityNode to resolve the conflict! ');\n    } // if we have a verified Response, we return this, if not, we simply take the first.\n\n\n    return verifiedResponse || responses[0];\n  });\n}\n/**\n * executes a one single request for one node and updates the stats\n */\n\n\nfunction handleRequest(request, node, conf, transport, ctx, excludes, retryCount = 0) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!retryCount) retryCount = (conf.maxAttempts || 2) - 1; // keep the timestamp in order to calc the avgResponseTime\n\n    const start = Date.now(); // get the existing weights\n\n    const weights = conf.servers[conf.chainId].weights || (conf.servers[conf.chainId].weights = {}); // and create one for the node if does not exist yet\n\n    const stats = weights[node.address] || (weights[node.address] = {});\n\n    try {\n      const cacheEntries = request.map(r => {\n        // make sure the requests are valid\n        r.jsonrpc = r.jsonrpc || '2.0';\n        r.id = r.id || idCount++; // append the in3-config\n\n        const in3 = {}; // only if the node supports chainId, we add it, because if the node is a simple remote-server it might refuse the request with additional keys\n\n        if (conf.chainId && serverList_1.canMultiChain(node)) in3.chainId = conf.chainId; // tell server to return finality blocks\n\n        if (conf.finality) in3.finality = conf.finality; // tell server to replace latest with a older block\n\n        if (conf.replaceLatestBlock) in3.latestBlock = conf.replaceLatestBlock; // if we request proof and the node can handle it ...\n\n        if (conf.proof && conf.proof != 'none' && serverList_1.canProof(node) && r.params.indexOf('pending') < 0) {\n          // activate Refs\n          if (conf.format === 'jsonRef') in3.useRef = true;\n          if (conf.proof === 'full') in3.useFullProof = true; // add existing blockhashes\n\n          if (conf.verifiedHashes) in3.verifiedHashes = conf.verifiedHashes; // .. we set the verificationtype\n\n          in3.verification = conf.signatureCount ? 'proofWithSignature' : 'proof';\n          if (conf.signatureCount) // if signatures are requested, we choose some random nodes and create a list of their addresses\n            in3.signatures = getNodes(conf, conf.signatureCount, transport).map(_ => ethereumjs_util_1.toChecksumAddress(_.address)); // ask the server to include the code\n\n          if (conf.includeCode) in3.includeCode = true;\n        } // only if there is something to set, we will add the in3-key and merge it\n\n\n        if (Object.keys(in3).length) r.in3 = Object.assign({}, in3, r.in3); // sign it?\n\n        if (r.in3 && conf.key) {\n          const sig = ethereumjs_util_1.ecsign(ethereumjs_util_1.hashPersonalMessage(Buffer.from(JSON.stringify(r))), conf.key = util_1.toBuffer(conf.key), 1);\n          r.in3.clientSignature = ethereumjs_util_1.toRpcSig(sig.v, sig.r, sig.s, 1);\n        } // prepare cache-entry\n\n\n        if (conf.cacheTimeout && CACHEABLE.indexOf(r.method) >= 0) {\n          const key = r.method + JSON.stringify(r.params).replace(/\\\"/g, '');\n          const content = ctx.getFromCache(key);\n          const json = content && JSON.parse(content);\n          return {\n            key,\n            content: json && json.r,\n            ts: json && json.t\n          };\n        }\n\n        return null;\n      }); // we will sennd all non cachable requests or the ones that timedout\n\n      const toSend = request.filter((r, i) => !cacheEntries[i] || !cacheEntries[i].ts || cacheEntries[i].ts + conf.cacheTimeout * 1000 < start);\n      let resultsFromCache = false; //    console.log(\" send \" + JSON.stringify(toSend) + ' to ' + node.url)\n      // send the request to the server with a timeout\n\n      const responses = toSend.length == 0 ? [] : cbor_1.resolveRefs((yield transport.handle(node.url, toSend, conf.timeout).then(_ => Array.isArray(_) ? _ : [_], err => transport.isOnline().then(o => {\n        // if we are not online we can check if the cache still contains all the results and use it.\n        if (o) throw err;\n        resultsFromCache = true;\n        return toSend.map(r => {\n          const i = request.findIndex(_ => _.id === r.id);\n          if (i >= 0 && cacheEntries[i] && cacheEntries[i].content) return {\n            id: r.id,\n            jsonrpc: r.jsonrpc,\n            result: cacheEntries[i].content\n          };else throw err;\n        });\n      })))); //    console.log(\" res : \" + JSON.stringify(responses))\n\n      if (conf.cacheTimeout && toSend.find(_ => _.method === 'eth_sendRawTransaction')) ctx.clearCache('eth_'); // update stats\n\n      if (!resultsFromCache && responses.length) {\n        stats.responseCount = (stats.responseCount || 0) + 1;\n        stats.avgResponseTime = ((stats.avgResponseTime || 0) * (stats.responseCount - 1) + Date.now() - start) / stats.responseCount;\n        stats.lastRequest = start; // assign the used node to each response\n\n        responses.forEach(_ => _.in3Node = node); // verify each response by checking the proof. This will throw if it can't be verified\n\n        yield Promise.all(responses.map((response, i) => modules_1.verifyProof(request[i], response, // TODO if we ask for a proof of a transactionHash, which does exist, we will not get a proof, which means, this would fail.\n        // maybe we can still deliver a proof, but without data\n        !request[i].in3 || (request[i].in3.verification || 'never') === 'never', ctx))); // add them to cache\n\n        if (conf.cacheTimeout) responses.filter(_ => _.result).forEach(res => {\n          const cacheEntry = cacheEntries[request.findIndex(_ => _.id === res.id)];\n          if (cacheEntry) ctx.putInCache(cacheEntry.key, JSON.stringify({\n            t: start,\n            r: res.result\n          }));\n        });\n      } // merge cache and reponses\n\n\n      const allResponses = request.map((r, i) => responses.find(_ => _.id === r.id) || cacheEntries[i] && cacheEntries[i].content && {\n        id: r.id,\n        jsonrpc: r.jsonrpc,\n        result: cacheEntries[i].content\n      }); // assign the used node to each response\n\n      allResponses.forEach(_ => _.in3Node = node);\n      return allResponses;\n    } catch (err) {\n      // log errors\n      if (conf.loggerUrl) axios_1.default.post(conf.loggerUrl, {\n        level: 'error',\n        message: 'error handling request for ' + node.url + ' : ' + err.message + ' (' + err.stack + ') ',\n        meta: request\n      }).then(_ => _, console.log('Error logging (' + err.message + ') : ', node.url, request));\n\n      if (err instanceof BlackListError) {\n        const n = excludes.indexOf(node.address);\n        if (n >= 0) excludes.splice(n, 1);\n        err.addresses.forEach(adr => {\n          conf.servers[conf.chainId].weights[adr].blacklistedUntil = Date.now() + 3600000 * 2;\n        });\n      } else if (err.message.indexOf('cannot sign') >= 0 && err.message.indexOf('blockHeight') > 0) {\n        // retry without signature\n        let tryAgainWithoutSignature = false;\n        request.forEach(r => {\n          if (r.in3 && r.in3.verification === 'proofWithSignature') {\n            r.in3.verification = 'proof';\n            delete r.in3.signatures;\n            tryAgainWithoutSignature = true;\n          }\n        });\n        if (tryAgainWithoutSignature && retryCount > 0) return handleRequest(request, node, Object.assign({}, conf, {\n          signatureCount: 0\n        }), transport, ctx, excludes, retryCount - 1);\n      } else {\n        // let us check first, if we are the problem.\n        // are we online?\n        if (!(yield transport.isOnline())) throw new Error('Currently there is no online-connection!'); // locally blacklist this node for one hour if it did not respond within the timeout or could not be verified\n\n        stats.blacklistedUntil = Date.now() + 3600000;\n      }\n\n      let otherNodes = null;\n\n      try {\n        // so the node did not answer, let's find a different one\n        otherNodes = getNodes(conf, 1, transport, [...excludes, node.address]);\n      } catch (x) {\n        // if we can't get nodes, it's because there none left to ask\n        throw new Error('tried ' + request.map(_ => _.method).join() + ' but failed and can not recover (' + x.message + ') from wrong response of node ' + node.url + ' did not respond correctly : ' + err);\n      }\n\n      if (!otherNodes.length) throw new Error('The node ' + node.url + ' did not respond correctly (' + err + ') but there is no other node to ask now!');else if (!retryCount) throw new Error('The node ' + node.url + ' did not respond correctly (' + err + ') but we reached the max number of attempts!'); // and we retry but keep a list of excludes to make sure we won't run into loops\n\n      return handleRequest(request, otherNodes[0], conf, transport, ctx, [...excludes, node.address, otherNodes[0].address], retryCount - 1);\n    }\n  });\n}\n/**\n * calculates the weight of a node\n * weight = customWeight * (1 + deposit) * 500/avgResponseTime\n */\n\n\nfunction getWeight(weight, node) {\n  return (weight.weight === undefined ? 1 : weight.weight) * (node.capacity || 1) * (500 / (weight.avgResponseTime || 500));\n}\n/**\n * finds nodes based on the config\n */\n\n\nfunction getNodes(config, count, transport, excludes) {\n  const now = Date.now(); // get the current chain-configuration, which was previously updated\n\n  const chain = config.servers[config.chainId]; // filter-function for the nodeList\n\n  const filter = n => n.deposit >= config.minDeposit && ( // check deposit\n  !excludes || excludes.indexOf(n.address) === -1) && ( // check excluded addresses (because of recursive calls)\n  !chain.weights || ((chain.weights[n.address] || {}).blacklistedUntil || 0) < now); // prefilter for minDeposit && excludes && blacklisted\n\n\n  let nodes = chain.nodeList.filter(filter); // check blacklist\n\n  if (nodes.length === 0) {\n    const blackListed = Object.keys(chain.weights).filter(_ => (!excludes || excludes.indexOf(_) === -1) && chain.weights[_].blacklistedUntil > now); // if more than 50% of the available nodes are currently blacklisted, we might want to clean up our blacklist\n\n    if (blackListed.length > chain.nodeList.length / 2) {\n      blackListed.forEach(_ => chain.weights[_].blacklistedUntil = 0);\n      nodes = chain.nodeList.filter(filter);\n    } else throw new Error('No nodes found that fullfill the filter criteria ');\n  } // in case we don't have enough nodes to randomize, we just need to accept the list as is\n\n\n  if (nodes.length <= count) return nodes; // create a arraw of weights for the nodes\n\n  const weights = nodes.map(_ => ({\n    s: 0,\n    w: getWeight(chain.weights && chain.weights[_.address] || {}, _)\n  }));\n  weights.forEach((_, i) => _.s = i && weights[i - 1].s + weights[i - 1].w); // calculate the total weight\n\n  const total = weights[nodes.length - 1].s + weights[nodes.length - 1].w; // fill from random picks\n\n  const res = []; // ask the transport for a random array. This is done, so the tests may use fixed numbers\n\n  let random = transport.random(count);\n\n  for (let i = 0; i < count; i++) {\n    // pick a random value based on the total weight\n    const r = random[i] * total; // find the index of the pick in the weight-array\n\n    const index = weights.findIndex(_ => _.s > r) - 1;\n    const node = index < 0 ? nodes[nodes.length - 1] : nodes[index]; // if this node was already picked we need to update our random numbers and try again\n\n    if (res.indexOf(node) >= 0) {\n      random = transport.random(count);\n      i--;\n    } else res.push(node);\n  }\n\n  return res;\n}\n\nfunction cleanResult(r) {\n  return r.error ? {\n    jsonrpc: r.jsonrpc,\n    id: r.id,\n    error: r.error\n  } : {\n    jsonrpc: r.jsonrpc,\n    id: r.id,\n    result: r.result\n  };\n}\n\nexports.aliases = {\n  kovan: '0x2a',\n  tobalaba: '0x44d',\n  main: '0x1',\n  ipfs: '0x7d0',\n  mainnet: '0x1',\n  goerli: '0x5'\n};\n\nfunction verifyConfig(conf) {\n  if (!conf) return {};\n  if (!conf.chainId) return conf;\n\n  if (conf.chainId.startsWith('0x')) {\n    if (conf.chainId[2] === '0') conf.chainId = util_1.toMinHex(conf.chainId);\n  } else if (exports.aliases[conf.chainId]) conf.chainId = exports.aliases[conf.chainId];else throw new Error('the chain ' + conf.chainId + ' can not be resolved');\n\n  return conf;\n}","map":null,"metadata":{},"sourceType":"script"}